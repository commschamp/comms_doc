<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1GenericMessage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="GenericMessage_8h_source.html">comms/GenericMessage.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TMessage, typename TFieldOpts = comms::option::app::EmptyOption, typename TExtraOpts = comms::option::app::EmptyOption&gt;<br />
class comms::GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt;</h3>

<p>Generic <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">Message</a>. </p>
<p>Generic message is there to substitute definition of actual message when contents of the latter are not important. It defines single <b>data</b> field as variable length sequence of raw bytes (see <a class="el" href="namespacecomms.html#a7f9725d68be4564134834976fc83ba20">GenericMessageFields</a>). The <a class="el" href="classcomms_1_1GenericMessage.html" title="Generic Message. ">GenericMessage</a> can be useful when implementing some kind of "bridge" or "firewall", that requires knowledge only about message ID and doesn't care much about message contents. The <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a> support creation of the <a class="el" href="classcomms_1_1GenericMessage.html" title="Generic Message. ">GenericMessage</a> in case the received message ID is not known (supported by using <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>Common message interface class, becomes one of the base classes. </td></tr>
    <tr><td class="paramname">TFieldOpts</td><td>Extra option(s) (multiple options need to be bundled in <b>std::tuple</b>) to be passed to the definition of the <b>data</b> field (see <a class="el" href="namespacecomms.html#a7f9725d68be4564134834976fc83ba20">GenericMessageFields</a>). </td></tr>
    <tr><td class="paramname">TExtraOpts</td><td>Extra option(s) (multple options need to be bundled in <b>std::tuple</b>) to be passed to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> which is base to this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires the common message interface (<b>TMessage</b>) to define inner <b>MsgIdType</b> and <b>MsgIdParamType</b> types (expected to use <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a>, see <a class="el" href="page_use_prot.html#page_use_prot_transport_generic_msg">Using Generic Message</a>) </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1GenericMessage.png" usemap="#comms::GenericMessage_3C_20TMessage_2C_20TFieldOpts_2C_20TExtraOpts_20_3E_map" alt=""/>
  <map id="comms::GenericMessage_3C_20TMessage_2C_20TFieldOpts_2C_20TExtraOpts_20_3E_map" name="comms::GenericMessage_3C_20TMessage_2C_20TFieldOpts_2C_20TExtraOpts_20_3E_map">
<area href="classcomms_1_1MessageBase.html" alt="comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, TFieldOpts &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, TExtraOpts &gt;" shape="rect" coords="0,56,1668,80"/>
<area href="classcomms_1_1Message.html" title="Main interface class for all the messages. " alt="comms::Message&lt; TOptions &gt;" shape="rect" coords="0,0,1668,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a87b9da0204520b428fa291676b61b8b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#a87b9da0204520b428fa291676b61b8b9">MsgIdType</a> = typename Base::MsgIdType</td></tr>
<tr class="memdesc:a87b9da0204520b428fa291676b61b8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message ID.  <a href="#a87b9da0204520b428fa291676b61b8b9">More...</a><br /></td></tr>
<tr class="separator:a87b9da0204520b428fa291676b61b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc320f563eba25df652fc662a43bbaf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> = typename <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">Base::MsgIdParamType</a></td></tr>
<tr class="memdesc:abc320f563eba25df652fc662a43bbaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message ID passed as parameter.  <a href="#abc320f563eba25df652fc662a43bbaf7">More...</a><br /></td></tr>
<tr class="separator:abc320f563eba25df652fc662a43bbaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212803732b5ff9a4e60a782e09adfc7"><td class="memItemLeft" align="right" valign="top"><a id="a4212803732b5ff9a4e60a782e09adfc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a4212803732b5ff9a4e60a782e09adfc7">ImplOptions</a> = details::MessageImplOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a4212803732b5ff9a4e60a782e09adfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:a4212803732b5ff9a4e60a782e09adfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108df722c6d6e5016ab6b35b961b43cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> = FieldsProvidedWithOption</td></tr>
<tr class="memdesc:a108df722c6d6e5016ab6b35b961b43cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All field classes provided with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option.  <a href="#a108df722c6d6e5016ab6b35b961b43cd">More...</a><br /></td></tr>
<tr class="separator:a108df722c6d6e5016ab6b35b961b43cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666cf5c4acf17424d67be09c13212c25"><td class="memItemLeft" align="right" valign="top"><a id="a666cf5c4acf17424d67be09c13212c25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a666cf5c4acf17424d67be09c13212c25">InterfaceOptions</a> = details::MessageInterfaceOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a666cf5c4acf17424d67be09c13212c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options bundled into struct. <br /></td></tr>
<tr class="separator:a666cf5c4acf17424d67be09c13212c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb35fb9379a188ce663079c956b3f80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a1bb35fb9379a188ce663079c956b3f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialisation endian type.  <a href="#a1bb35fb9379a188ce663079c956b3f80">More...</a><br /></td></tr>
<tr class="separator:a1bb35fb9379a188ce663079c956b3f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd3705f965f28c601858aced3f16c48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> = BaseImpl::Field</td></tr>
<tr class="memdesc:a4cd3705f965f28c601858aced3f16c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of default base class for all the fields.  <a href="#a4cd3705f965f28c601858aced3f16c48">More...</a><br /></td></tr>
<tr class="separator:a4cd3705f965f28c601858aced3f16c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for reading message contents from sequence of bytes stored somewhere.  <a href="#a463c7edb3734bffca6c41b9cee3d3f0a">More...</a><br /></td></tr>
<tr class="separator:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6698a41e3975ed6047dac727fe9a0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:aee6698a41e3975ed6047dac727fe9a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for writing message contents into sequence of bytes stored somewhere.  <a href="#aee6698a41e3975ed6047dac727fe9a0c">More...</a><br /></td></tr>
<tr class="separator:aee6698a41e3975ed6047dac727fe9a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b17e6aee609c0bb061556f4a0979bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a30b17e6aee609c0bb061556f4a0979bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message handler object.  <a href="#a30b17e6aee609c0bb061556f4a0979bb">More...</a><br /></td></tr>
<tr class="separator:a30b17e6aee609c0bb061556f4a0979bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d474f5037090d6d749419c51f2e100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> = typename Handler::RetType</td></tr>
<tr class="memdesc:a43d474f5037090d6d749419c51f2e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function.  <a href="#a43d474f5037090d6d749419c51f2e100">More...</a><br /></td></tr>
<tr class="separator:a43d474f5037090d6d749419c51f2e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> = FieldsProvidedWithOption</td></tr>
<tr class="memdesc:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized.  <a href="#a1a7c7b92d38774a038fbdedb3e0f99cc">More...</a><br /></td></tr>
<tr class="separator:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1cc4a66938068978b802ae5b76a2d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:adf1cc4a66938068978b802ae5b76a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for version info.  <a href="#adf1cc4a66938068978b802ae5b76a2d1">More...</a><br /></td></tr>
<tr class="separator:adf1cc4a66938068978b802ae5b76a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ffadca41894987f363f0df164869fe0"><td class="memItemLeft" align="right" valign="top"><a id="a1ffadca41894987f363f0df164869fe0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#a1ffadca41894987f363f0df164869fe0">GenericMessage</a> ()=delete</td></tr>
<tr class="memdesc:a1ffadca41894987f363f0df164869fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor is deleted. <br /></td></tr>
<tr class="separator:a1ffadca41894987f363f0df164869fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10607d56879f7f7253f24cf215d6b7c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#a10607d56879f7f7253f24cf215d6b7c7">GenericMessage</a> (<a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> id)</td></tr>
<tr class="memdesc:a10607d56879f7f7253f24cf215d6b7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a10607d56879f7f7253f24cf215d6b7c7">More...</a><br /></td></tr>
<tr class="separator:a10607d56879f7f7253f24cf215d6b7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b04f1df07c2a6b73b3d1e954b67eb7d"><td class="memItemLeft" align="right" valign="top"><a id="a7b04f1df07c2a6b73b3d1e954b67eb7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#a7b04f1df07c2a6b73b3d1e954b67eb7d">GenericMessage</a> (const <a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;)=default</td></tr>
<tr class="memdesc:a7b04f1df07c2a6b73b3d1e954b67eb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a7b04f1df07c2a6b73b3d1e954b67eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918a5f3b53820e77c2bc8a3e5719fec"><td class="memItemLeft" align="right" valign="top"><a id="ac918a5f3b53820e77c2bc8a3e5719fec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#ac918a5f3b53820e77c2bc8a3e5719fec">GenericMessage</a> (<a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ac918a5f3b53820e77c2bc8a3e5719fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ac918a5f3b53820e77c2bc8a3e5719fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82d0346539c62ffcf0a33844a2d5bbe"><td class="memItemLeft" align="right" valign="top"><a id="aa82d0346539c62ffcf0a33844a2d5bbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#aa82d0346539c62ffcf0a33844a2d5bbe">~GenericMessage</a> () noexcept=default</td></tr>
<tr class="memdesc:aa82d0346539c62ffcf0a33844a2d5bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aa82d0346539c62ffcf0a33844a2d5bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac534af601839b2e5ceea9e44dd0e6cb9"><td class="memItemLeft" align="right" valign="top"><a id="ac534af601839b2e5ceea9e44dd0e6cb9"></a>
<a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#ac534af601839b2e5ceea9e44dd0e6cb9">operator=</a> (const <a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;)=default</td></tr>
<tr class="memdesc:ac534af601839b2e5ceea9e44dd0e6cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:ac534af601839b2e5ceea9e44dd0e6cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fe4c61c7e08a4a1ffb0dc37068d61d"><td class="memItemLeft" align="right" valign="top"><a id="a28fe4c61c7e08a4a1ffb0dc37068d61d"></a>
<a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#a28fe4c61c7e08a4a1ffb0dc37068d61d">operator=</a> (<a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a28fe4c61c7e08a4a1ffb0dc37068d61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a28fe4c61c7e08a4a1ffb0dc37068d61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1614f54e7a191ca67673ac7b79cbe2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES</a> (data)</td></tr>
<tr class="memdesc:ad1614f54e7a191ca67673ac7b79cbe2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow access to internal fields.  <a href="#ad1614f54e7a191ca67673ac7b79cbe2e">More...</a><br /></td></tr>
<tr class="separator:ad1614f54e7a191ca67673ac7b79cbe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f227141e59736dc53868dedc06e556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#ab1f227141e59736dc53868dedc06e556">doGetId</a> () const</td></tr>
<tr class="memdesc:ab1f227141e59736dc53868dedc06e556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get message ID information.  <a href="#ab1f227141e59736dc53868dedc06e556">More...</a><br /></td></tr>
<tr class="separator:ab1f227141e59736dc53868dedc06e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28dc6bda95ea08996efbb6e7e5aa880"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html#aa28dc6bda95ea08996efbb6e7e5aa880">doName</a> () const</td></tr>
<tr class="memdesc:aa28dc6bda95ea08996efbb6e7e5aa880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get message name information.  <a href="#aa28dc6bda95ea08996efbb6e7e5aa880">More...</a><br /></td></tr>
<tr class="separator:aa28dc6bda95ea08996efbb6e7e5aa880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a> ()</td></tr>
<tr class="memdesc:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access to the fields of the message.  <a href="#af4b8bc4b6db684d0006d2c6c70b1e891">More...</a><br /></td></tr>
<tr class="separator:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dceebaa69e966780a805b1d4276386e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2dceebaa69e966780a805b1d4276386e">fields</a> () const</td></tr>
<tr class="memdesc:a2dceebaa69e966780a805b1d4276386e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access to the fields of the message.  <a href="#a2dceebaa69e966780a805b1d4276386e">More...</a><br /></td></tr>
<tr class="separator:a2dceebaa69e966780a805b1d4276386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45782845d1f24fc957efe1a41fdf32c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">doRead</a> (TIter &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a45782845d1f24fc957efe1a41fdf32c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of read functionality.  <a href="#a45782845d1f24fc957efe1a41fdf32c4">More...</a><br /></td></tr>
<tr class="separator:a45782845d1f24fc957efe1a41fdf32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e5ec00e39ff64c5f9208813f270468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">doWrite</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a79e5ec00e39ff64c5f9208813f270468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of write functionality.  <a href="#a79e5ec00e39ff64c5f9208813f270468">More...</a><br /></td></tr>
<tr class="separator:a79e5ec00e39ff64c5f9208813f270468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3077fb16f36d4710effc4d61a1330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">doValid</a> () const</td></tr>
<tr class="memdesc:afcb3077fb16f36d4710effc4d61a1330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of validity check functionality.  <a href="#afcb3077fb16f36d4710effc4d61a1330">More...</a><br /></td></tr>
<tr class="separator:afcb3077fb16f36d4710effc4d61a1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb6d8948de99eef4213a234625d3ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh</a> () const</td></tr>
<tr class="memdesc:a2feb6d8948de99eef4213a234625d3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of refreshing functionality.  <a href="#a2feb6d8948de99eef4213a234625d3ec">More...</a><br /></td></tr>
<tr class="separator:a2feb6d8948de99eef4213a234625d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">doLength</a> () const</td></tr>
<tr class="memdesc:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of length calculation functionality.  <a href="#a6d36881b8fea2fa53cc8e17a1e82df27">More...</a><br /></td></tr>
<tr class="separator:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c05d81adc406833e9ead9e4e2c5d51"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a60c05d81adc406833e9ead9e4e2c5d51">doLengthFrom</a> () const</td></tr>
<tr class="memdesc:a60c05d81adc406833e9ead9e4e2c5d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="#a60c05d81adc406833e9ead9e4e2c5d51">More...</a><br /></td></tr>
<tr class="separator:a60c05d81adc406833e9ead9e4e2c5d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d6398fd3e1ddb298e37927d3f7c35"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a869d6398fd3e1ddb298e37927d3f7c35">doLengthUntil</a> () const</td></tr>
<tr class="memdesc:a869d6398fd3e1ddb298e37927d3f7c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="#a869d6398fd3e1ddb298e37927d3f7c35">More...</a><br /></td></tr>
<tr class="separator:a869d6398fd3e1ddb298e37927d3f7c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd333d3fbdb22b7c5386a545a2870d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a21cd333d3fbdb22b7c5386a545a2870d">doLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:a21cd333d3fbdb22b7c5386a545a2870d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="#a21cd333d3fbdb22b7c5386a545a2870d">More...</a><br /></td></tr>
<tr class="separator:a21cd333d3fbdb22b7c5386a545a2870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aa967c1d370f4a40a6cb2f4de2f1f0168">doMinLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="#aa967c1d370f4a40a6cb2f4de2f1f0168">More...</a><br /></td></tr>
<tr class="separator:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a3ba7e14c08930d6fd0e7f2a354cecb9a">doMaxLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="#a3ba7e14c08930d6fd0e7f2a354cecb9a">More...</a><br /></td></tr>
<tr class="separator:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ba954a125586e6a339aad7b0d11e7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">doFieldsVersionUpdate</a> ()</td></tr>
<tr class="memdesc:a87ba954a125586e6a339aad7b0d11e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update version information of all the fields.  <a href="#a87ba954a125586e6a339aad7b0d11e7c">More...</a><br /></td></tr>
<tr class="separator:a87ba954a125586e6a339aad7b0d11e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9fd890f4efb1263179c3799d52098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId</a> () const</td></tr>
<tr class="memdesc:aaac9fd890f4efb1263179c3799d52098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve ID of the message.  <a href="#aaac9fd890f4efb1263179c3799d52098">More...</a><br /></td></tr>
<tr class="separator:aaac9fd890f4efb1263179c3799d52098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77396db2ec7a29de4bf335af49e1d760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a77396db2ec7a29de4bf335af49e1d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message contents using provided iterator.  <a href="#a77396db2ec7a29de4bf335af49e1d760">More...</a><br /></td></tr>
<tr class="separator:a77396db2ec7a29de4bf335af49e1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861cf1ef73973117f7842e567b05a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:ac861cf1ef73973117f7842e567b05a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message contents using provided iterator.  <a href="#ac861cf1ef73973117f7842e567b05a13">More...</a><br /></td></tr>
<tr class="separator:ac861cf1ef73973117f7842e567b05a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62f73f8c7db3745491ce668171af5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid</a> () const</td></tr>
<tr class="memdesc:aeb62f73f8c7db3745491ce668171af5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of message contents.  <a href="#aeb62f73f8c7db3745491ce668171af5f">More...</a><br /></td></tr>
<tr class="separator:aeb62f73f8c7db3745491ce668171af5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dba816185287db6d38a3274743f6cf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length</a> () const</td></tr>
<tr class="memdesc:a91dba816185287db6d38a3274743f6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes required to serialise this message.  <a href="#a91dba816185287db6d38a3274743f6cf">More...</a><br /></td></tr>
<tr class="separator:a91dba816185287db6d38a3274743f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78ac63decb13777fd7d203de01fdd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh</a> ()</td></tr>
<tr class="memdesc:adf78ac63decb13777fd7d203de01fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh to contents of the message.  <a href="#adf78ac63decb13777fd7d203de01fdd1">More...</a><br /></td></tr>
<tr class="separator:adf78ac63decb13777fd7d203de01fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8a1db5b023e576dd74f906dd547ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name</a> () const</td></tr>
<tr class="memdesc:acdc8a1db5b023e576dd74f906dd547ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the message.  <a href="#acdc8a1db5b023e576dd74f906dd547ad">More...</a><br /></td></tr>
<tr class="separator:acdc8a1db5b023e576dd74f906dd547ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler)</td></tr>
<tr class="memdesc:af2781055a9fb72a553d56cfd6ac99c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message to the handler for processing.  <a href="#af2781055a9fb72a553d56cfd6ac99c5e">More...</a><br /></td></tr>
<tr class="separator:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> ()</td></tr>
<tr class="memdesc:a6da7116040cb3e35912aa4b82a2a66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to extra transport fields.  <a href="#a6da7116040cb3e35912aa4b82a2a66b1">More...</a><br /></td></tr>
<tr class="separator:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa610b5478c6c6926ffc83ed5c91b7954">transportFields</a> () const</td></tr>
<tr class="memdesc:aa610b5478c6c6926ffc83ed5c91b7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>.  <a href="#aa610b5478c6c6926ffc83ed5c91b7954">More...</a><br /></td></tr>
<tr class="separator:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">version</a> ()</td></tr>
<tr class="memdesc:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to version information.  <a href="#a5ad5c5b59d08590aba3b1e97f4e8149c">More...</a><br /></td></tr>
<tr class="separator:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472075590eb54b5c660ffc74927f1afc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a472075590eb54b5c660ffc74927f1afc">version</a> () const</td></tr>
<tr class="memdesc:a472075590eb54b5c660ffc74927f1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to version information.  <a href="#a472075590eb54b5c660ffc74927f1afc">More...</a><br /></td></tr>
<tr class="separator:a472075590eb54b5c660ffc74927f1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a34ba95e7ac41051fa41b5f559c1c0018"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a34ba95e7ac41051fa41b5f559c1c0018">areFieldsVersionDependent</a> ()</td></tr>
<tr class="memdesc:a34ba95e7ac41051fa41b5f559c1c0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the message fields are version dependent.  <a href="#a34ba95e7ac41051fa41b5f559c1c0018">More...</a><br /></td></tr>
<tr class="separator:a34ba95e7ac41051fa41b5f559c1c0018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad51591454e5bc2a293743d2d1671d5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5">doGetId</a> ()</td></tr>
<tr class="memdesc:afad51591454e5bc2a293743d2d1671d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of ID retrieval functionality.  <a href="#afad51591454e5bc2a293743d2d1671d5">More...</a><br /></td></tr>
<tr class="separator:afad51591454e5bc2a293743d2d1671d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength</a> ()</td></tr>
<tr class="memdesc:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal serialisation length.  <a href="#a6e9b89aab4e8cd2e60095f1d6ac9eb40">More...</a><br /></td></tr>
<tr class="separator:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a1d36b0b3b6eec0319a4d8be725a56c52">doMinLengthFrom</a> ()</td></tr>
<tr class="memdesc:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="#a1d36b0b3b6eec0319a4d8be725a56c52">More...</a><br /></td></tr>
<tr class="separator:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf42c9d15d9cacb72dba9a4742609be"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afdf42c9d15d9cacb72dba9a4742609be">doMinLengthUntil</a> ()</td></tr>
<tr class="memdesc:afdf42c9d15d9cacb72dba9a4742609be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="#afdf42c9d15d9cacb72dba9a4742609be">More...</a><br /></td></tr>
<tr class="separator:afdf42c9d15d9cacb72dba9a4742609be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff048412f531c1d7294a3a96e34e03c0"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength</a> ()</td></tr>
<tr class="memdesc:aff048412f531c1d7294a3a96e34e03c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal serialisation length.  <a href="#aff048412f531c1d7294a3a96e34e03c0">More...</a><br /></td></tr>
<tr class="separator:aff048412f531c1d7294a3a96e34e03c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8579127c444abfb0923116b27c53efc"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ab8579127c444abfb0923116b27c53efc">doMaxLengthFrom</a> ()</td></tr>
<tr class="memdesc:ab8579127c444abfb0923116b27c53efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="#ab8579127c444abfb0923116b27c53efc">More...</a><br /></td></tr>
<tr class="separator:ab8579127c444abfb0923116b27c53efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25a2572c9d2ccc74ef764ead6701608"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac25a2572c9d2ccc74ef764ead6701608">doMaxLengthUntil</a> ()</td></tr>
<tr class="memdesc:ac25a2572c9d2ccc74ef764ead6701608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="#ac25a2572c9d2ccc74ef764ead6701608">More...</a><br /></td></tr>
<tr class="separator:ac25a2572c9d2ccc74ef764ead6701608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37efad282638409ff120b999954c2117"><td class="memItemLeft" align="right" valign="top"><a id="a37efad282638409ff120b999954c2117"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a37efad282638409ff120b999954c2117">hasMsgIdType</a> ()</td></tr>
<tr class="memdesc:a37efad282638409ff120b999954c2117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> and <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> types. <br /></td></tr>
<tr class="separator:a37efad282638409ff120b999954c2117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13724033c28237b389725d379d1f5b9f"><td class="memItemLeft" align="right" valign="top"><a id="a13724033c28237b389725d379d1f5b9f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian</a> ()</td></tr>
<tr class="memdesc:a13724033c28237b389725d379d1f5b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> and <a class="el" href="classcomms_1_1Field.html">Field</a> types. <br /></td></tr>
<tr class="separator:a13724033c28237b389725d379d1f5b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memItemLeft" align="right" valign="top"><a id="aa00be33cb01b7e9cdee9ecebfa54c171"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId</a> ()</td></tr>
<tr class="memdesc:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId()</a> and <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memItemLeft" align="right" valign="top"><a id="a1cab88111f9e395e71f8a8eb05c99fb5"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead</a> ()</td></tr>
<tr class="memdesc:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read()</a> and <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> type. <br /></td></tr>
<tr class="separator:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memItemLeft" align="right" valign="top"><a id="aa7a317a10acda2cd7affd8b69a7b459a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite</a> ()</td></tr>
<tr class="memdesc:aa7a317a10acda2cd7affd8b69a7b459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write()</a> and <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">writeImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> type. <br /></td></tr>
<tr class="separator:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133c135fda72ca2257fed0f5427053b4"><td class="memItemLeft" align="right" valign="top"><a id="a133c135fda72ca2257fed0f5427053b4"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid</a> ()</td></tr>
<tr class="memdesc:a133c135fda72ca2257fed0f5427053b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid()</a> and <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">validImpl()</a> member functions. <br /></td></tr>
<tr class="separator:a133c135fda72ca2257fed0f5427053b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaded9d46874a89824e91c962524836d"><td class="memItemLeft" align="right" valign="top"><a id="aaaded9d46874a89824e91c962524836d"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength</a> ()</td></tr>
<tr class="memdesc:aaaded9d46874a89824e91c962524836d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> and <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">lengthImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aaaded9d46874a89824e91c962524836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memItemLeft" align="right" valign="top"><a id="ae0929a96d1cb0c12a2b2a383ebd015ef"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ae0929a96d1cb0c12a2b2a383ebd015ef">hasRefresh</a> ()</td></tr>
<tr class="memdesc:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh()</a> and <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">refreshImpl()</a> member functions. <br /></td></tr>
<tr class="separator:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memItemLeft" align="right" valign="top"><a id="aec8ad53f1b5aa5f06a0d47c7d9585783"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aec8ad53f1b5aa5f06a0d47c7d9585783">hasDispatch</a> ()</td></tr>
<tr class="memdesc:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> and <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">dispatchImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> and <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> types. <br /></td></tr>
<tr class="separator:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memItemLeft" align="right" valign="top"><a id="a57f6dc0452da23c5cdf25ec56b26df80"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields</a> ()</td></tr>
<tr class="memdesc:a57f6dc0452da23c5cdf25ec56b26df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> type. <br /></td></tr>
<tr class="separator:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8cdb390a3a51811a5a836cff0b7828"><td class="memItemLeft" align="right" valign="top"><a id="afa8cdb390a3a51811a5a836cff0b7828"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#afa8cdb390a3a51811a5a836cff0b7828">hasVersionInTransportFields</a> ()</td></tr>
<tr class="memdesc:afa8cdb390a3a51811a5a836cff0b7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether there is version information inside transport fields. <br /></td></tr>
<tr class="separator:afa8cdb390a3a51811a5a836cff0b7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaf6e76e7639112d33a04683a4e1a43"><td class="memItemLeft" align="right" valign="top"><a id="abcaf6e76e7639112d33a04683a4e1a43"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName</a> ()</td></tr>
<tr class="memdesc:abcaf6e76e7639112d33a04683a4e1a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name()</a> and <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">nameImpl()</a> member functions. <br /></td></tr>
<tr class="separator:abcaf6e76e7639112d33a04683a4e1a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2194842a823f51fb02f2e3622550798a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">getIdImpl</a> () const override</td></tr>
<tr class="memdesc:a2194842a823f51fb02f2e3622550798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ID retrieval functionality.  <a href="#a2194842a823f51fb02f2e3622550798a">More...</a><br /></td></tr>
<tr class="separator:a2194842a823f51fb02f2e3622550798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c99a8d76e578261d01388ee3848e40e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">dispatchImpl</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler) override</td></tr>
<tr class="memdesc:a6c99a8d76e578261d01388ee3848e40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of dispatch functionality.  <a href="#a6c99a8d76e578261d01388ee3848e40e">More...</a><br /></td></tr>
<tr class="separator:a6c99a8d76e578261d01388ee3848e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bf76bcd33967e6fc543480c1643114"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">readImpl</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size) override</td></tr>
<tr class="memdesc:a53bf76bcd33967e6fc543480c1643114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic read functionality.  <a href="#a53bf76bcd33967e6fc543480c1643114">More...</a><br /></td></tr>
<tr class="separator:a53bf76bcd33967e6fc543480c1643114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af335676e4b4f9667887443aa7c6482ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:af335676e4b4f9667887443aa7c6482ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#af335676e4b4f9667887443aa7c6482ea">More...</a><br /></td></tr>
<tr class="separator:af335676e4b4f9667887443aa7c6482ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a04675c280e76ad35a9996fc29274f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac5a04675c280e76ad35a9996fc29274f">doReadUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ac5a04675c280e76ad35a9996fc29274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but updating length parameter.  <a href="#ac5a04675c280e76ad35a9996fc29274f">More...</a><br /></td></tr>
<tr class="separator:ac5a04675c280e76ad35a9996fc29274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d28011159c7a2adccf151304e88f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a231d28011159c7a2adccf151304e88f7">doReadNoStatusUntil</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a231d28011159c7a2adccf151304e88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#a231d28011159c7a2adccf151304e88f7">More...</a><br /></td></tr>
<tr class="separator:a231d28011159c7a2adccf151304e88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1370aa1f188ead8dee2091cffb691c65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a1370aa1f188ead8dee2091cffb691c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#a1370aa1f188ead8dee2091cffb691c65">More...</a><br /></td></tr>
<tr class="separator:a1370aa1f188ead8dee2091cffb691c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0022211e70afa1b915ecd2bd74c9b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac0022211e70afa1b915ecd2bd74c9b39">doReadFromAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ac0022211e70afa1b915ecd2bd74c9b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but modifies length parameter.  <a href="#ac0022211e70afa1b915ecd2bd74c9b39">More...</a><br /></td></tr>
<tr class="separator:ac0022211e70afa1b915ecd2bd74c9b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dac1f0e29db4e1904f89688299d5003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a5dac1f0e29db4e1904f89688299d5003">doReadNoStatusFrom</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a5dac1f0e29db4e1904f89688299d5003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#a5dac1f0e29db4e1904f89688299d5003">More...</a><br /></td></tr>
<tr class="separator:a5dac1f0e29db4e1904f89688299d5003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46df98c07723fa701f74b1b03c63a508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a46df98c07723fa701f74b1b03c63a508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#a46df98c07723fa701f74b1b03c63a508">More...</a><br /></td></tr>
<tr class="separator:a46df98c07723fa701f74b1b03c63a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce678a197ee7bfc4a4c7493813a4db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afce678a197ee7bfc4a4c7493813a4db2">doReadFromUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:afce678a197ee7bfc4a4c7493813a4db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but modifies length parameter.  <a href="#afce678a197ee7bfc4a4c7493813a4db2">More...</a><br /></td></tr>
<tr class="separator:afce678a197ee7bfc4a4c7493813a4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aeb3836dc4c1e9517a4331a9e80b53a11">doReadNoStatusFromUntil</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="#aeb3836dc4c1e9517a4331a9e80b53a11">More...</a><br /></td></tr>
<tr class="separator:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58412054c729f562ed1d99fda27fbf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">writeImpl</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const override</td></tr>
<tr class="memdesc:a7b58412054c729f562ed1d99fda27fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic write functionality.  <a href="#a7b58412054c729f562ed1d99fda27fbf">More...</a><br /></td></tr>
<tr class="separator:a7b58412054c729f562ed1d99fda27fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6848f65ab796a33517c3d48aa78de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:aa8e6848f65ab796a33517c3d48aa78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#aa8e6848f65ab796a33517c3d48aa78de">More...</a><br /></td></tr>
<tr class="separator:aa8e6848f65ab796a33517c3d48aa78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb223527d8d06a853aaf1b3ec2166d"><td class="memItemLeft" align="right" valign="top"><a id="a15eb223527d8d06a853aaf1b3ec2166d"></a>
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a15eb223527d8d06a853aaf1b3ec2166d">doWriteUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a15eb223527d8d06a853aaf1b3ec2166d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a>, but modifies length parameter. <br /></td></tr>
<tr class="separator:a15eb223527d8d06a853aaf1b3ec2166d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077d4c33307dac9474366666e22ac3f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a077d4c33307dac9474366666e22ac3f7">doWriteNoStatusUntil</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:a077d4c33307dac9474366666e22ac3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#a077d4c33307dac9474366666e22ac3f7">More...</a><br /></td></tr>
<tr class="separator:a077d4c33307dac9474366666e22ac3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#a54e6eb8daaf93a8671d3f8e5e0e32f46">More...</a><br /></td></tr>
<tr class="separator:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3385ab7b850a9d3825860be5b303bd6d"><td class="memItemLeft" align="right" valign="top"><a id="a3385ab7b850a9d3825860be5b303bd6d"></a>
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a3385ab7b850a9d3825860be5b303bd6d">doWriteFromAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a3385ab7b850a9d3825860be5b303bd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a>, but modifies length parameter. <br /></td></tr>
<tr class="separator:a3385ab7b850a9d3825860be5b303bd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5040afe5026d3f2840cd53b77eddf4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a5040afe5026d3f2840cd53b77eddf4e8">doWriteNoStatusFrom</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:a5040afe5026d3f2840cd53b77eddf4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#a5040afe5026d3f2840cd53b77eddf4e8">More...</a><br /></td></tr>
<tr class="separator:a5040afe5026d3f2840cd53b77eddf4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11a7be936db0cdce89540264b295619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:ae11a7be936db0cdce89540264b295619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#ae11a7be936db0cdce89540264b295619">More...</a><br /></td></tr>
<tr class="separator:ae11a7be936db0cdce89540264b295619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="memItemLeft" align="right" valign="top"><a id="a2281fd57ba4d05ac3cd4e15e9f802934"></a>
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2281fd57ba4d05ac3cd4e15e9f802934">doWriteFromUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a5040afe5026d3f2840cd53b77eddf4e8">doWriteNoStatusFrom()</a>, but updates length information. <br /></td></tr>
<tr class="separator:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ae21e997e8d813d21c3fe7ff0c145fbd6">doWriteNoStatusFromUntil</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="#ae21e997e8d813d21c3fe7ff0c145fbd6">More...</a><br /></td></tr>
<tr class="separator:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab1fe69accb75656f90e903da24fdc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc">validImpl</a> () const override</td></tr>
<tr class="memdesc:abeab1fe69accb75656f90e903da24fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic validity check functionality.  <a href="#abeab1fe69accb75656f90e903da24fdc">More...</a><br /></td></tr>
<tr class="separator:abeab1fe69accb75656f90e903da24fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8">lengthImpl</a> () const override</td></tr>
<tr class="memdesc:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic length calculation functionality.  <a href="#a9bc67df1b7b19a2a4263173d3badf8b8">More...</a><br /></td></tr>
<tr class="separator:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b9cea8e73c2f592ffd55fd274893ba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">refreshImpl</a> () override</td></tr>
<tr class="memdesc:a49b9cea8e73c2f592ffd55fd274893ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic refresh functionality.  <a href="#a49b9cea8e73c2f592ffd55fd274893ba">More...</a><br /></td></tr>
<tr class="separator:a49b9cea8e73c2f592ffd55fd274893ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6888dd9d8d070ac042a13ac48fc334"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">nameImpl</a> () const override</td></tr>
<tr class="memdesc:a4b6888dd9d8d070ac042a13ac48fc334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic name retrieval functionality.  <a href="#a4b6888dd9d8d070ac042a13ac48fc334">More...</a><br /></td></tr>
<tr class="separator:a4b6888dd9d8d070ac042a13ac48fc334"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ebf1dd77a1c6458392a9001d187ad45">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:a5ebf1dd77a1c6458392a9001d187ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output area.  <a href="#a5ebf1dd77a1c6458392a9001d187ad45">More...</a><br /></td></tr>
<tr class="separator:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abe23293aedd424af62bd5f4d05571b59">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:abe23293aedd424af62bd5f4d05571b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output area.  <a href="#abe23293aedd424af62bd5f4d05571b59">More...</a><br /></td></tr>
<tr class="separator:abe23293aedd424af62bd5f4d05571b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:ac484455094ac1eb1aa189bdc6d527ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input area.  <a href="#ac484455094ac1eb1aa189bdc6d527ded">More...</a><br /></td></tr>
<tr class="separator:ac484455094ac1eb1aa189bdc6d527ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a51c517d87946dea783a006f34a9868c8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a51c517d87946dea783a006f34a9868c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input area.  <a href="#a51c517d87946dea783a006f34a9868c8">More...</a><br /></td></tr>
<tr class="separator:a51c517d87946dea783a006f34a9868c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a789a34136ca38375d494820dd74c51e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a789a34136ca38375d494820dd74c51e5">operator==</a> (const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;msg1, const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;msg2)</td></tr>
<tr class="memdesc:a789a34136ca38375d494820dd74c51e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message object equality comparison operator.  <a href="#a789a34136ca38375d494820dd74c51e5">More...</a><br /></td></tr>
<tr class="separator:a789a34136ca38375d494820dd74c51e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2a76d7a2f93ebbcc0eb61d57ee628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ab2f2a76d7a2f93ebbcc0eb61d57ee628">operator!=</a> (const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;msg1, const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;msg2)</td></tr>
<tr class="memdesc:ab2f2a76d7a2f93ebbcc0eb61d57ee628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message object inequality comparison operator.  <a href="#ab2f2a76d7a2f93ebbcc0eb61d57ee628">More...</a><br /></td></tr>
<tr class="separator:ab2f2a76d7a2f93ebbcc0eb61d57ee628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cd34ed5b338241067433c45d7345ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:a25cd34ed5b338241067433c45d7345ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to message fields.  <a href="#a25cd34ed5b338241067433c45d7345ac">More...</a><br /></td></tr>
<tr class="separator:a25cd34ed5b338241067433c45d7345ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70987da383935a4cf0ceb5228f497a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a2c70987da383935a4cf0ceb5228f497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for message fields.  <a href="#a2c70987da383935a4cf0ceb5228f497a">More...</a><br /></td></tr>
<tr class="separator:a2c70987da383935a4cf0ceb5228f497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">COMMS_MSG_FIELD_ALIAS_ACCESS</a>(f_, ...)</td></tr>
<tr class="memdesc:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for other member fields.  <a href="#ab20effdb4cb453bd6b2eb86246b6ede1">More...</a><br /></td></tr>
<tr class="separator:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(f_, ...)</td></tr>
<tr class="memdesc:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias types and access member functions for other member fields.  <a href="#a43c008e2ba360d9dd4917a1c9f80bd38">More...</a><br /></td></tr>
<tr class="separator:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada784673f02d483a88fcf0c451cb72bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:ada784673f02d483a88fcf0c451cb72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to extra transport fields.  <a href="#ada784673f02d483a88fcf0c451cb72bd">More...</a><br /></td></tr>
<tr class="separator:ada784673f02d483a88fcf0c451cb72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00912bb201d47afbb0c3e51fff95b338"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a00912bb201d47afbb0c3e51fff95b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for extra transport fields.  <a href="#a00912bb201d47afbb0c3e51fff95b338">More...</a><br /></td></tr>
<tr class="separator:a00912bb201d47afbb0c3e51fff95b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, ...)&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td></tr>
<tr class="memdesc:a33954a8d8c1b0e04175ada3e840bcb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="#a33954a8d8c1b0e04175ada3e840bcb83">More...</a><br /></td></tr>
<tr class="separator:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(f_, ...)</td></tr>
<tr class="memdesc:adfa416afa2a8a77af9c46b42d3034f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="#adfa416afa2a8a77af9c46b42d3034f3e">More...</a><br /></td></tr>
<tr class="separator:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a108df722c6d6e5016ab6b35b961b43cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108df722c6d6e5016ab6b35b961b43cd">&#9670;&nbsp;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::<a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> =  FieldsProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All field classes provided with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p>
<p>The type is not defined if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. </p>

</div>
</div>
<a id="a43d474f5037090d6d749419c51f2e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d474f5037090d6d749419c51f2e100">&#9670;&nbsp;</a></span>DispatchRetType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> =  typename Handler::RetType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function. </p>
<p>Equal to <b>Handler::RetType</b> if such exists, <b>void</b> otherwise. </p>

</div>
</div>
<a id="a1bb35fb9379a188ce663079c956b3f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb35fb9379a188ce663079c956b3f80">&#9670;&nbsp;</a></span>Endian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> =  typename BaseImpl::Endian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialisation endian type. </p>
<p>The type exists only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used to specify it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian()</a> </dd></dl>

</div>
</div>
<a id="a4cd3705f965f28c601858aced3f16c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd3705f965f28c601858aced3f16c48">&#9670;&nbsp;</a></span>Field</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> =  BaseImpl::Field</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of default base class for all the fields. </p>
<p>Requires definition of the <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> type, i.e. the type exist only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used. </p>

</div>
</div>
<a id="a30b17e6aee609c0bb061556f4a0979bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b17e6aee609c0bb061556f4a0979bb">&#9670;&nbsp;</a></span>Handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the message handler object. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify one. </p>

</div>
</div>
<a id="abc320f563eba25df652fc662a43bbaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc320f563eba25df652fc662a43bbaf7">&#9670;&nbsp;</a></span>MsgIdParamType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::<a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> =  typename <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">Base::MsgIdParamType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the message ID passed as parameter. </p>
<p>The same as <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03" title="Type used for message ID passed as parameter or returned from function. ">comms::Message::MsgIdParamType</a>; </p>

</div>
</div>
<a id="a87b9da0204520b428fa291676b61b8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b9da0204520b428fa291676b61b8b9">&#9670;&nbsp;</a></span>MsgIdType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::<a class="el" href="classcomms_1_1GenericMessage.html#a87b9da0204520b428fa291676b61b8b9">MsgIdType</a> =  typename Base::MsgIdType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the message ID. </p>
<p>The same as <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2" title="Type used for message ID. ">comms::Message::MsgIdType</a>; </p>

</div>
</div>
<a id="a463c7edb3734bffca6c41b9cee3d3f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463c7edb3734bffca6c41b9cee3d3f0a">&#9670;&nbsp;</a></span>ReadIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the iterator used for reading message contents from sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="a1a7c7b92d38774a038fbdedb3e0f99cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7c7b92d38774a038fbdedb3e0f99cc">&#9670;&nbsp;</a></span>TransportFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> =  FieldsProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="adf1cc4a66938068978b802ae5b76a2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1cc4a66938068978b802ae5b76a2d1">&#9670;&nbsp;</a></span>VersionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> =  typename BaseImpl::VersionType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for version info. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="aee6698a41e3975ed6047dac727fe9a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6698a41e3975ed6047dac727fe9a0c">&#9670;&nbsp;</a></span>WriteIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the iterator used for writing message contents into sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a10607d56879f7f7253f24cf215d6b7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10607d56879f7f7253f24cf215d6b7c7">&#9670;&nbsp;</a></span>GenericMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::<a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34ba95e7ac41051fa41b5f559c1c0018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ba95e7ac41051fa41b5f559c1c0018">&#9670;&nbsp;</a></span>areFieldsVersionDependent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::areFieldsVersionDependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check of whether the message fields are version dependent. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if at least one of the fields is version dependent. </dd></dl>

</div>
</div>
<a id="ad1614f54e7a191ca67673ac7b79cbe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1614f54e7a191ca67673ac7b79cbe2e">&#9670;&nbsp;</a></span>COMMS_MSG_FIELDS_NAMES()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::COMMS_MSG_FIELDS_NAMES </td>
          <td>(</td>
          <td class="paramtype">data&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow access to internal fields. </p>
<p>See definition of <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a> macro related to <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a></b> class for details. </p>

</div>
</div>
<a id="af2781055a9fb72a553d56cfd6ac99c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2781055a9fb72a553d56cfd6ac99c5e">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch message to the handler for processing. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify type of the handler. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e" title="Implementation of dispatch functionality. ">dispatchImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Handler object to dispatch message to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c99a8d76e578261d01388ee3848e40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c99a8d76e578261d01388ee3848e40e">&#9670;&nbsp;</a></span>dispatchImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::dispatchImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of dispatch functionality. </p>
<p>This function exists only if the following conditions are <b>true:</b> </p><ul>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify actual type of the inheriting message class. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoDispatchImpl.html">comms::option::app::NoDispatchImpl</a> option was <b>NOT</b> used.</li>
</ul>
<p>In order to properly implement the dispatch functionality this class imposes several requirements. First of all, the custom message class must provide its own type as an argument to <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessageBase :  <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt; { ...};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Message1 :</div><div class="line">    <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div><div class="line">        MyMessageBase,</div><div class="line">        ...</div><div class="line">        comms::option::def::MsgType&lt;Message1&gt;</div><div class="line">        ...</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    ...</div><div class="line">};</div></div><!-- fragment --><p> Second, The <a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> type (inherited from <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>) must implement "handle()" member function for every message type (specified as Message1, Message2, ...) it is supposed to handle: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(Message1&amp; msg);</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(Message2&amp; msg);</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> The "handle()" functions may be virtual. If the handler is capable of handling only limited number of messages, there is a need to provide additional "handle()" member function to implement default handling functionality (usually ignore the message by doing nothing) for all other messages that weren't handled explicitly. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(MessageBase&amp; msg);</div><div class="line">}</div></div><!-- fragment --><p> Where "MessageBase" is a common base class for all the possible messages.</p>
<p>Once the requirements above are properly implemented, the implementation of this message is very simple: </p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="code" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">dispatchImpl</a>(<a class="code" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a>&amp; handler)</div><div class="line">{</div><div class="line">    <span class="keyword">typedef</span> &lt;actual-message-type-provided-with-option&gt; Actual;</div><div class="line">    <span class="keywordflow">return</span> handler.handle(static_cast&lt;Actual&amp;&gt;(*<span class="keyword">this</span>));</div><div class="line">}</div></div><!-- fragment --><p> The code above forces a compiler to choose appropriate <b>handle()</b> function in the Handler class, based on the actual type of the message. If such function is not found, the compiler will choose to call the one that covers all possible messages <b>"void handle(MessageBase&amp; msg)"</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Reference to handler object. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a87ba954a125586e6a339aad7b0d11e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ba954a125586e6a339aad7b0d11e7c">&#9670;&nbsp;</a></span>doFieldsVersionUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doFieldsVersionUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update version information of all the fields. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> and <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> was provided to the message interface class (<a class="el" href="classcomms_1_1Message.html">comms::Message</a>). <br />
 This function will invoke such <b>setVersion()</b> member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option and will return <b>true</b> if <b>at least</b> one of the invoked functions returned <b>true</b> (similar to <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh()</a>). </p><dl class="section return"><dt>Returns</dt><dd>true when <b>at least</b> one of the fields has been updated. </dd></dl>

</div>
</div>
<a id="afad51591454e5bc2a293743d2d1671d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad51591454e5bc2a293743d2d1671d5">&#9670;&nbsp;</a></span>doGetId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doGetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of ID retrieval functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. <br />
</p><dl class="section return"><dt>Returns</dt><dd>Numeric ID of the message. </dd></dl>

</div>
</div>
<a id="ab1f227141e59736dc53868dedc06e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f227141e59736dc53868dedc06e556">&#9670;&nbsp;</a></span>doGetId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::doGetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get message ID information. </p>
<p>The <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a" title="Implementation of ID retrieval functionality. ">comms::MessageBase::getIdImpl()</a> will invoke this function. </p>

</div>
</div>
<a id="a6d36881b8fea2fa53cc8e17a1e82df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d36881b8fea2fa53cc8e17a1e82df27">&#9670;&nbsp;</a></span>doLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of length calculation functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. To make this function works, every field class must provide "length()" function with following signature: </p><div class="fragment"><div class="line">std::size_t <a class="code" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length</a>() <span class="keyword">const</span>;</div></div><!-- fragment --><p> This function will invoke such "length()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. The final result is a summary of the "length" values of all the fields. </p><dl class="section return"><dt>Returns</dt><dd>Serialisation length of the message. </dd></dl>

</div>
</div>
<a id="a60c05d81adc406833e9ead9e4e2c5d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c05d81adc406833e9ead9e4e2c5d51">&#9670;&nbsp;</a></span>doLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a21cd333d3fbdb22b7c5386a545a2870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cd333d3fbdb22b7c5386a545a2870d">&#9670;&nbsp;</a></span>doLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a869d6398fd3e1ddb298e37927d3f7c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869d6398fd3e1ddb298e37927d3f7c35">&#9670;&nbsp;</a></span>doLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aff048412f531c1d7294a3a96e34e03c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff048412f531c1d7294a3a96e34e03c0">&#9670;&nbsp;</a></span>doMaxLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal serialisation length. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. To make this function works, every field class must provide "maxLength()" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr std::size_t maxLength();</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Minimal serialisation length of the message. </dd></dl>

</div>
</div>
<a id="ab8579127c444abfb0923116b27c53efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8579127c444abfb0923116b27c53efc">&#9670;&nbsp;</a></span>doMaxLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a3ba7e14c08930d6fd0e7f2a354cecb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba7e14c08930d6fd0e7f2a354cecb9a">&#9670;&nbsp;</a></span>doMaxLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="ac25a2572c9d2ccc74ef764ead6701608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a2572c9d2ccc74ef764ead6701608">&#9670;&nbsp;</a></span>doMaxLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a6e9b89aab4e8cd2e60095f1d6ac9eb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9b89aab4e8cd2e60095f1d6ac9eb40">&#9670;&nbsp;</a></span>doMinLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal serialisation length. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. To make this function works, every field class must provide "minLength()" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr std::size_t minLength();</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Minimal serialisation length of the message. </dd></dl>

</div>
</div>
<a id="a1d36b0b3b6eec0319a4d8be725a56c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36b0b3b6eec0319a4d8be725a56c52">&#9670;&nbsp;</a></span>doMinLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aa967c1d370f4a40a6cb2f4de2f1f0168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa967c1d370f4a40a6cb2f4de2f1f0168">&#9670;&nbsp;</a></span>doMinLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="afdf42c9d15d9cacb72dba9a4742609be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf42c9d15d9cacb72dba9a4742609be">&#9670;&nbsp;</a></span>doMinLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aa28dc6bda95ea08996efbb6e7e5aa880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28dc6bda95ea08996efbb6e7e5aa880">&#9670;&nbsp;</a></span>doName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TFieldOpts  = comms::option::app::EmptyOption, typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>&lt; TMessage, TFieldOpts, TExtraOpts &gt;::doName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get message name information. </p>
<p>The <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334" title="Implementation of polymorphic name retrieval functionality. ">comms::MessageBase::nameImpl()</a> will invoke this function. </p>

</div>
</div>
<a id="a45782845d1f24fc957efe1a41fdf32c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45782845d1f24fc957efe1a41fdf32c4">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of read functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. <br />
 To make this function works, every field class must provide "read" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a>(TIter&amp; iter, std::size_t size);</div></div><!-- fragment --><p> This function will invoke such "read()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. If any field doesn't report <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation. ">ErrorStatus::Success</a>, then read operation stops, i.e. the provided iterator is not advanced any more. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a1370aa1f188ead8dee2091cffb691c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1370aa1f188ead8dee2091cffb691c65">&#9670;&nbsp;</a></span>doReadFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other field exists or must be skipped. In this case the derived class must implement different read functionality. To help in such task <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a> function allows to read fields up to a specified one, while this function provides an ability to resume reading from some other field in the middle. The overriding <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> function in the custom message definition class may use this function for such task. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read from. The function reads all the fields between the one indexed TIdx (included) and the last one (also included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ac0022211e70afa1b915ecd2bd74c9b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0022211e70afa1b915ecd2bd74c9b39">&#9670;&nbsp;</a></span>doReadFromAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but modifies length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46df98c07723fa701f74b1b03c63a508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46df98c07723fa701f74b1b03c63a508">&#9670;&nbsp;</a></span>doReadFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other fields exist or must be skipped. In this case the derived class must implement different read functionality. In similar way to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65" title="Helper function that allows to read only limited number of fields. ">doReadFrom()</a> and <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea" title="Helper function that allows to read only limited number of fields. ">doReadUntil()</a> this function provides an ability to read any number of fields. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to read from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to read until (not included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="afce678a197ee7bfc4a4c7493813a4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce678a197ee7bfc4a4c7493813a4db2">&#9670;&nbsp;</a></span>doReadFromUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but modifies length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dac1f0e29db4e1904f89688299d5003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dac1f0e29db4e1904f89688299d5003">&#9670;&nbsp;</a></span>doReadNoStatusFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read from. The function reads all the fields between the one indexed TIdx (included) and the last one (also included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aeb3836dc4c1e9517a4331a9e80b53a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3836dc4c1e9517a4331a9e80b53a11">&#9670;&nbsp;</a></span>doReadNoStatusFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to read from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to read until (not included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a231d28011159c7a2adccf151304e88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231d28011159c7a2adccf151304e88f7">&#9670;&nbsp;</a></span>doReadNoStatusUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read until. The function returns when field with index "TIdx - 1" (if such exists) has been read, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="af335676e4b4f9667887443aa7c6482ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af335676e4b4f9667887443aa7c6482ea">&#9670;&nbsp;</a></span>doReadUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other field exists or must be skipped. In this case the derived class must implement different read functionality. To help in such task this function provides an ability to read all the fields up to (not including) requested field. The overriding <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> function in the custom message definition class may use this function for such task. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read until. The function returns when field with index "TIdx - 1" (if such exists) has been read, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ac5a04675c280e76ad35a9996fc29274f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a04675c280e76ad35a9996fc29274f">&#9670;&nbsp;</a></span>doReadUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but updating length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2feb6d8948de99eef4213a234625d3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb6d8948de99eef4213a234625d3ec">&#9670;&nbsp;</a></span>doRefresh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doRefresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of refreshing functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. To make this function works, every field class must provide "refresh()" function with following signature: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh</a>() <span class="keyword">const</span>;</div></div><!-- fragment --><p> This function will invoke such "refresh()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option and will return <b>true</b> if <b>at least</b> one of the invoked functions returned <b>true</b>. </p><dl class="section return"><dt>Returns</dt><dd>true when <b>at least</b> one of the fields has been updated. </dd></dl>

</div>
</div>
<a id="afcb3077fb16f36d4710effc4d61a1330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3077fb16f36d4710effc4d61a1330">&#9670;&nbsp;</a></span>doValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of validity check functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. To make this function works, every field class must provide "valid()" function with following signature: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid</a>() <span class="keyword">const</span>;</div></div><!-- fragment --><p> This function will invoke such "valid()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="section return"><dt>Returns</dt><dd>true when <b>all</b> fields are valid. </dd></dl>

</div>
</div>
<a id="a79e5ec00e39ff64c5f9208813f270468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e5ec00e39ff64c5f9208813f270468">&#9670;&nbsp;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of write functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. <br />
 To make this function works, every field class must provide "write" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write</a>(TIter&amp; iter, std::size_t size) <span class="keyword">const</span>;</div></div><!-- fragment --><p> This function will invoke such "write()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. If any field doesn't report <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation. ">ErrorStatus::Success</a>, then write operation stops, i.e. the provided iterator is not advanced any more. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a54e6eb8daaf93a8671d3f8e5e0e32f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e6eb8daaf93a8671d3f8e5e0e32f46">&#9670;&nbsp;</a></span>doWriteFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65" title="Helper function that allows to read only limited number of fields. ">doReadFrom()</a>, this function allows writing limited number of fields starting from the requested one until the end. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality. ">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ae11a7be936db0cdce89540264b295619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11a7be936db0cdce89540264b295619">&#9670;&nbsp;</a></span>doWriteFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508" title="Helper function that allows to read only limited number of fields. ">doReadFromUntil()</a>, this function allows writing limited number of fields between the requested indices. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality. ">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to write until (not including). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a5040afe5026d3f2840cd53b77eddf4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5040afe5026d3f2840cd53b77eddf4e8">&#9670;&nbsp;</a></span>doWriteNoStatusFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ae21e997e8d813d21c3fe7ff0c145fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21e997e8d813d21c3fe7ff0c145fbd6">&#9670;&nbsp;</a></span>doWriteNoStatusFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to write until (not including). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a077d4c33307dac9474366666e22ac3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077d4c33307dac9474366666e22ac3f7">&#9670;&nbsp;</a></span>doWriteNoStatusUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write until. The function returns when field with index "TIdx - 1" (if such exists) has been written, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aa8e6848f65ab796a33517c3d48aa78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e6848f65ab796a33517c3d48aa78de">&#9670;&nbsp;</a></span>doWriteUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea" title="Helper function that allows to read only limited number of fields. ">doReadUntil()</a>, this function allows writing limited number of fields starting from the first one. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality. ">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write until. The function returns when field with index "TIdx - 1" (if such exists) has been written, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="af4b8bc4b6db684d0006d2c6c70b1e891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b8bc4b6db684d0006d2c6c70b1e891">&#9670;&nbsp;</a></span>fields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a>&amp; <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an access to the fields of the message. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd>Reference to the fields of the message. </dd></dl>

</div>
</div>
<a id="a2dceebaa69e966780a805b1d4276386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dceebaa69e966780a805b1d4276386e">&#9670;&nbsp;</a></span>fields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a>&amp; <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an access to the fields of the message. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages. ">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd>Const reference to the fields of the message. </dd></dl>

</div>
</div>
<a id="aaac9fd890f4efb1263179c3799d52098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9fd890f4efb1263179c3799d52098">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve ID of the message. </p>
<p>Invokes pure virtual <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">getIdImpl()</a>. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used to specify type of the ID value and <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option are used. </p><dl class="section return"><dt>Returns</dt><dd>ID of the message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId()</a>; </dd></dl>

</div>
</div>
<a id="a2194842a823f51fb02f2e3622550798a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2194842a823f51fb02f2e3622550798a">&#9670;&nbsp;</a></span>getIdImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1GenericMessage.html#abc320f563eba25df652fc662a43bbaf7">MsgIdParamType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::getIdImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of ID retrieval functionality. </p>
<p>This function may exist only if ID retrieval is possible, i.e. the ID type has been privded to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> using <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option and the polymorphic ID retrieval functionality was requested (using <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a>). In addition to the conditions listed earlier this function is provided if local <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality. ">doGetId()</a> function was generated. If not, it may still be provided if the derived class is known (<a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used) and the <a class="el" href="structcomms_1_1option_1_1def_1_1HasDoGetId.html">comms::option::def::HasDoGetId</a> option is used to declare the derived type having <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality. ">doGetId()</a> member function defined. </p><dl class="section return"><dt>Returns</dt><dd>ID value passed as template parameter to <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option. </dd></dl>

<p>Implements <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a91dba816185287db6d38a3274743f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dba816185287db6d38a3274743f6cf">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of bytes required to serialise this message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality. ">lengthImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes required to serialise this message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength()</a> </dd></dl>

</div>
</div>
<a id="a9bc67df1b7b19a2a4263173d3badf8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc67df1b7b19a2a4263173d3badf8b8">&#9670;&nbsp;</a></span>lengthImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::lengthImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic length calculation functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoLengthImpl.html">comms::option::app::NoLengthImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27" title="Default implementation of length calculation functionality. ">doLength()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27" title="Default implementation of length calculation functionality. ">comms::MessageBase::doLength()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="section return"><dt>Returns</dt><dd>Serialisation length of the message. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="acdc8a1db5b023e576dd74f906dd547ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8a1db5b023e576dd74f906dd547ad">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of the message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">nameImpl()</a> function. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName()</a> </dd></dl>

</div>
</div>
<a id="a4b6888dd9d8d070ac042a13ac48fc334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6888dd9d8d070ac042a13ac48fc334">&#9670;&nbsp;</a></span>nameImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::nameImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic name retrieval functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> as well as <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> options ware used for this class. This function downcasts <b>this</b> pointer to actual message type and invokes <b><a class="el" href="classcomms_1_1GenericMessage.html#aa28dc6bda95ea08996efbb6e7e5aa880" title="Get message name information. ">doName()</a></b> member function. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> in case fields were updated, <b>false</b> if nothing has changed. </dd></dl>

<p>Implements <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a77396db2ec7a29de4bf335af49e1d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77396db2ec7a29de4bf335af49e1d760">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a>. The contents of the message are updated with bytes being read. The buffer is external and maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality. ">readImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="ac484455094ac1eb1aa189bdc6d527ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac484455094ac1eb1aa189bdc6d527ded">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input area. </p>
<p>Use this function to read data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a51c517d87946dea783a006f34a9868c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c517d87946dea783a006f34a9868c8">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input area. </p>
<p>Use this function to read partial data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a53bf76bcd33967e6fc543480c1643114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bf76bcd33967e6fc543480c1643114">&#9670;&nbsp;</a></span>readImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::readImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic read functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoReadImpl.html">comms::option::app::NoReadImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">doRead()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality. ">comms::MessageBase::doRead()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="adf78ac63decb13777fd7d203de01fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78ac63decb13777fd7d203de01fdd1">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh to contents of the message. </p>
<p>Many protocols define their messages in a way that the content of some fields may depend on the value of the other field(s). For example, providing in one field the information about number of elements in the list that will follow later. Another example is having bits in a bitmask field specifying whether other optional fields exist. In this case, directly modifying value of some fields may leave a message contents in an inconsistent state. Having <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1" title="Refresh to contents of the message. ">refresh()</a> member function allows the developer to bring the message into a consistent state prior to sending it over I/O link . <br />
 The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba" title="Implementation of polymorphic refresh functionality. ">refreshImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true in case the contents of the message were modified, false if all the fields of the message remained unchanged. </dd></dl>

</div>
</div>
<a id="a49b9cea8e73c2f592ffd55fd274893ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b9cea8e73c2f592ffd55fd274893ba">&#9670;&nbsp;</a></span>refreshImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::refreshImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic refresh functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> option was used (either on on of the fields or when defining a message class) to to notify about existence of custom refresh functionality. If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual message class, the <b>this</b> pointer will be downcasted to it to invoke <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec" title="Default implementation of refreshing functionality. ">doRefresh()</a> member function defined there. If such is not defined the default <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec" title="Default implementation of refreshing functionality. ">doRefresh()</a> member function from this class will be used. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> in case fields were updated, <b>false</b> if nothing has changed. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a6da7116040cb3e35912aa4b82a2a66b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da7116040cb3e35912aa4b82a2a66b1">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to extra transport fields. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. Some protocols may use additional values in transport information, such as message version for example. Such values may influence the way message data is being serialized / deserialized. The provided extra transport fields are <b>NOT</b> serialised as part of message payload. Their values are expected to be set by transport layer(s) when such information is read. The transport layers are also responsible to take the updated information from the relevant field and write it when message contents being written. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aa610b5478c6c6926ffc83ed5c91b7954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610b5478c6c6926ffc83ed5c91b7954">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aeb62f73f8c7db3745491ce668171af5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62f73f8c7db3745491ce668171af5f">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check validity of message contents. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality. ">validImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true for valid contents, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid()</a> </dd></dl>

</div>
</div>
<a id="abeab1fe69accb75656f90e903da24fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeab1fe69accb75656f90e903da24fdc">&#9670;&nbsp;</a></span>validImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::validImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic validity check functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoValidImpl.html">comms::option::app::NoValidImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330" title="Default implementation of validity check functionality. ">doValid()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330" title="Default implementation of validity check functionality. ">comms::MessageBase::doValid()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a5ad5c5b59d08590aba3b1e97f4e8149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad5c5b59d08590aba3b1e97f4e8149c">&#9670;&nbsp;</a></span>version() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="a472075590eb54b5c660ffc74927f1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472075590eb54b5c660ffc74927f1afc">&#9670;&nbsp;</a></span>version() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="ac861cf1ef73973117f7842e567b05a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac861cf1ef73973117f7842e567b05a13">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a>. The contents of the message are serialised into buffer. The buffer is external and is maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf" title="Implementation of polymorphic write functionality. ">writeImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<a id="a5ebf1dd77a1c6458392a9001d187ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf1dd77a1c6458392a9001d187ad45">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output area. </p>
<p>Use this function to write data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="abe23293aedd424af62bd5f4d05571b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23293aedd424af62bd5f4d05571b59">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output area. </p>
<p>Use this function to write partial data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a7b58412054c729f562ed1d99fda27fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58412054c729f562ed1d99fda27fbf">&#9670;&nbsp;</a></span>writeImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::writeImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic write functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoWriteImpl.html">comms::option::app::NoWriteImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality. ">doWrite()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality. ">comms::MessageBase::doWrite()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a43c008e2ba360d9dd4917a1c9f80bd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c008e2ba360d9dd4917a1c9f80bd38">&#9670;&nbsp;</a></span>COMMS_MSG_FIELD_ALIAS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELD_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias types and access member functions for other member fields. </p>
<p>The <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a> macro generates inner types and convenience access member functions for member fields. Sometimes the fields may get renamed or moved to be a member of other fields, like <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> or <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In such case the compilation of the existing client code (that already uses published protocol definition) may fail. To avoid such scenarios and make the transition to newer versions of the protocol easier, the <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> macro can be used to create alias to other fields. For example, let's assume that some message class was defined: like this. </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, name3);</div><div class="line">};</div></div><!-- fragment --><p> In the future versions of the protocol "name3" was renamed to "newName3". To keep the existing code (that uses "name3" name) compiling it is possible to create an alias access function(s) with: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, newName3);</div><div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(name3, newName3);</div><div class="line">};</div></div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions as well as type defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Field_name3 = Field_newName3;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(field_newName3())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> field_newName3();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(field_newName3())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> field_newName3();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Another example would be a replacing a <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> with <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> in the future version of the protocol. It can happen when the developer decides to split the used storage into multiple values (because the range of the used/valid values allows so). In order to keep the old client code compiling, the access to the replaced field needs to be an alias to the first member of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In this case the usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> will look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, newName3);</div><div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(name3, newName3, member1);</div><div class="line">};</div></div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Field_name3 = <span class="keyword">typename</span> Field_newName3::Field_member1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(field_newName3().field_member1())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(field_newName3().field_member1())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a> needs to be used before <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1" title="Generate convinience alias access member functions for other member fields. ">COMMS_MSG_FIELD_ALIAS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="ab20effdb4cb453bd6b2eb86246b6ede1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20effdb4cb453bd6b2eb86246b6ede1">&#9670;&nbsp;</a></span>COMMS_MSG_FIELD_ALIAS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELD_ALIAS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias access member functions for other member fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> but requires usage of <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> instead of <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a> and does NOT create alias to the field type, only access functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> needs to be used before <a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">COMMS_MSG_FIELD_ALIAS_ACCESS()</a> to define convenience access functions.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> </dd></dl>

</div>
</div>
<a id="a25cd34ed5b338241067433c45d7345ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cd34ed5b338241067433c45d7345ac">&#9670;&nbsp;</a></span>COMMS_MSG_FIELDS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELDS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add convenience access enum and functions to message fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>Field_*</b> types for used fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="a2c70987da383935a4cf0ceb5228f497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70987da383935a4cf0ceb5228f497a">&#9670;&nbsp;</a></span>COMMS_MSG_FIELDS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELDS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names for message fields. </p>
<p>The <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class provides access to its fields via <a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields()</a> member function(s). The fields are bundled into <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and can be accessed using indices with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. For convenience, the fields should be named. The <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e" title="Allow access to internal fields. ">COMMS_MSG_FIELDS_NAMES()</a> macro does exactly that. <br />
 As an example, let's assume that custom message uses 3 fields of any types: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Field1 = ... <span class="comment">/* some field definition */</span>;</div><div class="line"><span class="keyword">using</span> Field2 = ... <span class="comment">/* some field definition */</span>;</div><div class="line"><span class="keyword">using</span> Field3 = ... <span class="comment">/* some field definition */</span>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Message1Fields = std::tuple&lt;Field1, Field2, Field3&gt;;</div><div class="line"></div><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div><div class="line">        MyInterface,</div><div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&gt;,</div><div class="line">        ... <span class="comment">/* some other options */</span>&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Base class (re) definition required by COMMS_MSG_FIELDS_NAMES()</span></div><div class="line">    <span class="keyword">using</span> Base =</div><div class="line">        <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div><div class="line">            MyInterface,</div><div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl&lt;Message1Fields&gt;</a>,</div><div class="line">            ... <span class="comment">/* some other options */</span>&gt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Provide names for message fields</span></div><div class="line">    <a class="code" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, name3);</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> that there is a required to have <b>Base</b> member type that specifies base class used. It is needed to be able to access <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">comms::MessageBase::AllFields</a> type definition.</p>
<p>The usage of the <a class="el" href="classcomms_1_1GenericMessage.html#ad1614f54e7a191ca67673ac7b79cbe2e" title="Allow access to internal fields. ">COMMS_MSG_FIELDS_NAMES()</a> macro with the list of the field's names is equivalent to having the following definitions inside the message class </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Indices of the fields</span></div><div class="line">    <span class="keyword">enum</span> FieldIdx {</div><div class="line">        FieldIdx_name1,</div><div class="line">        FieldIdx_name2,</div><div class="line">        FieldIdx_name3,</div><div class="line">        FieldIdx_nameOfValues</div><div class="line">    };</div><div class="line"></div><div class="line">    static_assert(std::tuple_size&lt;Base::AllFields&gt;::value == FieldIdx_nameOfValues,</div><div class="line">        <span class="stringliteral">&quot;Number of expected fields is incorrect&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name1() -&gt; decltype(std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name1() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name1&gt;(Base::fields()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name2() -&gt; decltype(std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name2() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name2&gt;(Base::fields()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name3&gt;(Base::fields()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">Base::fields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Redefinition of the field types:</span></div><div class="line">    <span class="keyword">using</span> Field_name1 = Field1;</div><div class="line">    <span class="keyword">using</span> Field_name2 = Field2;</div><div class="line">    <span class="keyword">using</span> Field_name3 = Field3;</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>name1</b>, <b>name2</b>, and <b>name3</b> have found their way to the following definitions: </p><ul>
<li><b>FieldIdx</b> enum. The names are prefixed with <b>FieldIdx_</b>. The <b>FieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>field_*</b> </li>
<li>Types of fields prefixed with <b>Field_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using <b>FieldIdx</b> enum </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; allFields = msg.fields();</div><div class="line">    <span class="keyword">auto</span>&amp; field1 = std::get&lt;Message1::FieldIdx_name1&gt;(allFields);</div><div class="line">    <span class="keyword">auto</span>&amp; field2 = std::get&lt;Message1::FieldIdx_name2&gt;(allFields);</div><div class="line">    <span class="keyword">auto</span>&amp; field3 = std::get&lt;Message1::FieldIdx_name3&gt;(allFields);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> value1 = field1.value();</div><div class="line">    <span class="keyword">auto</span> value2 = field2.value();</div><div class="line">    <span class="keyword">auto</span> value3 = field3.value();</div><div class="line">}</div></div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> value1 = field_name1().value();</div><div class="line">    <span class="keyword">auto</span> value2 = field_name2().value();</div><div class="line">    <span class="keyword">auto</span> value3 = field_name3().value();</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires (re)definition of the message base class as inner <b>Base</b> member type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac" title="Add convenience access enum and functions to message fields. ">COMMS_MSG_FIELDS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="adfa416afa2a8a77af9c46b42d3034f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa416afa2a8a77af9c46b42d3034f3e">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, __VA_ARGS__)) \</div><div class="line">    COMMS_EXPAND(COMMS_DO_ALIAS_TYPEDEF(TransportField_, f_, __VA_ARGS__))</div></div><!-- fragment -->
<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro generates alias type as well as convenience access member functions for extra transport fields. Sometimes the fields may get renamed or moved to be a member of other fields, like <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> or <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In such case the compilation of the existing client code (that already uses published protocol definition) may fail. To avoid such scenarios and make the transition to newer versions of the protocol easier, the <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> macro can be used to create alias to other fields. For example, let's assume that some common interface class was defined: like this. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div><div class="line">};</div></div><!-- fragment --><p> In the future versions of the protocol "name3" was renamed to "newName3". To keep the existing code (that uses "name3" name) compiling it is possible to create an alias access function(s) with: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3);</div><div class="line">};</div></div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following type and functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Another example would be a replacing a <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> with <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> in the future version of the protocol. It can happen when the developer decides to split the used storage into multiple values (because the range of the used/valid values allows so). In order to keep the old client code compiling, the access to the replaced field needs to be an alias to the first member of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In this case the usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> will look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3, member1);</div><div class="line">};</div></div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3::Field_Member1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3().field_member1())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3().field_member1())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> transportField_newName3().field_member1();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="Message_8h.html#a6fe96d7272148945853ce61572b3d4b1">COMMS_MSG_TRANSPORT_FIELD_ALIAS_NOTEMPLATE()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a33954a8d8c1b0e04175ada3e840bcb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33954a8d8c1b0e04175ada3e840bcb83">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> but requires usage of <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> instead of <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> and does NOT create alias to the field type, only access functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="ada784673f02d483a88fcf0c451cb72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada784673f02d483a88fcf0c451cb72bd">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">COMMS_EXPAND(COMMS_DEFINE_TRANSPORT_FIELD_ENUM(__VA_ARGS__)) \</div><div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_FUNC { \</div><div class="line">        auto&amp; msgBase = <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*<span class="keyword">this</span>); \</div><div class="line">        using MsgBase = <span class="keyword">typename</span> std::decay&lt;decltype(msgBase)&gt;::type; \</div><div class="line">        static_assert(MsgBase::hasTransportFields(), \</div><div class="line">            <span class="stringliteral">&quot;Message interface class doesn&#39;t define extra transport fields.&quot;</span>); \</div><div class="line">        using TransportFieldsTuple = <span class="keyword">typename</span> MsgBase::TransportFields; \</div><div class="line">        static_assert(std::tuple_size&lt;TransportFieldsTuple&gt;::value == TransportFieldIdx_numOfValues, \</div><div class="line">            <span class="stringliteral">&quot;Invalid number of names for transport fields tuple&quot;</span>); \</div><div class="line">        return msgBase.transportFields(); \</div><div class="line">    } \</div><div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_CONST_FUNC { \</div><div class="line">        return <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*this).transportFields(); \</div><div class="line">    } \</div><div class="line">    COMMS_EXPAND(COMMS_DO_TRANSPORT_FIELD_ACC_FUNC(<a class="code" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>, <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>(), __VA_ARGS__))</div></div><!-- fragment -->
<p>Add convenience access enum and functions to extra transport fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>TransportField_*</b> types for used fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields. ">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a00912bb201d47afbb0c3e51fff95b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00912bb201d47afbb0c3e51fff95b338">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(__VA_ARGS__)) \</div><div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_TYPEDEF(<span class="keyword">typename</span> Base::TransportFields, TransportField_, TransportFieldIdx_, __VA_ARGS__))</div></div><!-- fragment -->
<p>Provide names for extra transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">comms::Message</a> class provides access to its extra transport fields via <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1" title="Get access to extra transport fields. ">comms::MessageBase::transportFields()</a> member function(s). The fields are bundled into <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and can be accessed using indices with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. For convenience, the fields should be named. The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields. ">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro does exactly that. <br />
 As an example, let's assume that custom message uses 3 fields of any types: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TransportField1 = ...;</div><div class="line"><span class="keyword">using</span> TransportField2 = ...;</div><div class="line"><span class="keyword">using</span> TransportField3 = ...;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;TransportField1, TransportField2, TransportField3&gt; MyExtraTransportFields</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div><div class="line">        ...</div><div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt; &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div><div class="line">    <span class="comment">// required by the COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro.</span></div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div><div class="line">};</div></div><!-- fragment --><p> The usage of the <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields. ">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro with the list of the extra transport field's names is equivalent to having the following definitions inside the message class </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> TransportFieldIdx {</div><div class="line">        TransportFieldIdx_name1,</div><div class="line">        TransportFieldIdx_name2,</div><div class="line">        TransportFieldIdx_name3,</div><div class="line">        TransportFieldIdx_nameOfValues</div><div class="line">    };</div><div class="line"></div><div class="line">    static_assert(std::tuple_size&lt;Base::TransportFields&gt;::value == TransportFieldIdx_nameOfValues,</div><div class="line">        <span class="stringliteral">&quot;Number of expected transport fields is incorrect&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name1&quot; transport field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name1() -&gt; decltype(std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name1() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name1&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name2() -&gt; decltype(std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name2() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name2&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div><div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_name3&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">Base::transportFields</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Redefinition of the transport field types:</span></div><div class="line">    <span class="keyword">using</span> TransportField_name1 = TransportField1;</div><div class="line">    <span class="keyword">using</span> TransportField_name2 = TransportField2;</div><div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField3;</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>name1</b>, <b>name2</b>, and <b>name3</b> have found their way to the following definitions: </p><ul>
<li><b>TransportFieldIdx</b> enum. The names are prefixed with <b>TransportFieldIdx_</b>. The <b>TransportFieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>transportField_*</b> </li>
<li>Types of fields prefixed with <b>TransportField_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using <b>TransportFieldIdx</b> enum </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> = msg.transportFields();</div><div class="line">    <span class="keyword">auto</span>&amp; field1 = std::get&lt;Message1::TransportFieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div><div class="line">    <span class="keyword">auto</span>&amp; field2 = std::get&lt;Message1::TransportFieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div><div class="line">    <span class="keyword">auto</span>&amp; field3 = std::get&lt;Message1::TransportFieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> value1 = field1.value();</div><div class="line">    <span class="keyword">auto</span> value2 = field2.value();</div><div class="line">    <span class="keyword">auto</span> value3 = field3.value();</div><div class="line">}</div></div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> value1 = transportField_name1().value();</div><div class="line">    <span class="keyword">auto</span> value2 = transportField_name2().value();</div><div class="line">    <span class="keyword">auto</span> value3 = transportField_name3().value();</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires (re)definition of the message base class as inner <b>Base</b> member type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd" title="Add convenience access enum and functions to extra transport fields. ">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="ab2f2a76d7a2f93ebbcc0eb61d57ee628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f2a76d7a2f93ebbcc0eb61d57ee628">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">Message</a> object inequality comparison operator. </p>
<p>Messages are considered not equal if any their fields are considered inequal. </p>

</div>
</div>
<a id="a789a34136ca38375d494820dd74c51e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789a34136ca38375d494820dd74c51e5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages. ">Message</a> object equality comparison operator. </p>
<p>Messages are considered equal if all their fields are considered equal </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/<a class="el" href="GenericMessage_8h_source.html">GenericMessage.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 17 2019 07:39:41 for COMMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
