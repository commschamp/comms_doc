<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::Message&lt; TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="classcomms_1_1Message.html">Message</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1Message-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::Message&lt; TOptions &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="Message_8h_source.html">comms/Message.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... TOptions&gt;<br />
class comms::Message&lt; TOptions &gt;</h3>

<p>Main interface class for all the messages. </p>
<p>Provides basic interface for all the messages. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TOptions</td><td>Variadic template parameter that contain any number of options to define functionality/behaviour of the message. The options may be comma separated as well as bundled into std::tuple. Supported options are: <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> - options used to specify endianness of the serialisation. If this option is <a class="el" href="classcomms_1_1Field.html">Field</a> internal types get defined. used, <a class="el" href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded" title="Read data from input area.">readData()</a> functions as well as <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> and </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> - an option used to specify type of the ID value used to identify the message. If this option is used, the <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> and <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> types get defined. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> - Provide extra fields that are read / written by transport layers, but may influence the way the message being serialized / deserialized and/or handled. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> - Provide index of the version field in extra transport fields. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> - an option used to provide polymorphic id retrieval functionality. If this option is used in conjunction with <a class="el" href="namespacecomms_1_1option.html#ae116d8be9449c27165351b3f07151284" title="Same as comms::option::def::MsgIdType.">comms::option::MsgIdType</a>, the <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098" title="Retrieve ID of the message.">getId()</a> member function is defined. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> - an option used to specify type of iterator used for reading. If this option is not used, then <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read()</a> member function doesn't exist. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> - an option used to specify type of iterator used for writing. If this option is not used, then <a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write()</a> member function doesn't exist. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> - an option used to add <a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid()</a> member function to the default interface. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> - an option used to add <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function to the default interface. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> - an option used to add <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh()</a> member function to the default interface. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> - an option used to add <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name()</a> member function to the default interface. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> - an option used to specify type of message handler object used to handle the message when it received. If this option is not used, then <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e" title="Dispatch message to the handler for processing.">dispatch()</a> member function doesn't exist. See <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e" title="Dispatch message to the handler for processing.">dispatch()</a> documentation for details. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoVirtualDestructor.html">comms::option::app::NoVirtualDestructor</a> - Force the destructor to be non-virtual, even if there are virtual functions in use.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd" title="Add convenience access enum and functions to extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::Message&lt; TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1Message.png" usemap="#comms::Message_3C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::Message_3C_20TOptions_20_3E_map" name="comms::Message_3C_20TOptions_20_3E_map">
<area href="classcomms_1_1MessageBase.html" alt="comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;" shape="rect" coords="0,56,2150,80"/>
<area href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages." alt="comms::MessageBase&lt; TMessage, TOptions &gt;" shape="rect" coords="2160,56,4310,80"/>
<area href="classcomms_1_1GenericMessage.html" title="Generic Message." alt="comms::GenericMessage&lt; TMessage, TFieldOpts, TExtraOpts &gt;" shape="rect" coords="0,112,2150,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43d474f5037090d6d749419c51f2e100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> = typename Handler::RetType</td></tr>
<tr class="memdesc:a43d474f5037090d6d749419c51f2e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function.  <a href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">More...</a><br /></td></tr>
<tr class="separator:a43d474f5037090d6d749419c51f2e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb35fb9379a188ce663079c956b3f80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a1bb35fb9379a188ce663079c956b3f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialisation endian type.  <a href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">More...</a><br /></td></tr>
<tr class="separator:a1bb35fb9379a188ce663079c956b3f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd3705f965f28c601858aced3f16c48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> = BaseImpl::Field</td></tr>
<tr class="memdesc:a4cd3705f965f28c601858aced3f16c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of default base class for all the fields.  <a href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">More...</a><br /></td></tr>
<tr class="separator:a4cd3705f965f28c601858aced3f16c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b17e6aee609c0bb061556f4a0979bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a30b17e6aee609c0bb061556f4a0979bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message handler object.  <a href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">More...</a><br /></td></tr>
<tr class="separator:a30b17e6aee609c0bb061556f4a0979bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666cf5c4acf17424d67be09c13212c25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a666cf5c4acf17424d67be09c13212c25">InterfaceOptions</a> = details::MessageInterfaceOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a666cf5c4acf17424d67be09c13212c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options bundled into struct.  <a href="classcomms_1_1Message.html#a666cf5c4acf17424d67be09c13212c25">More...</a><br /></td></tr>
<tr class="separator:a666cf5c4acf17424d67be09c13212c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99780161941773e6bbe2767675c4a03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> = typename BaseImpl::MsgIdParamType</td></tr>
<tr class="memdesc:aa99780161941773e6bbe2767675c4a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for message ID passed as parameter or returned from function.  <a href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">More...</a><br /></td></tr>
<tr class="separator:aa99780161941773e6bbe2767675c4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> = typename BaseImpl::MsgIdType</td></tr>
<tr class="memdesc:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for message ID.  <a href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">More...</a><br /></td></tr>
<tr class="separator:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for reading message contents from sequence of bytes stored somewhere.  <a href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">More...</a><br /></td></tr>
<tr class="separator:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> = FieldsProvidedWithOption</td></tr>
<tr class="memdesc:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized.  <a href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">More...</a><br /></td></tr>
<tr class="separator:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1cc4a66938068978b802ae5b76a2d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:adf1cc4a66938068978b802ae5b76a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for version info.  <a href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">More...</a><br /></td></tr>
<tr class="separator:adf1cc4a66938068978b802ae5b76a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6698a41e3975ed6047dac727fe9a0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:aee6698a41e3975ed6047dac727fe9a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for writing message contents into sequence of bytes stored somewhere.  <a href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">More...</a><br /></td></tr>
<tr class="separator:aee6698a41e3975ed6047dac727fe9a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e92ee93252dcf912384ade08349dd74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a2e92ee93252dcf912384ade08349dd74">~Message</a> () noexcept=default</td></tr>
<tr class="memdesc:a2e92ee93252dcf912384ade08349dd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classcomms_1_1Message.html#a2e92ee93252dcf912384ade08349dd74">More...</a><br /></td></tr>
<tr class="separator:a2e92ee93252dcf912384ade08349dd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler)</td></tr>
<tr class="memdesc:af2781055a9fb72a553d56cfd6ac99c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message to the handler for processing.  <a href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">More...</a><br /></td></tr>
<tr class="separator:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9fd890f4efb1263179c3799d52098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId</a> () const</td></tr>
<tr class="memdesc:aaac9fd890f4efb1263179c3799d52098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve ID of the message.  <a href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">More...</a><br /></td></tr>
<tr class="separator:aaac9fd890f4efb1263179c3799d52098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dba816185287db6d38a3274743f6cf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length</a> () const</td></tr>
<tr class="memdesc:a91dba816185287db6d38a3274743f6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes required to serialise this message.  <a href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">More...</a><br /></td></tr>
<tr class="separator:a91dba816185287db6d38a3274743f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8a1db5b023e576dd74f906dd547ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name</a> () const</td></tr>
<tr class="memdesc:acdc8a1db5b023e576dd74f906dd547ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the message.  <a href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">More...</a><br /></td></tr>
<tr class="separator:acdc8a1db5b023e576dd74f906dd547ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77396db2ec7a29de4bf335af49e1d760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a77396db2ec7a29de4bf335af49e1d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message contents using provided iterator.  <a href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">More...</a><br /></td></tr>
<tr class="separator:a77396db2ec7a29de4bf335af49e1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78ac63decb13777fd7d203de01fdd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh</a> ()</td></tr>
<tr class="memdesc:adf78ac63decb13777fd7d203de01fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh to contents of the message.  <a href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">More...</a><br /></td></tr>
<tr class="separator:adf78ac63decb13777fd7d203de01fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> ()</td></tr>
<tr class="memdesc:a6da7116040cb3e35912aa4b82a2a66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to extra transport fields.  <a href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">More...</a><br /></td></tr>
<tr class="separator:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa610b5478c6c6926ffc83ed5c91b7954">transportFields</a> () const</td></tr>
<tr class="memdesc:aa610b5478c6c6926ffc83ed5c91b7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>.  <a href="classcomms_1_1Message.html#aa610b5478c6c6926ffc83ed5c91b7954">More...</a><br /></td></tr>
<tr class="separator:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62f73f8c7db3745491ce668171af5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid</a> () const</td></tr>
<tr class="memdesc:aeb62f73f8c7db3745491ce668171af5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of message contents.  <a href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">More...</a><br /></td></tr>
<tr class="separator:aeb62f73f8c7db3745491ce668171af5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">version</a> ()</td></tr>
<tr class="memdesc:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to version information.  <a href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">More...</a><br /></td></tr>
<tr class="separator:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472075590eb54b5c660ffc74927f1afc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a472075590eb54b5c660ffc74927f1afc">version</a> () const</td></tr>
<tr class="memdesc:a472075590eb54b5c660ffc74927f1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to version information.  <a href="classcomms_1_1Message.html#a472075590eb54b5c660ffc74927f1afc">More...</a><br /></td></tr>
<tr class="separator:a472075590eb54b5c660ffc74927f1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861cf1ef73973117f7842e567b05a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:ac861cf1ef73973117f7842e567b05a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message contents using provided iterator.  <a href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">More...</a><br /></td></tr>
<tr class="separator:ac861cf1ef73973117f7842e567b05a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memItemLeft" align="right" valign="top"><a id="aec8ad53f1b5aa5f06a0d47c7d9585783"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aec8ad53f1b5aa5f06a0d47c7d9585783">hasDispatch</a> ()</td></tr>
<tr class="memdesc:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> and <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">dispatchImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> and <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> types. <br /></td></tr>
<tr class="separator:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13724033c28237b389725d379d1f5b9f"><td class="memItemLeft" align="right" valign="top"><a id="a13724033c28237b389725d379d1f5b9f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian</a> ()</td></tr>
<tr class="memdesc:a13724033c28237b389725d379d1f5b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> and <a class="el" href="classcomms_1_1Field.html">Field</a> types. <br /></td></tr>
<tr class="separator:a13724033c28237b389725d379d1f5b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memItemLeft" align="right" valign="top"><a id="aa00be33cb01b7e9cdee9ecebfa54c171"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId</a> ()</td></tr>
<tr class="memdesc:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId()</a> and <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaded9d46874a89824e91c962524836d"><td class="memItemLeft" align="right" valign="top"><a id="aaaded9d46874a89824e91c962524836d"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength</a> ()</td></tr>
<tr class="memdesc:aaaded9d46874a89824e91c962524836d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> and <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">lengthImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aaaded9d46874a89824e91c962524836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37efad282638409ff120b999954c2117"><td class="memItemLeft" align="right" valign="top"><a id="a37efad282638409ff120b999954c2117"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a37efad282638409ff120b999954c2117">hasMsgIdType</a> ()</td></tr>
<tr class="memdesc:a37efad282638409ff120b999954c2117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> and <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> types. <br /></td></tr>
<tr class="separator:a37efad282638409ff120b999954c2117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaf6e76e7639112d33a04683a4e1a43"><td class="memItemLeft" align="right" valign="top"><a id="abcaf6e76e7639112d33a04683a4e1a43"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName</a> ()</td></tr>
<tr class="memdesc:abcaf6e76e7639112d33a04683a4e1a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name()</a> and <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">nameImpl()</a> member functions. <br /></td></tr>
<tr class="separator:abcaf6e76e7639112d33a04683a4e1a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memItemLeft" align="right" valign="top"><a id="a1cab88111f9e395e71f8a8eb05c99fb5"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead</a> ()</td></tr>
<tr class="memdesc:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read()</a> and <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> type. <br /></td></tr>
<tr class="separator:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memItemLeft" align="right" valign="top"><a id="ae0929a96d1cb0c12a2b2a383ebd015ef"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ae0929a96d1cb0c12a2b2a383ebd015ef">hasRefresh</a> ()</td></tr>
<tr class="memdesc:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh()</a> and <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">refreshImpl()</a> member functions. <br /></td></tr>
<tr class="separator:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memItemLeft" align="right" valign="top"><a id="a57f6dc0452da23c5cdf25ec56b26df80"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields</a> ()</td></tr>
<tr class="memdesc:a57f6dc0452da23c5cdf25ec56b26df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> type. <br /></td></tr>
<tr class="separator:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133c135fda72ca2257fed0f5427053b4"><td class="memItemLeft" align="right" valign="top"><a id="a133c135fda72ca2257fed0f5427053b4"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid</a> ()</td></tr>
<tr class="memdesc:a133c135fda72ca2257fed0f5427053b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid()</a> and <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">validImpl()</a> member functions. <br /></td></tr>
<tr class="separator:a133c135fda72ca2257fed0f5427053b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8cdb390a3a51811a5a836cff0b7828"><td class="memItemLeft" align="right" valign="top"><a id="afa8cdb390a3a51811a5a836cff0b7828"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#afa8cdb390a3a51811a5a836cff0b7828">hasVersionInTransportFields</a> ()</td></tr>
<tr class="memdesc:afa8cdb390a3a51811a5a836cff0b7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether there is version information inside transport fields. <br /></td></tr>
<tr class="separator:afa8cdb390a3a51811a5a836cff0b7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memItemLeft" align="right" valign="top"><a id="aa7a317a10acda2cd7affd8b69a7b459a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite</a> ()</td></tr>
<tr class="memdesc:aa7a317a10acda2cd7affd8b69a7b459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write()</a> and <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">writeImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> type. <br /></td></tr>
<tr class="separator:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d74062683710d3e3807937227a99318"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1d74062683710d3e3807937227a99318">versionIdxInTransportFields</a> ()</td></tr>
<tr class="memdesc:a1d74062683710d3e3807937227a99318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry of version field index in transport field.  <a href="classcomms_1_1Message.html#a1d74062683710d3e3807937227a99318">More...</a><br /></td></tr>
<tr class="separator:a1d74062683710d3e3807937227a99318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab89e468c618e0f3697c73ffb98bc9d54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">dispatchImpl</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler)</td></tr>
<tr class="memdesc:ab89e468c618e0f3697c73ffb98bc9d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used to dispatch message to the handler object for processing.  <a href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">More...</a><br /></td></tr>
<tr class="separator:ab89e468c618e0f3697c73ffb98bc9d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e70f9849dc35cc25018207d556b691"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl</a> () const =0</td></tr>
<tr class="memdesc:aa8e70f9849dc35cc25018207d556b691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function used to retrieve ID of the message.  <a href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">More...</a><br /></td></tr>
<tr class="separator:aa8e70f9849dc35cc25018207d556b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ec1d8f1eb313d3fc4b21febe118f6e"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">lengthImpl</a> () const</td></tr>
<tr class="memdesc:ad7ec1d8f1eb313d3fc4b21febe118f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used to retrieve number of bytes required to serialise this message.  <a href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">More...</a><br /></td></tr>
<tr class="separator:ad7ec1d8f1eb313d3fc4b21febe118f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eeed2ffee7614b73cb5af211a263d6"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">nameImpl</a> () const =0</td></tr>
<tr class="memdesc:a36eeed2ffee7614b73cb5af211a263d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function used to retrieve actual message name.  <a href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">More...</a><br /></td></tr>
<tr class="separator:a36eeed2ffee7614b73cb5af211a263d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8679fd222f23e632097defc811aefbd6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a8679fd222f23e632097defc811aefbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used to implement read operation.  <a href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">More...</a><br /></td></tr>
<tr class="separator:a8679fd222f23e632097defc811aefbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39437bde1292832507e97885fee114f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">refreshImpl</a> ()</td></tr>
<tr class="memdesc:af39437bde1292832507e97885fee114f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used to bring contents of the message into a consistent state.  <a href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">More...</a><br /></td></tr>
<tr class="separator:af39437bde1292832507e97885fee114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c16f0064741a8fad3ff76a4b5654bf5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">validImpl</a> () const</td></tr>
<tr class="memdesc:a7c16f0064741a8fad3ff76a4b5654bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function used to implement contents validity check.  <a href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">More...</a><br /></td></tr>
<tr class="separator:a7c16f0064741a8fad3ff76a4b5654bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ae2afc3e5059b9728644dd7034f817"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">writeImpl</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:ae7ae2afc3e5059b9728644dd7034f817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function used to implement write operation.  <a href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">More...</a><br /></td></tr>
<tr class="separator:ae7ae2afc3e5059b9728644dd7034f817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:ac484455094ac1eb1aa189bdc6d527ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input area.  <a href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded">More...</a><br /></td></tr>
<tr class="separator:ac484455094ac1eb1aa189bdc6d527ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a51c517d87946dea783a006f34a9868c8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a51c517d87946dea783a006f34a9868c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input area.  <a href="classcomms_1_1Message.html#a51c517d87946dea783a006f34a9868c8">More...</a><br /></td></tr>
<tr class="separator:a51c517d87946dea783a006f34a9868c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ebf1dd77a1c6458392a9001d187ad45">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:a5ebf1dd77a1c6458392a9001d187ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output area.  <a href="classcomms_1_1Message.html#a5ebf1dd77a1c6458392a9001d187ad45">More...</a><br /></td></tr>
<tr class="separator:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abe23293aedd424af62bd5f4d05571b59">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:abe23293aedd424af62bd5f4d05571b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output area.  <a href="classcomms_1_1Message.html#abe23293aedd424af62bd5f4d05571b59">More...</a><br /></td></tr>
<tr class="separator:abe23293aedd424af62bd5f4d05571b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(f_, ...)</td></tr>
<tr class="memdesc:adfa416afa2a8a77af9c46b42d3034f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">More...</a><br /></td></tr>
<tr class="separator:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, ...)&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td></tr>
<tr class="memdesc:a33954a8d8c1b0e04175ada3e840bcb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">More...</a><br /></td></tr>
<tr class="separator:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada784673f02d483a88fcf0c451cb72bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:ada784673f02d483a88fcf0c451cb72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to extra transport fields.  <a href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">More...</a><br /></td></tr>
<tr class="separator:ada784673f02d483a88fcf0c451cb72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00912bb201d47afbb0c3e51fff95b338"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a00912bb201d47afbb0c3e51fff95b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for extra transport fields.  <a href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">More...</a><br /></td></tr>
<tr class="separator:a00912bb201d47afbb0c3e51fff95b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a43d474f5037090d6d749419c51f2e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d474f5037090d6d749419c51f2e100">&#9670;&nbsp;</a></span>DispatchRetType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> =  typename Handler::RetType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function. </p>
<p>Equal to <b>Handler::RetType</b> if such exists, <b>void</b> otherwise. </p>

</div>
</div>
<a id="a1bb35fb9379a188ce663079c956b3f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb35fb9379a188ce663079c956b3f80">&#9670;&nbsp;</a></span>Endian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> =  typename BaseImpl::Endian</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialisation endian type. </p>
<p>The type exists only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used to specify it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian()</a> </dd></dl>

</div>
</div>
<a id="a4cd3705f965f28c601858aced3f16c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd3705f965f28c601858aced3f16c48">&#9670;&nbsp;</a></span>Field</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> =  BaseImpl::Field</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of default base class for all the fields. </p>
<p>Requires definition of the <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> type, i.e. the type exist only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used. </p>

</div>
</div>
<a id="a30b17e6aee609c0bb061556f4a0979bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b17e6aee609c0bb061556f4a0979bb">&#9670;&nbsp;</a></span>Handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the message handler object. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p>

</div>
</div>
<a id="a666cf5c4acf17424d67be09c13212c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666cf5c4acf17424d67be09c13212c25">&#9670;&nbsp;</a></span>InterfaceOptions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a666cf5c4acf17424d67be09c13212c25">InterfaceOptions</a> =  details::MessageInterfaceOptionsParser&lt;TOptions...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All the options bundled into struct. </p>
<p>For internal use only. </p>

</div>
</div>
<a id="aa99780161941773e6bbe2767675c4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99780161941773e6bbe2767675c4a03">&#9670;&nbsp;</a></span>MsgIdParamType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> =  typename BaseImpl::MsgIdParamType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for message ID passed as parameter or returned from function. </p>
<p>It is equal to <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> for numeric types and becomes "const-reference-to" <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> for more complex types. The type exists only if <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> exists, i.e. the <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used. </p>

</div>
</div>
<a id="aa7bb56b0758dfa9a8f9be12d3b8295a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bb56b0758dfa9a8f9be12d3b8295a2">&#9670;&nbsp;</a></span>MsgIdType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> =  typename BaseImpl::MsgIdType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for message ID. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a37efad282638409ff120b999954c2117" title="Compile type inquiry whether message interface class defines MsgIdType and MsgIdParamType types.">hasMsgIdType()</a> </dd></dl>

</div>
</div>
<a id="a463c7edb3734bffca6c41b9cee3d3f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463c7edb3734bffca6c41b9cee3d3f0a">&#9670;&nbsp;</a></span>ReadIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the iterator used for reading message contents from sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="a1a7c7b92d38774a038fbdedb3e0f99cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7c7b92d38774a038fbdedb3e0f99cc">&#9670;&nbsp;</a></span>TransportFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> =  FieldsProvidedWithOption</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="adf1cc4a66938068978b802ae5b76a2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1cc4a66938068978b802ae5b76a2d1">&#9670;&nbsp;</a></span>VersionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> =  typename BaseImpl::VersionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for version info. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="aee6698a41e3975ed6047dac727fe9a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6698a41e3975ed6047dac727fe9a0c">&#9670;&nbsp;</a></span>WriteIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the iterator used for writing message contents into sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2e92ee93252dcf912384ade08349dd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e92ee93252dcf912384ade08349dd74">&#9670;&nbsp;</a></span>~Message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::~<a class="el" href="classcomms_1_1Message.html">Message</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Becomes <b>virtual</b> if the message interface is defined to expose any polymorphic behavior, i.e. if there is at least one virtual function. It is possible to explicitly suppress <b>virtual</b> declaration by using <a class="el" href="structcomms_1_1option_1_1app_1_1NoVirtualDestructor.html" title="Force the destructor of comms::Message class to be non-virtual, even if there are other virtual funct...">comms::option::app::NoVirtualDestructor</a> option. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2781055a9fb72a553d56cfd6ac99c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2781055a9fb72a553d56cfd6ac99c5e">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message to the handler for processing. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the handler. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54" title="Virtual function used to dispatch message to the handler object for processing.">dispatchImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Handler object to dispatch message to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab89e468c618e0f3697c73ffb98bc9d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89e468c618e0f3697c73ffb98bc9d54">&#9670;&nbsp;</a></span>dispatchImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::dispatchImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function used to dispatch message to the handler object for processing. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e" title="Dispatch message to the handler for processing.">dispatch()</a>, must be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the handler. If not overridden unconditionally fails on assert in DEBUG build and does nothing in RELEASE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Handler object to dispatch message to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="aaac9fd890f4efb1263179c3799d52098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9fd890f4efb1263179c3799d52098">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve ID of the message. </p>
<p>Invokes pure virtual <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl()</a>. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used to specify type of the ID value and <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option are used. </p><dl class="section return"><dt>Returns</dt><dd>ID of the message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId()</a>; </dd></dl>

</div>
</div>
<a id="aa8e70f9849dc35cc25018207d556b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e70f9849dc35cc25018207d556b691">&#9670;&nbsp;</a></span>getIdImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::getIdImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function used to retrieve ID of the message. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098" title="Retrieve ID of the message.">getId()</a>, must be implemented in the derived class. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used to specify type of the ID value as well as <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a>. </p><dl class="section return"><dt>Returns</dt><dd>ID of the message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId()</a>; </dd></dl>

<p>Implemented in <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="a91dba816185287db6d38a3274743f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dba816185287db6d38a3274743f6cf">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bytes required to serialise this message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e" title="Virtual function used to retrieve number of bytes required to serialise this message.">lengthImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes required to serialise this message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength()</a> </dd></dl>

</div>
</div>
<a id="ad7ec1d8f1eb313d3fc4b21febe118f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ec1d8f1eb313d3fc4b21febe118f6e">&#9670;&nbsp;</a></span>lengthImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::lengthImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function used to retrieve number of bytes required to serialise this message. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf" title="Get number of bytes required to serialise this message.">length()</a>, must be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes required to serialise this message. If not overriden unconditionally fails on assert in DEBUG build and returns <b>0</b> in RELEASE. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="acdc8a1db5b023e576dd74f906dd547ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8a1db5b023e576dd74f906dd547ad">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of the message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">nameImpl()</a> function. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName()</a> </dd></dl>

</div>
</div>
<a id="a36eeed2ffee7614b73cb5af211a263d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eeed2ffee7614b73cb5af211a263d6">&#9670;&nbsp;</a></span>nameImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::nameImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function used to retrieve actual message name. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name()</a>, must be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a>. </p>

<p>Implemented in <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="a77396db2ec7a29de4bf335af49e1d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77396db2ec7a29de4bf335af49e1d760">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a>. The contents of the message are updated with bytes being read. The buffer is external and maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6" title="Virtual function used to implement read operation.">readImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="ac484455094ac1eb1aa189bdc6d527ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac484455094ac1eb1aa189bdc6d527ded">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input area. </p>
<p>Use this function to read data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a51c517d87946dea783a006f34a9868c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c517d87946dea783a006f34a9868c8">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input area. </p>
<p>Use this function to read partial data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a8679fd222f23e632097defc811aefbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8679fd222f23e632097defc811aefbd6">&#9670;&nbsp;</a></span>readImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function used to implement read operation. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760" title="Read message contents using provided iterator.">read()</a>, expected be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. If not overridden returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb" title="The operation is not supported.">comms::ErrorStatus::NotSupported</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="adf78ac63decb13777fd7d203de01fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78ac63decb13777fd7d203de01fdd1">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh to contents of the message. </p>
<p>Many protocols define their messages in a way that the content of some fields may depend on the value of the other field(s). For example, providing in one field the information about number of elements in the list that will follow later. Another example is having bits in a bitmask field specifying whether other optional fields exist. In this case, directly modifying value of some fields may leave a message contents in an inconsistent state. Having <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1" title="Refresh to contents of the message.">refresh()</a> member function allows the developer to bring the message into a consistent state prior to sending it over I/O link . <br  />
 The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f" title="Virtual function used to bring contents of the message into a consistent state.">refreshImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true in case the contents of the message were modified, false if all the fields of the message remained unchanged. </dd></dl>

</div>
</div>
<a id="af39437bde1292832507e97885fee114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39437bde1292832507e97885fee114f">&#9670;&nbsp;</a></span>refreshImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::refreshImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function used to bring contents of the message into a consistent state. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1" title="Refresh to contents of the message.">refresh()</a>, can be overridden in the derived class. If not overridden, does nothing and returns false indicating that contents of the message haven't been changed. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. </p><dl class="section return"><dt>Returns</dt><dd>true in case the contents of the message were modified, false if all the fields of the message remained unchanged. </dd></dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="a6da7116040cb3e35912aa4b82a2a66b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da7116040cb3e35912aa4b82a2a66b1">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to extra transport fields. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. Some protocols may use additional values in transport information, such as message version for example. Such values may influence the way message data is being serialized / deserialized. The provided extra transport fields are <b>NOT</b> serialised as part of message payload. Their values are expected to be set by transport layer(s) when such information is read. The transport layers are also responsible to take the updated information from the relevant field and write it when message contents being written. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aa610b5478c6c6926ffc83ed5c91b7954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610b5478c6c6926ffc83ed5c91b7954">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aeb62f73f8c7db3745491ce668171af5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62f73f8c7db3745491ce668171af5f">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check validity of message contents. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5" title="Pure virtual function used to implement contents validity check.">validImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true for valid contents, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid()</a> </dd></dl>

</div>
</div>
<a id="a7c16f0064741a8fad3ff76a4b5654bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c16f0064741a8fad3ff76a4b5654bf5">&#9670;&nbsp;</a></span>validImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::validImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function used to implement contents validity check. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f" title="Check validity of message contents.">valid()</a>, must be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. </p><dl class="section return"><dt>Returns</dt><dd>true for valid contents, false otherwise. If not overridden always returns <b>true</b>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<a id="a5ad5c5b59d08590aba3b1e97f4e8149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad5c5b59d08590aba3b1e97f4e8149c">&#9670;&nbsp;</a></span>version() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="a472075590eb54b5c660ffc74927f1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472075590eb54b5c660ffc74927f1afc">&#9670;&nbsp;</a></span>version() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="a1d74062683710d3e3807937227a99318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d74062683710d3e3807937227a99318">&#9670;&nbsp;</a></span>versionIdxInTransportFields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::versionIdxInTransportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile type inquiry of version field index in transport field. </p>
<p>If <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option hasn't been used, the <b>std::numeric_limits&lt;std::size_t&gt;::max()</b> is returned. <br  />
 </p>

</div>
</div>
<a id="ac861cf1ef73973117f7842e567b05a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac861cf1ef73973117f7842e567b05a13">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a>. The contents of the message are serialised into buffer. The buffer is external and is maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817" title="Virtual function used to implement write operation.">writeImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<a id="a5ebf1dd77a1c6458392a9001d187ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf1dd77a1c6458392a9001d187ad45">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output area. </p>
<p>Use this function to write data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="abe23293aedd424af62bd5f4d05571b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23293aedd424af62bd5f4d05571b59">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output area. </p>
<p>Use this function to write partial data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="ae7ae2afc3e5059b9728644dd7034f817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ae2afc3e5059b9728644dd7034f817">&#9670;&nbsp;</a></span>writeImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function used to implement write operation. </p>
<p>Called by <a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13" title="Write message contents using provided iterator.">write()</a>, expected be implemented in the derived class. The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. If not overridden returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb" title="The operation is not supported.">comms::ErrorStatus::NotSupported</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">comms::MessageBase&lt; TMessage, TOptions &gt;</a>, and <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">comms::MessageBase&lt; TMessage, comms::option::def::FieldsImpl&lt; GenericMessageFields&lt; TMessage::Field, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::MsgType&lt; GenericMessage&lt; TMessage, comms::option::app::EmptyOption, comms::option::app::EmptyOption &gt; &gt;, comms::option::def::HasDoGetId, comms::option::def::HasName, comms::option::app::EmptyOption &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adfa416afa2a8a77af9c46b42d3034f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa416afa2a8a77af9c46b42d3034f3e">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, __VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_ALIAS_TYPEDEF(TransportField_, f_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a33954a8d8c1b0e04175ada3e840bcb83"><div class="ttname"><a href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">comms::Message::COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for extra member transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:733</div></div>
</div><!-- fragment -->
<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro generates alias type as well as convenience access member functions for extra transport fields. Sometimes the fields may get renamed or moved to be a member of other fields, like <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> or <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In such case the compilation of the existing client code (that already uses published protocol definition) may fail. To avoid such scenarios and make the transition to newer versions of the protocol easier, the <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> macro can be used to create alias to other fields. For example, let's assume that some common interface class was defined: like this. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1Message_html"><div class="ttname"><a href="classcomms_1_1Message.html">comms::Message</a></div><div class="ttdoc">Main interface class for all the messages.</div><div class="ttdef"><b>Definition:</b> Message.h:80</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a00912bb201d47afbb0c3e51fff95b338"><div class="ttname"><a href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_NAMES</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES(...)</div><div class="ttdoc">Provide names for extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:716</div></div>
</div><!-- fragment --><p> In the future versions of the protocol "name3" was renamed to "newName3". To keep the existing code (that uses "name3" name) compiling it is possible to create an alias access function(s) with: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1Message_html_adfa416afa2a8a77af9c46b42d3034f3e"><div class="ttname"><a href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">comms::Message::COMMS_MSG_TRANSPORT_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for extra member transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:845</div></div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following type and functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Another example would be a replacing a <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> with <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> in the future version of the protocol. It can happen when the developer decides to split the used storage into multiple values (because the range of the used/valid values allows so). In order to keep the old client code compiling, the access to the replaced field needs to be an alias to the first member of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In this case the usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> will look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3, member1);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3::Field_Member1;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="Message_8h.html#a6fe96d7272148945853ce61572b3d4b1">COMMS_MSG_TRANSPORT_FIELD_ALIAS_NOTEMPLATE()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a33954a8d8c1b0e04175ada3e840bcb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33954a8d8c1b0e04175ada3e840bcb83">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> but requires usage of <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> instead of <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> and does NOT create alias to the field type, only access functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="ada784673f02d483a88fcf0c451cb72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada784673f02d483a88fcf0c451cb72bd">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(COMMS_DEFINE_TRANSPORT_FIELD_ENUM(__VA_ARGS__)) \</div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_FUNC { \</div>
<div class="line">        auto&amp; msgBase = <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*<span class="keyword">this</span>); \</div>
<div class="line">        using MsgBase = <span class="keyword">typename</span> std::decay&lt;decltype(msgBase)&gt;::type; \</div>
<div class="line">        static_assert(MsgBase::hasTransportFields(), \</div>
<div class="line">            <span class="stringliteral">&quot;Message interface class doesn&#39;t define extra transport fields.&quot;</span>); \</div>
<div class="line">        using TransportFieldsTuple = <span class="keyword">typename</span> MsgBase::TransportFields; \</div>
<div class="line">        static_assert(std::tuple_size&lt;TransportFieldsTuple&gt;::value == TransportFieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for transport fields tuple&quot;</span>); \</div>
<div class="line">        return msgBase.transportFields(); \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_CONST_FUNC { \</div>
<div class="line">        return <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*this).transportFields(); \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_TRANSPORT_FIELD_ACC_FUNC(<a class="code" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>, <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>(), __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a1a7c7b92d38774a038fbdedb3e0f99cc"><div class="ttname"><a href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">comms::Message::TransportFields</a></div><div class="ttdeci">FieldsProvidedWithOption TransportFields</div><div class="ttdoc">std::tuple of extra fields from transport layers that may affect the way the message fields get seria...</div><div class="ttdef"><b>Definition:</b> Message.h:325</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a6da7116040cb3e35912aa4b82a2a66b1"><div class="ttname"><a href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">comms::Message::transportFields</a></div><div class="ttdeci">TransportFields &amp; transportFields()</div><div class="ttdoc">Get access to extra transport fields.</div></div>
<div class="ttc" id="anamespacecomms_html_a6cfdaf9bcb9780874bac5b1f69601f6d"><div class="ttname"><a href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a></div><div class="ttdeci">Message&lt; TOptions... &gt; &amp; toMessage(Message&lt; TOptions... &gt; &amp;msg)</div><div class="ttdoc">Upcast type of the message object to comms::Message in order to have access to its internal types.</div><div class="ttdef"><b>Definition:</b> Message.h:524</div></div>
</div><!-- fragment -->
<p>Add convenience access enum and functions to extra transport fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>TransportField_*</b> types for used fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a00912bb201d47afbb0c3e51fff95b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00912bb201d47afbb0c3e51fff95b338">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(__VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_TYPEDEF(<span class="keyword">typename</span> Base::TransportFields, TransportField_, TransportFieldIdx_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_ada784673f02d483a88fcf0c451cb72bd"><div class="ttname"><a href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:575</div></div>
</div><!-- fragment -->
<p>Provide names for extra transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class provides access to its extra transport fields via <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1" title="Get access to extra transport fields.">comms::MessageBase::transportFields()</a> member function(s). The fields are bundled into <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and can be accessed using indices with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. For convenience, the fields should be named. The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro does exactly that. <br  />
 As an example, let's assume that custom message uses 3 fields of any types: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TransportField1 = ...;</div>
<div class="line"><span class="keyword">using</span> TransportField2 = ...;</div>
<div class="line"><span class="keyword">using</span> TransportField3 = ...;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::tuple&lt;TransportField1, TransportField2, TransportField3&gt; MyExtraTransportFields</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        ...</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt; &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div>
<div class="line">    <span class="comment">// required by the COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of the <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro with the list of the extra transport field's names is equivalent to having the following definitions inside the message class </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> TransportFieldIdx {</div>
<div class="line">        TransportFieldIdx_name1,</div>
<div class="line">        TransportFieldIdx_name2,</div>
<div class="line">        TransportFieldIdx_name3,</div>
<div class="line">        TransportFieldIdx_nameOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    static_assert(std::tuple_size&lt;Base::TransportFields&gt;::value == TransportFieldIdx_nameOfValues,</div>
<div class="line">        <span class="stringliteral">&quot;Number of expected transport fields is incorrect&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; transport field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name1() -&gt; decltype(std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name1() const -&gt; decltype(std::get&lt;TransportFieldIdx_name1&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name2() -&gt; decltype(std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name2() const -&gt; decltype(std::get&lt;TransportFieldIdx_name2&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(std::get&lt;TransportFieldIdx_name3&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name3&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redefinition of the transport field types:</span></div>
<div class="line">    <span class="keyword">using</span> TransportField_name1 = TransportField1;</div>
<div class="line">    <span class="keyword">using</span> TransportField_name2 = TransportField2;</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField3;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>name1</b>, <b>name2</b>, and <b>name3</b> have found their way to the following definitions: </p><ul>
<li><b>TransportFieldIdx</b> enum. The names are prefixed with <b>TransportFieldIdx_</b>. The <b>TransportFieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>transportField_*</b> </li>
<li>Types of fields prefixed with <b>TransportField_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using <b>TransportFieldIdx</b> enum </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> = msg.transportFields();</div>
<div class="line">    <span class="keyword">auto</span>&amp; field1 = std::get&lt;Message1::TransportFieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field2 = std::get&lt;Message1::TransportFieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field3 = std::get&lt;Message1::TransportFieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> value1 = field1.value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = field2.value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = field3.value();</div>
<div class="line">}</div>
</div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> value1 = transportField_name1().value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = transportField_name2().value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = transportField_name3().value();</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires (re)definition of the message base class as inner <b>Base</b> member type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd" title="Add convenience access enum and functions to extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/<a class="el" href="Message_8h_source.html">Message.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
