<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::MessageBase&lt; TMessage, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1MessageBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::MessageBase&lt; TMessage, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="MessageBase_8h_source.html">comms/MessageBase.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TMessage, typename... TOptions&gt;<br />
class comms::MessageBase&lt; TMessage, TOptions &gt;</h3>

<p>Base class for all the custom protocol messages. </p>
<p>The main purpose of this class is to provide default implementation for some pure virtual functions defined in <a class="el" href="classcomms_1_1Message.html">Message</a> class. Just like with <a class="el" href="classcomms_1_1Message.html">Message</a> class, the provided methods implementation depends on the options passed as TOption template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>The main interface class of the custom protocol messages. It may be either <a class="el" href="classcomms_1_1Message.html">Message</a> class itself or any other class that extends <a class="el" href="classcomms_1_1Message.html">Message</a>. The <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a> inherits from class provided as TMessage template parameter. As the result the real inheritance diagram will look like: <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> &lt;&ndash; TMessage &lt;&ndash; <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Variadic template parameter that can include zero or more options that specify behaviour. The options may be comma separated as well as bundled into std::tuple. Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> - In case message have numeric IDs (<a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2" title="Type used for message ID.">comms::Message::MsgIdType</a> is of integral or enum type), usage of this option will cause this class to implement <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a" title="Implementation of ID retrieval functionality.">getIdImpl()</a> virtual function that returns provided numeric value. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1NoIdImpl.html">comms::option::def::NoIdImpl</a> - Some message may not have valid IDs and their <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098" title="Retrieve ID of the message.">getId()</a> function is never going to be called. Usage of this option will create dummy implementation of <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a" title="Implementation of ID retrieval functionality.">getIdImpl()</a> virtual function that contains always failing assertion. In DEBUG mode compilation the application will crash while in release mode the default constructed value of <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2" title="Type used for message ID.">comms::Message::MsgIdType</a> will be returned. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> - Provide type of actual message that inherits from this <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> class. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> - Usually implementation of read, write, validity check, and length calculation is pretty straight forward. For example the message is considered valid if all the field values are considered to be valid, or read operation is to perform read for all the fields in the message. If the <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option with all the message field classes bundled into the std::tuple is provided, then <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a> class can implement <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality.">readImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf" title="Implementation of polymorphic write functionality.">writeImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality.">validImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality.">lengthImpl()</a> virtual functions declared as pure in <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> interface. The option also provides an accessor functions to the all the field objects: <a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891" title="Get an access to the fields of the message.">fields()</a>. </li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> - This option is an alias to <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a>&lt;std::tuple&lt;&gt; &gt;, which provides implementation <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality.">readImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf" title="Implementation of polymorphic write functionality.">writeImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality.">validImpl()</a>, <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality.">lengthImpl()</a> virtual functions when message contains no fields, i.e. <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality.">readImpl()</a> and writeImple() will always report success doing nothing, <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality.">validImpl()</a> will always return true, and <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality.">lengthImpl()</a> will always return 0. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> - Notify <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> that there is custom <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec" title="Default implementation of refreshing functionality.">doRefresh()</a> member function in the message definition class. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasDoGetId.html">comms::option::def::HasDoGetId</a> - Enable implementation of <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a" title="Implementation of ID retrieval functionality.">getIdImpl()</a> even if <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option wasn't used. Must be paired with <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoReadImpl.html">comms::option::app::NoReadImpl</a> - Inhibit the implementation of <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality.">readImpl()</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoWriteImpl.html">comms::option::app::NoWriteImpl</a> - Inhibit the implementation of <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf" title="Implementation of polymorphic write functionality.">writeImpl()</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoLengthImpl.html">comms::option::app::NoLengthImpl</a> - Inhibit the implementation of <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality.">lengthImpl()</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoValidImpl.html">comms::option::app::NoValidImpl</a> - Inhibit the implementation of <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality.">validImpl()</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoDispatchImpl.html">comms::option::app::NoDispatchImpl</a> - Inhibit the implementation of <a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e" title="Implementation of dispatch functionality.">dispatchImpl()</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">toMessageBase()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::MessageBase&lt; TMessage, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1MessageBase.png" usemap="#comms::MessageBase_3C_20TMessage_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::MessageBase_3C_20TMessage_2C_20TOptions_20_3E_map" name="comms::MessageBase_3C_20TMessage_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1Message.html" title="Main interface class for all the messages." alt="comms::Message&lt; TOptions &gt;" shape="rect" coords="0,0,276,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a108df722c6d6e5016ab6b35b961b43cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> = FieldsProvidedWithOption</td></tr>
<tr class="memdesc:a108df722c6d6e5016ab6b35b961b43cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All field classes provided with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option.  <a href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">More...</a><br /></td></tr>
<tr class="separator:a108df722c6d6e5016ab6b35b961b43cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d474f5037090d6d749419c51f2e100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> = typename Handler::RetType</td></tr>
<tr class="memdesc:a43d474f5037090d6d749419c51f2e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function.  <a href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">More...</a><br /></td></tr>
<tr class="separator:a43d474f5037090d6d749419c51f2e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb35fb9379a188ce663079c956b3f80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a1bb35fb9379a188ce663079c956b3f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialisation endian type.  <a href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">More...</a><br /></td></tr>
<tr class="separator:a1bb35fb9379a188ce663079c956b3f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd3705f965f28c601858aced3f16c48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> = BaseImpl::Field</td></tr>
<tr class="memdesc:a4cd3705f965f28c601858aced3f16c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of default base class for all the fields.  <a href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">More...</a><br /></td></tr>
<tr class="separator:a4cd3705f965f28c601858aced3f16c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b17e6aee609c0bb061556f4a0979bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a30b17e6aee609c0bb061556f4a0979bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message handler object.  <a href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">More...</a><br /></td></tr>
<tr class="separator:a30b17e6aee609c0bb061556f4a0979bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212803732b5ff9a4e60a782e09adfc7"><td class="memItemLeft" align="right" valign="top"><a id="a4212803732b5ff9a4e60a782e09adfc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a4212803732b5ff9a4e60a782e09adfc7">ImplOptions</a> = details::MessageImplOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a4212803732b5ff9a4e60a782e09adfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:a4212803732b5ff9a4e60a782e09adfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666cf5c4acf17424d67be09c13212c25"><td class="memItemLeft" align="right" valign="top"><a id="a666cf5c4acf17424d67be09c13212c25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a666cf5c4acf17424d67be09c13212c25">InterfaceOptions</a> = details::MessageInterfaceOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a666cf5c4acf17424d67be09c13212c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options bundled into struct. <br /></td></tr>
<tr class="separator:a666cf5c4acf17424d67be09c13212c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99780161941773e6bbe2767675c4a03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> = typename BaseImpl::MsgIdParamType</td></tr>
<tr class="memdesc:aa99780161941773e6bbe2767675c4a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for message ID passed as parameter or returned from function.  <a href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">More...</a><br /></td></tr>
<tr class="separator:aa99780161941773e6bbe2767675c4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> = typename BaseImpl::MsgIdType</td></tr>
<tr class="memdesc:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for message ID.  <a href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">More...</a><br /></td></tr>
<tr class="separator:aa7bb56b0758dfa9a8f9be12d3b8295a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for reading message contents from sequence of bytes stored somewhere.  <a href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">More...</a><br /></td></tr>
<tr class="separator:a463c7edb3734bffca6c41b9cee3d3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> = FieldsProvidedWithOption</td></tr>
<tr class="memdesc:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized.  <a href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">More...</a><br /></td></tr>
<tr class="separator:a1a7c7b92d38774a038fbdedb3e0f99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1cc4a66938068978b802ae5b76a2d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:adf1cc4a66938068978b802ae5b76a2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for version info.  <a href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">More...</a><br /></td></tr>
<tr class="separator:adf1cc4a66938068978b802ae5b76a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6698a41e3975ed6047dac727fe9a0c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> = TypeProvidedWithOption</td></tr>
<tr class="memdesc:aee6698a41e3975ed6047dac727fe9a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the iterator used for writing message contents into sequence of bytes stored somewhere.  <a href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">More...</a><br /></td></tr>
<tr class="separator:aee6698a41e3975ed6047dac727fe9a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler)</td></tr>
<tr class="memdesc:af2781055a9fb72a553d56cfd6ac99c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message to the handler for processing.  <a href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">More...</a><br /></td></tr>
<tr class="separator:af2781055a9fb72a553d56cfd6ac99c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ba954a125586e6a339aad7b0d11e7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">doFieldsVersionUpdate</a> ()</td></tr>
<tr class="memdesc:a87ba954a125586e6a339aad7b0d11e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update version information of all the fields.  <a href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">More...</a><br /></td></tr>
<tr class="separator:a87ba954a125586e6a339aad7b0d11e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">doLength</a> () const</td></tr>
<tr class="memdesc:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of length calculation functionality.  <a href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">More...</a><br /></td></tr>
<tr class="separator:a6d36881b8fea2fa53cc8e17a1e82df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c05d81adc406833e9ead9e4e2c5d51"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:a60c05d81adc406833e9ead9e4e2c5d51"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a60c05d81adc406833e9ead9e4e2c5d51">doLengthFrom</a> () const</td></tr>
<tr class="memdesc:a60c05d81adc406833e9ead9e4e2c5d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="classcomms_1_1MessageBase.html#a60c05d81adc406833e9ead9e4e2c5d51">More...</a><br /></td></tr>
<tr class="separator:a60c05d81adc406833e9ead9e4e2c5d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd333d3fbdb22b7c5386a545a2870d"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:a21cd333d3fbdb22b7c5386a545a2870d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a21cd333d3fbdb22b7c5386a545a2870d">doLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:a21cd333d3fbdb22b7c5386a545a2870d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="classcomms_1_1MessageBase.html#a21cd333d3fbdb22b7c5386a545a2870d">More...</a><br /></td></tr>
<tr class="separator:a21cd333d3fbdb22b7c5386a545a2870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d6398fd3e1ddb298e37927d3f7c35"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:a869d6398fd3e1ddb298e37927d3f7c35"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a869d6398fd3e1ddb298e37927d3f7c35">doLengthUntil</a> () const</td></tr>
<tr class="memdesc:a869d6398fd3e1ddb298e37927d3f7c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of partial length calculation functionality.  <a href="classcomms_1_1MessageBase.html#a869d6398fd3e1ddb298e37927d3f7c35">More...</a><br /></td></tr>
<tr class="separator:a869d6398fd3e1ddb298e37927d3f7c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a3ba7e14c08930d6fd0e7f2a354cecb9a">doMaxLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#a3ba7e14c08930d6fd0e7f2a354cecb9a">More...</a><br /></td></tr>
<tr class="separator:a3ba7e14c08930d6fd0e7f2a354cecb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aa967c1d370f4a40a6cb2f4de2f1f0168">doMinLengthFromUntil</a> () const</td></tr>
<tr class="memdesc:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#aa967c1d370f4a40a6cb2f4de2f1f0168">More...</a><br /></td></tr>
<tr class="separator:aa967c1d370f4a40a6cb2f4de2f1f0168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45782845d1f24fc957efe1a41fdf32c4"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a45782845d1f24fc957efe1a41fdf32c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">doRead</a> (TIter &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a45782845d1f24fc957efe1a41fdf32c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of read functionality.  <a href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">More...</a><br /></td></tr>
<tr class="separator:a45782845d1f24fc957efe1a41fdf32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb6d8948de99eef4213a234625d3ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh</a> () const</td></tr>
<tr class="memdesc:a2feb6d8948de99eef4213a234625d3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of refreshing functionality.  <a href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">More...</a><br /></td></tr>
<tr class="separator:a2feb6d8948de99eef4213a234625d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3077fb16f36d4710effc4d61a1330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">doValid</a> () const</td></tr>
<tr class="memdesc:afcb3077fb16f36d4710effc4d61a1330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of validity check functionality.  <a href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">More...</a><br /></td></tr>
<tr class="separator:afcb3077fb16f36d4710effc4d61a1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e5ec00e39ff64c5f9208813f270468"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a79e5ec00e39ff64c5f9208813f270468"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">doWrite</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a79e5ec00e39ff64c5f9208813f270468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of write functionality.  <a href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">More...</a><br /></td></tr>
<tr class="separator:a79e5ec00e39ff64c5f9208813f270468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a> ()</td></tr>
<tr class="memdesc:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access to the fields of the message.  <a href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">More...</a><br /></td></tr>
<tr class="separator:af4b8bc4b6db684d0006d2c6c70b1e891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dceebaa69e966780a805b1d4276386e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2dceebaa69e966780a805b1d4276386e">fields</a> () const</td></tr>
<tr class="memdesc:a2dceebaa69e966780a805b1d4276386e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an access to the fields of the message.  <a href="classcomms_1_1MessageBase.html#a2dceebaa69e966780a805b1d4276386e">More...</a><br /></td></tr>
<tr class="separator:a2dceebaa69e966780a805b1d4276386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9fd890f4efb1263179c3799d52098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId</a> () const</td></tr>
<tr class="memdesc:aaac9fd890f4efb1263179c3799d52098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve ID of the message.  <a href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">More...</a><br /></td></tr>
<tr class="separator:aaac9fd890f4efb1263179c3799d52098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dba816185287db6d38a3274743f6cf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length</a> () const</td></tr>
<tr class="memdesc:a91dba816185287db6d38a3274743f6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes required to serialise this message.  <a href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">More...</a><br /></td></tr>
<tr class="separator:a91dba816185287db6d38a3274743f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8a1db5b023e576dd74f906dd547ad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name</a> () const</td></tr>
<tr class="memdesc:acdc8a1db5b023e576dd74f906dd547ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the message.  <a href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">More...</a><br /></td></tr>
<tr class="separator:acdc8a1db5b023e576dd74f906dd547ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77396db2ec7a29de4bf335af49e1d760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a77396db2ec7a29de4bf335af49e1d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message contents using provided iterator.  <a href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">More...</a><br /></td></tr>
<tr class="separator:a77396db2ec7a29de4bf335af49e1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf78ac63decb13777fd7d203de01fdd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh</a> ()</td></tr>
<tr class="memdesc:adf78ac63decb13777fd7d203de01fdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh to contents of the message.  <a href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">More...</a><br /></td></tr>
<tr class="separator:adf78ac63decb13777fd7d203de01fdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> ()</td></tr>
<tr class="memdesc:a6da7116040cb3e35912aa4b82a2a66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to extra transport fields.  <a href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">More...</a><br /></td></tr>
<tr class="separator:a6da7116040cb3e35912aa4b82a2a66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa610b5478c6c6926ffc83ed5c91b7954">transportFields</a> () const</td></tr>
<tr class="memdesc:aa610b5478c6c6926ffc83ed5c91b7954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>.  <a href="classcomms_1_1Message.html#aa610b5478c6c6926ffc83ed5c91b7954">More...</a><br /></td></tr>
<tr class="separator:aa610b5478c6c6926ffc83ed5c91b7954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62f73f8c7db3745491ce668171af5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid</a> () const</td></tr>
<tr class="memdesc:aeb62f73f8c7db3745491ce668171af5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of message contents.  <a href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">More...</a><br /></td></tr>
<tr class="separator:aeb62f73f8c7db3745491ce668171af5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">version</a> ()</td></tr>
<tr class="memdesc:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to version information.  <a href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">More...</a><br /></td></tr>
<tr class="separator:a5ad5c5b59d08590aba3b1e97f4e8149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472075590eb54b5c660ffc74927f1afc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a472075590eb54b5c660ffc74927f1afc">version</a> () const</td></tr>
<tr class="memdesc:a472075590eb54b5c660ffc74927f1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to version information.  <a href="classcomms_1_1Message.html#a472075590eb54b5c660ffc74927f1afc">More...</a><br /></td></tr>
<tr class="separator:a472075590eb54b5c660ffc74927f1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861cf1ef73973117f7842e567b05a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:ac861cf1ef73973117f7842e567b05a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message contents using provided iterator.  <a href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">More...</a><br /></td></tr>
<tr class="separator:ac861cf1ef73973117f7842e567b05a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a34ba95e7ac41051fa41b5f559c1c0018"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a34ba95e7ac41051fa41b5f559c1c0018">areFieldsVersionDependent</a> ()</td></tr>
<tr class="memdesc:a34ba95e7ac41051fa41b5f559c1c0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the message fields are version dependent.  <a href="classcomms_1_1MessageBase.html#a34ba95e7ac41051fa41b5f559c1c0018">More...</a><br /></td></tr>
<tr class="separator:a34ba95e7ac41051fa41b5f559c1c0018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad51591454e5bc2a293743d2d1671d5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5">doGetId</a> ()</td></tr>
<tr class="memdesc:afad51591454e5bc2a293743d2d1671d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of ID retrieval functionality.  <a href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5">More...</a><br /></td></tr>
<tr class="separator:afad51591454e5bc2a293743d2d1671d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff048412f531c1d7294a3a96e34e03c0"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength</a> ()</td></tr>
<tr class="memdesc:aff048412f531c1d7294a3a96e34e03c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal serialisation length.  <a href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">More...</a><br /></td></tr>
<tr class="separator:aff048412f531c1d7294a3a96e34e03c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8579127c444abfb0923116b27c53efc"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:ab8579127c444abfb0923116b27c53efc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ab8579127c444abfb0923116b27c53efc">doMaxLengthFrom</a> ()</td></tr>
<tr class="memdesc:ab8579127c444abfb0923116b27c53efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#ab8579127c444abfb0923116b27c53efc">More...</a><br /></td></tr>
<tr class="separator:ab8579127c444abfb0923116b27c53efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25a2572c9d2ccc74ef764ead6701608"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:ac25a2572c9d2ccc74ef764ead6701608"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac25a2572c9d2ccc74ef764ead6701608">doMaxLengthUntil</a> ()</td></tr>
<tr class="memdesc:ac25a2572c9d2ccc74ef764ead6701608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of maximal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#ac25a2572c9d2ccc74ef764ead6701608">More...</a><br /></td></tr>
<tr class="separator:ac25a2572c9d2ccc74ef764ead6701608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength</a> ()</td></tr>
<tr class="memdesc:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal serialisation length.  <a href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">More...</a><br /></td></tr>
<tr class="separator:a6e9b89aab4e8cd2e60095f1d6ac9eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a1d36b0b3b6eec0319a4d8be725a56c52">doMinLengthFrom</a> ()</td></tr>
<tr class="memdesc:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#a1d36b0b3b6eec0319a4d8be725a56c52">More...</a><br /></td></tr>
<tr class="separator:a1d36b0b3b6eec0319a4d8be725a56c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf42c9d15d9cacb72dba9a4742609be"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:afdf42c9d15d9cacb72dba9a4742609be"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afdf42c9d15d9cacb72dba9a4742609be">doMinLengthUntil</a> ()</td></tr>
<tr class="memdesc:afdf42c9d15d9cacb72dba9a4742609be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time constant of minimal partial serialisation length.  <a href="classcomms_1_1MessageBase.html#afdf42c9d15d9cacb72dba9a4742609be">More...</a><br /></td></tr>
<tr class="separator:afdf42c9d15d9cacb72dba9a4742609be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memItemLeft" align="right" valign="top"><a id="aec8ad53f1b5aa5f06a0d47c7d9585783"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aec8ad53f1b5aa5f06a0d47c7d9585783">hasDispatch</a> ()</td></tr>
<tr class="memdesc:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> and <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">dispatchImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> and <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> types. <br /></td></tr>
<tr class="separator:aec8ad53f1b5aa5f06a0d47c7d9585783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13724033c28237b389725d379d1f5b9f"><td class="memItemLeft" align="right" valign="top"><a id="a13724033c28237b389725d379d1f5b9f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian</a> ()</td></tr>
<tr class="memdesc:a13724033c28237b389725d379d1f5b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> and <a class="el" href="classcomms_1_1Field.html">Field</a> types. <br /></td></tr>
<tr class="separator:a13724033c28237b389725d379d1f5b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memItemLeft" align="right" valign="top"><a id="aa00be33cb01b7e9cdee9ecebfa54c171"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId</a> ()</td></tr>
<tr class="memdesc:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId()</a> and <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aa00be33cb01b7e9cdee9ecebfa54c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaded9d46874a89824e91c962524836d"><td class="memItemLeft" align="right" valign="top"><a id="aaaded9d46874a89824e91c962524836d"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength</a> ()</td></tr>
<tr class="memdesc:aaaded9d46874a89824e91c962524836d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> and <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">lengthImpl()</a> member functions. <br /></td></tr>
<tr class="separator:aaaded9d46874a89824e91c962524836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37efad282638409ff120b999954c2117"><td class="memItemLeft" align="right" valign="top"><a id="a37efad282638409ff120b999954c2117"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a37efad282638409ff120b999954c2117">hasMsgIdType</a> ()</td></tr>
<tr class="memdesc:a37efad282638409ff120b999954c2117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> and <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> types. <br /></td></tr>
<tr class="separator:a37efad282638409ff120b999954c2117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaf6e76e7639112d33a04683a4e1a43"><td class="memItemLeft" align="right" valign="top"><a id="abcaf6e76e7639112d33a04683a4e1a43"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName</a> ()</td></tr>
<tr class="memdesc:abcaf6e76e7639112d33a04683a4e1a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">name()</a> and <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">nameImpl()</a> member functions. <br /></td></tr>
<tr class="separator:abcaf6e76e7639112d33a04683a4e1a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memItemLeft" align="right" valign="top"><a id="a1cab88111f9e395e71f8a8eb05c99fb5"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead</a> ()</td></tr>
<tr class="memdesc:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read()</a> and <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> type. <br /></td></tr>
<tr class="separator:a1cab88111f9e395e71f8a8eb05c99fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memItemLeft" align="right" valign="top"><a id="ae0929a96d1cb0c12a2b2a383ebd015ef"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ae0929a96d1cb0c12a2b2a383ebd015ef">hasRefresh</a> ()</td></tr>
<tr class="memdesc:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh()</a> and <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">refreshImpl()</a> member functions. <br /></td></tr>
<tr class="separator:ae0929a96d1cb0c12a2b2a383ebd015ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memItemLeft" align="right" valign="top"><a id="a57f6dc0452da23c5cdf25ec56b26df80"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields</a> ()</td></tr>
<tr class="memdesc:a57f6dc0452da23c5cdf25ec56b26df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> type. <br /></td></tr>
<tr class="separator:a57f6dc0452da23c5cdf25ec56b26df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133c135fda72ca2257fed0f5427053b4"><td class="memItemLeft" align="right" valign="top"><a id="a133c135fda72ca2257fed0f5427053b4"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid</a> ()</td></tr>
<tr class="memdesc:a133c135fda72ca2257fed0f5427053b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid()</a> and <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">validImpl()</a> member functions. <br /></td></tr>
<tr class="separator:a133c135fda72ca2257fed0f5427053b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8cdb390a3a51811a5a836cff0b7828"><td class="memItemLeft" align="right" valign="top"><a id="afa8cdb390a3a51811a5a836cff0b7828"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#afa8cdb390a3a51811a5a836cff0b7828">hasVersionInTransportFields</a> ()</td></tr>
<tr class="memdesc:afa8cdb390a3a51811a5a836cff0b7828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether there is version information inside transport fields. <br /></td></tr>
<tr class="separator:afa8cdb390a3a51811a5a836cff0b7828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memItemLeft" align="right" valign="top"><a id="aa7a317a10acda2cd7affd8b69a7b459a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite</a> ()</td></tr>
<tr class="memdesc:aa7a317a10acda2cd7affd8b69a7b459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile type inquiry whether message interface class defines <a class="el" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write()</a> and <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">writeImpl()</a> member functions as well as <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> type. <br /></td></tr>
<tr class="separator:aa7a317a10acda2cd7affd8b69a7b459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6c99a8d76e578261d01388ee3848e40e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">dispatchImpl</a> (<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;handler) override</td></tr>
<tr class="memdesc:a6c99a8d76e578261d01388ee3848e40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of dispatch functionality.  <a href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">More...</a><br /></td></tr>
<tr class="separator:a6c99a8d76e578261d01388ee3848e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1370aa1f188ead8dee2091cffb691c65"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a1370aa1f188ead8dee2091cffb691c65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a1370aa1f188ead8dee2091cffb691c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">More...</a><br /></td></tr>
<tr class="separator:a1370aa1f188ead8dee2091cffb691c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0022211e70afa1b915ecd2bd74c9b39"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ac0022211e70afa1b915ecd2bd74c9b39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac0022211e70afa1b915ecd2bd74c9b39">doReadFromAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ac0022211e70afa1b915ecd2bd74c9b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but modifies length parameter.  <a href="classcomms_1_1MessageBase.html#ac0022211e70afa1b915ecd2bd74c9b39">More...</a><br /></td></tr>
<tr class="separator:ac0022211e70afa1b915ecd2bd74c9b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46df98c07723fa701f74b1b03c63a508"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a46df98c07723fa701f74b1b03c63a508"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a46df98c07723fa701f74b1b03c63a508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">More...</a><br /></td></tr>
<tr class="separator:a46df98c07723fa701f74b1b03c63a508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce678a197ee7bfc4a4c7493813a4db2"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:afce678a197ee7bfc4a4c7493813a4db2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#afce678a197ee7bfc4a4c7493813a4db2">doReadFromUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:afce678a197ee7bfc4a4c7493813a4db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but modifies length parameter.  <a href="classcomms_1_1MessageBase.html#afce678a197ee7bfc4a4c7493813a4db2">More...</a><br /></td></tr>
<tr class="separator:afce678a197ee7bfc4a4c7493813a4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dac1f0e29db4e1904f89688299d5003"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a5dac1f0e29db4e1904f89688299d5003"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a5dac1f0e29db4e1904f89688299d5003">doReadNoStatusFrom</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a5dac1f0e29db4e1904f89688299d5003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a5dac1f0e29db4e1904f89688299d5003">More...</a><br /></td></tr>
<tr class="separator:a5dac1f0e29db4e1904f89688299d5003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aeb3836dc4c1e9517a4331a9e80b53a11">doReadNoStatusFromUntil</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#aeb3836dc4c1e9517a4331a9e80b53a11">More...</a><br /></td></tr>
<tr class="separator:aeb3836dc4c1e9517a4331a9e80b53a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d28011159c7a2adccf151304e88f7"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a231d28011159c7a2adccf151304e88f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a231d28011159c7a2adccf151304e88f7">doReadNoStatusUntil</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a231d28011159c7a2adccf151304e88f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a231d28011159c7a2adccf151304e88f7">More...</a><br /></td></tr>
<tr class="separator:a231d28011159c7a2adccf151304e88f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af335676e4b4f9667887443aa7c6482ea"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:af335676e4b4f9667887443aa7c6482ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:af335676e4b4f9667887443aa7c6482ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to read only limited number of fields.  <a href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">More...</a><br /></td></tr>
<tr class="separator:af335676e4b4f9667887443aa7c6482ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a04675c280e76ad35a9996fc29274f"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ac5a04675c280e76ad35a9996fc29274f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ac5a04675c280e76ad35a9996fc29274f">doReadUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ac5a04675c280e76ad35a9996fc29274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but updating length parameter.  <a href="classcomms_1_1MessageBase.html#ac5a04675c280e76ad35a9996fc29274f">More...</a><br /></td></tr>
<tr class="separator:ac5a04675c280e76ad35a9996fc29274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">More...</a><br /></td></tr>
<tr class="separator:a54e6eb8daaf93a8671d3f8e5e0e32f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3385ab7b850a9d3825860be5b303bd6d"><td class="memTemplParams" colspan="2"><a id="a3385ab7b850a9d3825860be5b303bd6d"></a>
template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a3385ab7b850a9d3825860be5b303bd6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a3385ab7b850a9d3825860be5b303bd6d">doWriteFromAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a3385ab7b850a9d3825860be5b303bd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a>, but modifies length parameter. <br /></td></tr>
<tr class="separator:a3385ab7b850a9d3825860be5b303bd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11a7be936db0cdce89540264b295619"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ae11a7be936db0cdce89540264b295619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:ae11a7be936db0cdce89540264b295619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">More...</a><br /></td></tr>
<tr class="separator:ae11a7be936db0cdce89540264b295619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="memTemplParams" colspan="2"><a id="a2281fd57ba4d05ac3cd4e15e9f802934"></a>
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2281fd57ba4d05ac3cd4e15e9f802934">doWriteFromUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#a5040afe5026d3f2840cd53b77eddf4e8">doWriteNoStatusFrom()</a>, but updates length information. <br /></td></tr>
<tr class="separator:a2281fd57ba4d05ac3cd4e15e9f802934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5040afe5026d3f2840cd53b77eddf4e8"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a5040afe5026d3f2840cd53b77eddf4e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a5040afe5026d3f2840cd53b77eddf4e8">doWriteNoStatusFrom</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:a5040afe5026d3f2840cd53b77eddf4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a5040afe5026d3f2840cd53b77eddf4e8">More...</a><br /></td></tr>
<tr class="separator:a5040afe5026d3f2840cd53b77eddf4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ae21e997e8d813d21c3fe7ff0c145fbd6">doWriteNoStatusFromUntil</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#ae21e997e8d813d21c3fe7ff0c145fbd6">More...</a><br /></td></tr>
<tr class="separator:ae21e997e8d813d21c3fe7ff0c145fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077d4c33307dac9474366666e22ac3f7"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a077d4c33307dac9474366666e22ac3f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a077d4c33307dac9474366666e22ac3f7">doWriteNoStatusUntil</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:a077d4c33307dac9474366666e22ac3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#a077d4c33307dac9474366666e22ac3f7">More...</a><br /></td></tr>
<tr class="separator:a077d4c33307dac9474366666e22ac3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6848f65ab796a33517c3d48aa78de"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:aa8e6848f65ab796a33517c3d48aa78de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:aa8e6848f65ab796a33517c3d48aa78de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows to write only limited number of fields.  <a href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">More...</a><br /></td></tr>
<tr class="separator:aa8e6848f65ab796a33517c3d48aa78de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb223527d8d06a853aaf1b3ec2166d"><td class="memTemplParams" colspan="2"><a id="a15eb223527d8d06a853aaf1b3ec2166d"></a>
template&lt;std::size_t TIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a15eb223527d8d06a853aaf1b3ec2166d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a15eb223527d8d06a853aaf1b3ec2166d">doWriteUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len) const</td></tr>
<tr class="memdesc:a15eb223527d8d06a853aaf1b3ec2166d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a>, but modifies length parameter. <br /></td></tr>
<tr class="separator:a15eb223527d8d06a853aaf1b3ec2166d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2194842a823f51fb02f2e3622550798a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">getIdImpl</a> () const override</td></tr>
<tr class="memdesc:a2194842a823f51fb02f2e3622550798a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ID retrieval functionality.  <a href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">More...</a><br /></td></tr>
<tr class="separator:a2194842a823f51fb02f2e3622550798a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8">lengthImpl</a> () const override</td></tr>
<tr class="memdesc:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic length calculation functionality.  <a href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8">More...</a><br /></td></tr>
<tr class="separator:a9bc67df1b7b19a2a4263173d3badf8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6888dd9d8d070ac042a13ac48fc334"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">nameImpl</a> () const override</td></tr>
<tr class="memdesc:a4b6888dd9d8d070ac042a13ac48fc334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic name retrieval functionality.  <a href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">More...</a><br /></td></tr>
<tr class="separator:a4b6888dd9d8d070ac042a13ac48fc334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bf76bcd33967e6fc543480c1643114"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">readImpl</a> (<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;iter, std::size_t size) override</td></tr>
<tr class="memdesc:a53bf76bcd33967e6fc543480c1643114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic read functionality.  <a href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">More...</a><br /></td></tr>
<tr class="separator:a53bf76bcd33967e6fc543480c1643114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b9cea8e73c2f592ffd55fd274893ba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">refreshImpl</a> () override</td></tr>
<tr class="memdesc:a49b9cea8e73c2f592ffd55fd274893ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic refresh functionality.  <a href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">More...</a><br /></td></tr>
<tr class="separator:a49b9cea8e73c2f592ffd55fd274893ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab1fe69accb75656f90e903da24fdc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc">validImpl</a> () const override</td></tr>
<tr class="memdesc:abeab1fe69accb75656f90e903da24fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic validity check functionality.  <a href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc">More...</a><br /></td></tr>
<tr class="separator:abeab1fe69accb75656f90e903da24fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58412054c729f562ed1d99fda27fbf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">writeImpl</a> (<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;iter, std::size_t size) const override</td></tr>
<tr class="memdesc:a7b58412054c729f562ed1d99fda27fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of polymorphic write functionality.  <a href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">More...</a><br /></td></tr>
<tr class="separator:a7b58412054c729f562ed1d99fda27fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:ac484455094ac1eb1aa189bdc6d527ded"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:ac484455094ac1eb1aa189bdc6d527ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input area.  <a href="classcomms_1_1Message.html#ac484455094ac1eb1aa189bdc6d527ded">More...</a><br /></td></tr>
<tr class="separator:ac484455094ac1eb1aa189bdc6d527ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:a51c517d87946dea783a006f34a9868c8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a51c517d87946dea783a006f34a9868c8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a51c517d87946dea783a006f34a9868c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input area.  <a href="classcomms_1_1Message.html#a51c517d87946dea783a006f34a9868c8">More...</a><br /></td></tr>
<tr class="separator:a51c517d87946dea783a006f34a9868c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a5ebf1dd77a1c6458392a9001d187ad45">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:a5ebf1dd77a1c6458392a9001d187ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output area.  <a href="classcomms_1_1Message.html#a5ebf1dd77a1c6458392a9001d187ad45">More...</a><br /></td></tr>
<tr class="separator:a5ebf1dd77a1c6458392a9001d187ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:abe23293aedd424af62bd5f4d05571b59"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#abe23293aedd424af62bd5f4d05571b59">writeData</a> (T value, TIter &amp;iter)</td></tr>
<tr class="memdesc:abe23293aedd424af62bd5f4d05571b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output area.  <a href="classcomms_1_1Message.html#abe23293aedd424af62bd5f4d05571b59">More...</a><br /></td></tr>
<tr class="separator:abe23293aedd424af62bd5f4d05571b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(f_, ...)</td></tr>
<tr class="memdesc:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias types and access member functions for other member fields.  <a href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">More...</a><br /></td></tr>
<tr class="separator:a43c008e2ba360d9dd4917a1c9f80bd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">COMMS_MSG_FIELD_ALIAS_ACCESS</a>(f_, ...)&#160;&#160;&#160;COMMS_DO_ALIAS(field_, f_, __VA_ARGS__)</td></tr>
<tr class="memdesc:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for other member fields.  <a href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">More...</a><br /></td></tr>
<tr class="separator:ab20effdb4cb453bd6b2eb86246b6ede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cd34ed5b338241067433c45d7345ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:a25cd34ed5b338241067433c45d7345ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to message fields.  <a href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">More...</a><br /></td></tr>
<tr class="separator:a25cd34ed5b338241067433c45d7345ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70987da383935a4cf0ceb5228f497a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a2c70987da383935a4cf0ceb5228f497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for message fields.  <a href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">More...</a><br /></td></tr>
<tr class="separator:a2c70987da383935a4cf0ceb5228f497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(f_, ...)</td></tr>
<tr class="memdesc:adfa416afa2a8a77af9c46b42d3034f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">More...</a><br /></td></tr>
<tr class="separator:adfa416afa2a8a77af9c46b42d3034f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, ...)&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td></tr>
<tr class="memdesc:a33954a8d8c1b0e04175ada3e840bcb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate convinience alias access member functions for extra member transport fields.  <a href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">More...</a><br /></td></tr>
<tr class="separator:a33954a8d8c1b0e04175ada3e840bcb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada784673f02d483a88fcf0c451cb72bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:ada784673f02d483a88fcf0c451cb72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to extra transport fields.  <a href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">More...</a><br /></td></tr>
<tr class="separator:ada784673f02d483a88fcf0c451cb72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00912bb201d47afbb0c3e51fff95b338"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a00912bb201d47afbb0c3e51fff95b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for extra transport fields.  <a href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">More...</a><br /></td></tr>
<tr class="separator:a00912bb201d47afbb0c3e51fff95b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ecd276ccd033225ecfdc4909f2d211"><td class="memTemplParams" colspan="2">template&lt;typename TMessage1 , typename TMessage2 , typename... TOptions&gt; </td></tr>
<tr class="memitem:a05ecd276ccd033225ecfdc4909f2d211"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#a05ecd276ccd033225ecfdc4909f2d211">operator!=</a> (const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;msg1, const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;msg2) noexcept</td></tr>
<tr class="memdesc:a05ecd276ccd033225ecfdc4909f2d211"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object inequality comparison operator.  <a href="classcomms_1_1MessageBase.html#a05ecd276ccd033225ecfdc4909f2d211">More...</a><br /></td></tr>
<tr class="separator:a05ecd276ccd033225ecfdc4909f2d211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f49a279a7f24e25156bacfd3a9ccc"><td class="memTemplParams" colspan="2">template&lt;typename TMessage1 , typename TMessage2 , typename... TOptions&gt; </td></tr>
<tr class="memitem:ad59f49a279a7f24e25156bacfd3a9ccc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html#ad59f49a279a7f24e25156bacfd3a9ccc">operator==</a> (const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;msg1, const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;msg2) noexcept</td></tr>
<tr class="memdesc:ad59f49a279a7f24e25156bacfd3a9ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object equality comparison operator.  <a href="classcomms_1_1MessageBase.html#ad59f49a279a7f24e25156bacfd3a9ccc">More...</a><br /></td></tr>
<tr class="separator:ad59f49a279a7f24e25156bacfd3a9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a108df722c6d6e5016ab6b35b961b43cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108df722c6d6e5016ab6b35b961b43cd">&#9670;&nbsp;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::<a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> =  FieldsProvidedWithOption</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All field classes provided with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p>
<p>The type is not defined if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. </p>

</div>
</div>
<a id="a43d474f5037090d6d749419c51f2e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d474f5037090d6d749419c51f2e100">&#9670;&nbsp;</a></span>DispatchRetType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> =  typename Handler::RetType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">dispatch()</a> member function. </p>
<p>Equal to <b>Handler::RetType</b> if such exists, <b>void</b> otherwise. </p>

</div>
</div>
<a id="a1bb35fb9379a188ce663079c956b3f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb35fb9379a188ce663079c956b3f80">&#9670;&nbsp;</a></span>Endian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> =  typename BaseImpl::Endian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialisation endian type. </p>
<p>The type exists only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used to specify it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a13724033c28237b389725d379d1f5b9f">hasEndian()</a> </dd></dl>

</div>
</div>
<a id="a4cd3705f965f28c601858aced3f16c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd3705f965f28c601858aced3f16c48">&#9670;&nbsp;</a></span>Field</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">Field</a> =  BaseImpl::Field</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of default base class for all the fields. </p>
<p>Requires definition of the <a class="el" href="classcomms_1_1Message.html#a1bb35fb9379a188ce663079c956b3f80">Endian</a> type, i.e. the type exist only if <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options were used. </p>

</div>
</div>
<a id="a30b17e6aee609c0bb061556f4a0979bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b17e6aee609c0bb061556f4a0979bb">&#9670;&nbsp;</a></span>Handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the message handler object. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p>

</div>
</div>
<a id="aa99780161941773e6bbe2767675c4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99780161941773e6bbe2767675c4a03">&#9670;&nbsp;</a></span>MsgIdParamType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> =  typename BaseImpl::MsgIdParamType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for message ID passed as parameter or returned from function. </p>
<p>It is equal to <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> for numeric types and becomes "const-reference-to" <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> for more complex types. The type exists only if <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> exists, i.e. the <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used. </p>

</div>
</div>
<a id="aa7bb56b0758dfa9a8f9be12d3b8295a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bb56b0758dfa9a8f9be12d3b8295a2">&#9670;&nbsp;</a></span>MsgIdType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">MsgIdType</a> =  typename BaseImpl::MsgIdType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for message ID. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a37efad282638409ff120b999954c2117" title="Compile type inquiry whether message interface class defines MsgIdType and MsgIdParamType types.">hasMsgIdType()</a> </dd></dl>

</div>
</div>
<a id="a463c7edb3734bffca6c41b9cee3d3f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463c7edb3734bffca6c41b9cee3d3f0a">&#9670;&nbsp;</a></span>ReadIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the iterator used for reading message contents from sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="a1a7c7b92d38774a038fbdedb3e0f99cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7c7b92d38774a038fbdedb3e0f99cc">&#9670;&nbsp;</a></span>TransportFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> =  FieldsProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>std::tuple</b> of extra fields from transport layers that may affect the way the message fields get serialized / deserialized. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="adf1cc4a66938068978b802ae5b76a2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1cc4a66938068978b802ae5b76a2d1">&#9670;&nbsp;</a></span>VersionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a> =  typename BaseImpl::VersionType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type used for version info. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="aee6698a41e3975ed6047dac727fe9a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6698a41e3975ed6047dac727fe9a0c">&#9670;&nbsp;</a></span>WriteIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::<a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> =  TypeProvidedWithOption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the iterator used for writing message contents into sequence of bytes stored somewhere. </p>
<p>The type exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34ba95e7ac41051fa41b5f559c1c0018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ba95e7ac41051fa41b5f559c1c0018">&#9670;&nbsp;</a></span>areFieldsVersionDependent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::areFieldsVersionDependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check of whether the message fields are version dependent. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if at least one of the fields is version dependent. </dd></dl>

</div>
</div>
<a id="af2781055a9fb72a553d56cfd6ac99c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2781055a9fb72a553d56cfd6ac99c5e">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch message to the handler for processing. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the handler. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e" title="Implementation of dispatch functionality.">dispatchImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Handler object to dispatch message to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c99a8d76e578261d01388ee3848e40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c99a8d76e578261d01388ee3848e40e">&#9670;&nbsp;</a></span>dispatchImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::dispatchImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of dispatch functionality. </p>
<p>This function exists only if the following conditions are <b>true:</b> </p><ul>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify actual type of the inheriting message class. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoDispatchImpl.html">comms::option::app::NoDispatchImpl</a> option was <b>NOT</b> used.</li>
</ul>
<p>In order to properly implement the dispatch functionality this class imposes several requirements. First of all, the custom message class must provide its own type as an argument to <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessageBase :  <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt; { ...};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Message1 :</div>
<div class="line">    <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        MyMessageBase,</div>
<div class="line">        ...</div>
<div class="line">        comms::option::def::MsgType&lt;Message1&gt;</div>
<div class="line">        ...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html"><div class="ttname"><a href="classcomms_1_1MessageBase.html">comms::MessageBase</a></div><div class="ttdoc">Base class for all the custom protocol messages.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:80</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html"><div class="ttname"><a href="classcomms_1_1Message.html">comms::Message</a></div><div class="ttdoc">Main interface class for all the messages.</div><div class="ttdef"><b>Definition:</b> Message.h:80</div></div>
</div><!-- fragment --><p> Second, The <a class="el" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a> type (inherited from <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>) must implement "handle()" member function for every message type (specified as Message1, Message2, ...) it is supposed to handle: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(Message1&amp; msg);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(Message2&amp; msg);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a43d474f5037090d6d749419c51f2e100"><div class="ttname"><a href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">comms::Message::DispatchRetType</a></div><div class="ttdeci">typename Handler::RetType DispatchRetType</div><div class="ttdoc">Return type of the dispatch() member function.</div><div class="ttdef"><b>Definition:</b> Message.h:302</div></div>
</div><!-- fragment --><p> The "handle()" functions may be virtual. If the handler is capable of handling only limited number of messages, there is a need to provide additional "handle()" member function to implement default handling functionality (usually ignore the message by doing nothing) for all other messages that weren't handled explicitly. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> handle(MessageBase&amp; msg);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Where "MessageBase" is a common base class for all the possible messages.</p>
<p>Once the requirements above are properly implemented, the implementation of this message is very simple: </p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1Message.html#a43d474f5037090d6d749419c51f2e100">DispatchRetType</a> <a class="code" href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">dispatchImpl</a>(<a class="code" href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">Handler</a>&amp; handler)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> &lt;actual-message-type-provided-with-option&gt; Actual;</div>
<div class="line">    <span class="keywordflow">return</span> handler.handle(<span class="keyword">static_cast&lt;</span>Actual&amp;<span class="keyword">&gt;</span>(*<span class="keyword">this</span>));</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a6c99a8d76e578261d01388ee3848e40e"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a6c99a8d76e578261d01388ee3848e40e">comms::MessageBase::dispatchImpl</a></div><div class="ttdeci">virtual DispatchRetType dispatchImpl(Handler &amp;handler) override</div><div class="ttdoc">Implementation of dispatch functionality.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a30b17e6aee609c0bb061556f4a0979bb"><div class="ttname"><a href="classcomms_1_1Message.html#a30b17e6aee609c0bb061556f4a0979bb">comms::Message::Handler</a></div><div class="ttdeci">TypeProvidedWithOption Handler</div><div class="ttdoc">Type of the message handler object.</div><div class="ttdef"><b>Definition:</b> Message.h:298</div></div>
</div><!-- fragment --><p> The code above forces a compiler to choose appropriate <b>handle()</b> function in the Handler class, based on the actual type of the message. If such function is not found, the compiler will choose to call the one that covers all possible messages <b>"void handle(MessageBase&amp; msg)"</b>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Reference to handler object. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ab89e468c618e0f3697c73ffb98bc9d54">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a87ba954a125586e6a339aad7b0d11e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ba954a125586e6a339aad7b0d11e7c">&#9670;&nbsp;</a></span>doFieldsVersionUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doFieldsVersionUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update version information of all the fields. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> and <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> was provided to the message interface class (<a class="el" href="classcomms_1_1Message.html">comms::Message</a>). <br  />
 This function will invoke such <b>setVersion()</b> member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option and will return <b>true</b> if <b>at least</b> one of the invoked functions returned <b>true</b> (similar to <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh()</a>). </p><dl class="section return"><dt>Returns</dt><dd>true when <b>at least</b> one of the fields has been updated. </dd></dl>

</div>
</div>
<a id="afad51591454e5bc2a293743d2d1671d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad51591454e5bc2a293743d2d1671d5">&#9670;&nbsp;</a></span>doGetId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doGetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of ID retrieval functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. <br  />
</p><dl class="section return"><dt>Returns</dt><dd>Numeric ID of the message. </dd></dl>

</div>
</div>
<a id="a6d36881b8fea2fa53cc8e17a1e82df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d36881b8fea2fa53cc8e17a1e82df27">&#9670;&nbsp;</a></span>doLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of length calculation functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. To make this function works, every field class must provide "length()" function with following signature: </p><div class="fragment"><div class="line">std::size_t <a class="code" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a91dba816185287db6d38a3274743f6cf"><div class="ttname"><a href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">comms::Message::length</a></div><div class="ttdeci">std::size_t length() const</div><div class="ttdoc">Get number of bytes required to serialise this message.</div></div>
</div><!-- fragment --><p> This function will invoke such "length()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. The final result is a summary of the "length" values of all the fields. </p><dl class="section return"><dt>Returns</dt><dd>Serialisation length of the message. </dd></dl>

</div>
</div>
<a id="a60c05d81adc406833e9ead9e4e2c5d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c05d81adc406833e9ead9e4e2c5d51">&#9670;&nbsp;</a></span>doLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a21cd333d3fbdb22b7c5386a545a2870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cd333d3fbdb22b7c5386a545a2870d">&#9670;&nbsp;</a></span>doLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a869d6398fd3e1ddb298e37927d3f7c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869d6398fd3e1ddb298e37927d3f7c35">&#9670;&nbsp;</a></span>doLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of partial length calculation functionality. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#a91dba816185287db6d38a3274743f6cf">length()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aff048412f531c1d7294a3a96e34e03c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff048412f531c1d7294a3a96e34e03c0">&#9670;&nbsp;</a></span>doMaxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal serialisation length. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. To make this function works, every field class must provide "maxLength()" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr std::size_t maxLength();</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Minimal serialisation length of the message. </dd></dl>

</div>
</div>
<a id="ab8579127c444abfb0923116b27c53efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8579127c444abfb0923116b27c53efc">&#9670;&nbsp;</a></span>doMaxLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a3ba7e14c08930d6fd0e7f2a354cecb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba7e14c08930d6fd0e7f2a354cecb9a">&#9670;&nbsp;</a></span>doMaxLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="ac25a2572c9d2ccc74ef764ead6701608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a2572c9d2ccc74ef764ead6701608">&#9670;&nbsp;</a></span>doMaxLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMaxLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of maximal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">doMaxLength()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a6e9b89aab4e8cd2e60095f1d6ac9eb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9b89aab4e8cd2e60095f1d6ac9eb40">&#9670;&nbsp;</a></span>doMinLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal serialisation length. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. To make this function works, every field class must provide "minLength()" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr std::size_t minLength();</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Minimal serialisation length of the message. </dd></dl>

</div>
</div>
<a id="a1d36b0b3b6eec0319a4d8be725a56c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d36b0b3b6eec0319a4d8be725a56c52">&#9670;&nbsp;</a></span>doMinLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aa967c1d370f4a40a6cb2f4de2f1f0168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa967c1d370f4a40a6cb2f4de2f1f0168">&#9670;&nbsp;</a></span>doMinLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but starts the calculation at the the field specified using <b>TFromIdx</b> template parameter, and stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field, from which length calculation will start </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="afdf42c9d15d9cacb72dba9a4742609be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf42c9d15d9cacb72dba9a4742609be">&#9670;&nbsp;</a></span>doMinLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doMinLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time constant of minimal partial serialisation length. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">doMinLength()</a> member function but stops the calculation at the the field specified using <b>TUntilIdx</b> template parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field, at which the calculation will stop. The length of the filed with index <b>TUntilIdx</b> will <b>NOT</b> be taken into account. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Calculated minimal serialisation length </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="a45782845d1f24fc957efe1a41fdf32c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45782845d1f24fc957efe1a41fdf32c4">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of read functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. <br  />
 To make this function works, every field class must provide "read" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a>(TIter&amp; iter, std::size_t size);</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a77396db2ec7a29de4bf335af49e1d760"><div class="ttname"><a href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">comms::Message::read</a></div><div class="ttdeci">ErrorStatus read(ReadIterator &amp;iter, std::size_t size)</div><div class="ttdoc">Read message contents using provided iterator.</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition:</b> ErrorStatus.h:17</div></div>
</div><!-- fragment --><p> This function will invoke such "read()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. If any field doesn't report <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">ErrorStatus::Success</a>, then read operation stops, i.e. the provided iterator is not advanced any more. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a1370aa1f188ead8dee2091cffb691c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1370aa1f188ead8dee2091cffb691c65">&#9670;&nbsp;</a></span>doReadFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other field exists or must be skipped. In this case the derived class must implement different read functionality. To help in such task <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a> function allows to read fields up to a specified one, while this function provides an ability to resume reading from some other field in the middle. The overriding <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> function in the custom message definition class may use this function for such task. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read from. The function reads all the fields between the one indexed TIdx (included) and the last one (also included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ac0022211e70afa1b915ecd2bd74c9b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0022211e70afa1b915ecd2bd74c9b39">&#9670;&nbsp;</a></span>doReadFromAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but modifies length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46df98c07723fa701f74b1b03c63a508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46df98c07723fa701f74b1b03c63a508">&#9670;&nbsp;</a></span>doReadFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other fields exist or must be skipped. In this case the derived class must implement different read functionality. In similar way to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65" title="Helper function that allows to read only limited number of fields.">doReadFrom()</a> and <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea" title="Helper function that allows to read only limited number of fields.">doReadUntil()</a> this function provides an ability to read any number of fields. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to read from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to read until (not included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="afce678a197ee7bfc4a4c7493813a4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce678a197ee7bfc4a4c7493813a4db2">&#9670;&nbsp;</a></span>doReadFromUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadFromUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but modifies length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dac1f0e29db4e1904f89688299d5003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dac1f0e29db4e1904f89688299d5003">&#9670;&nbsp;</a></span>doReadNoStatusFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">doReadFrom()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read from. The function reads all the fields between the one indexed TIdx (included) and the last one (also included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aeb3836dc4c1e9517a4331a9e80b53a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3836dc4c1e9517a4331a9e80b53a11">&#9670;&nbsp;</a></span>doReadNoStatusFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">doReadFromUntil()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to read from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to read until (not included). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a231d28011159c7a2adccf151304e88f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231d28011159c7a2adccf151304e88f7">&#9670;&nbsp;</a></span>doReadNoStatusUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadNoStatusUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a> when correction of the read operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read until. The function returns when field with index "TIdx - 1" (if such exists) has been read, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="af335676e4b4f9667887443aa7c6482ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af335676e4b4f9667887443aa7c6482ea">&#9670;&nbsp;</a></span>doReadUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to read only limited number of fields. </p>
<p>Sometimes the default implementation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> is incorrect. For example, some bit in specific field specifies whether other field exists or must be skipped. In this case the derived class must implement different read functionality. To help in such task this function provides an ability to read all the fields up to (not including) requested field. The overriding <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> function in the custom message definition class may use this function for such task. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to read until. The function returns when field with index "TIdx - 1" (if such exists) has been read, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ac5a04675c280e76ad35a9996fc29274f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a04675c280e76ad35a9996fc29274f">&#9670;&nbsp;</a></span>doReadUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doReadUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">doReadUntil()</a>, but updating length parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Maximum number of bytes that can be read. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2feb6d8948de99eef4213a234625d3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb6d8948de99eef4213a234625d3ec">&#9670;&nbsp;</a></span>doRefresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doRefresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of refreshing functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. To make this function works, every field class must provide "refresh()" function with following signature: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasscomms_1_1Message_html_adf78ac63decb13777fd7d203de01fdd1"><div class="ttname"><a href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">comms::Message::refresh</a></div><div class="ttdeci">bool refresh()</div><div class="ttdoc">Refresh to contents of the message.</div></div>
</div><!-- fragment --><p> This function will invoke such "refresh()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option and will return <b>true</b> if <b>at least</b> one of the invoked functions returned <b>true</b>. </p><dl class="section return"><dt>Returns</dt><dd>true when <b>at least</b> one of the fields has been updated. </dd></dl>

</div>
</div>
<a id="afcb3077fb16f36d4710effc4d61a1330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3077fb16f36d4710effc4d61a1330">&#9670;&nbsp;</a></span>doValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of validity check functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. To make this function works, every field class must provide "valid()" function with following signature: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">valid</a>() <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasscomms_1_1Message_html_aeb62f73f8c7db3745491ce668171af5f"><div class="ttname"><a href="classcomms_1_1Message.html#aeb62f73f8c7db3745491ce668171af5f">comms::Message::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Check validity of message contents.</div></div>
</div><!-- fragment --><p> This function will invoke such "valid()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="section return"><dt>Returns</dt><dd>true when <b>all</b> fields are valid. </dd></dl>

</div>
</div>
<a id="a79e5ec00e39ff64c5f9208813f270468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e5ec00e39ff64c5f9208813f270468">&#9670;&nbsp;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of write functionality. </p>
<p>This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. <br  />
 To make this function works, every field class must provide "write" function with following signature: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">write</a>(TIter&amp; iter, std::size_t size) <span class="keyword">const</span>;</div>
<div class="ttc" id="aclasscomms_1_1Message_html_ac861cf1ef73973117f7842e567b05a13"><div class="ttname"><a href="classcomms_1_1Message.html#ac861cf1ef73973117f7842e567b05a13">comms::Message::write</a></div><div class="ttdeci">ErrorStatus write(WriteIterator &amp;iter, std::size_t size) const</div><div class="ttdoc">Write message contents using provided iterator.</div></div>
</div><!-- fragment --><p> This function will invoke such "write()" member function for every field object listed with <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. If any field doesn't report <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">ErrorStatus::Success</a>, then write operation stops, i.e. the provided iterator is not advanced any more. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a54e6eb8daaf93a8671d3f8e5e0e32f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e6eb8daaf93a8671d3f8e5e0e32f46">&#9670;&nbsp;</a></span>doWriteFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65" title="Helper function that allows to read only limited number of fields.">doReadFrom()</a>, this function allows writing limited number of fields starting from the requested one until the end. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality.">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ae11a7be936db0cdce89540264b295619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11a7be936db0cdce89540264b295619">&#9670;&nbsp;</a></span>doWriteFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508" title="Helper function that allows to read only limited number of fields.">doReadFromUntil()</a>, this function allows writing limited number of fields between the requested indices. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality.">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to write until (not including). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a5040afe5026d3f2840cd53b77eddf4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5040afe5026d3f2840cd53b77eddf4e8">&#9670;&nbsp;</a></span>doWriteNoStatusFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">doWriteFrom()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="ae21e997e8d813d21c3fe7ff0c145fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21e997e8d813d21c3fe7ff0c145fbd6">&#9670;&nbsp;</a></span>doWriteNoStatusFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">doWriteFromUntil()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Zero based index of the field to write from. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Zero based index of the field to write until (not including). </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TUntilIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a077d4c33307dac9474366666e22ac3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077d4c33307dac9474366666e22ac3f7">&#9670;&nbsp;</a></span>doWriteNoStatusUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteNoStatusUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a>, but doesn't check for errors and doesn't report status. This function can be used instead of <a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">doWriteUntil()</a> when correction of the write operation was ensured by other means prior to its invocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write until. The function returns when field with index "TIdx - 1" (if such exists) has been written, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="aa8e6848f65ab796a33517c3d48aa78de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e6848f65ab796a33517c3d48aa78de">&#9670;&nbsp;</a></span>doWriteUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::doWriteUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that allows to write only limited number of fields. </p>
<p>In a similar way to <a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea" title="Helper function that allows to read only limited number of fields.">doReadUntil()</a>, this function allows writing limited number of fields starting from the first one. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af25731a01dd89c246a019d24c8f964d5">comms::option::def::ZeroFieldsImpl</a> option was provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. The requirements from field classes is the same as explained in <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality.">doWrite()</a> documentation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Zero based index of the field to write until. The function returns when field with index "TIdx - 1" (if such exists) has been written, while field with index "TIdx" still hasn't. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TIdx &lt;= std::tuple_size&lt;AllFields&gt;::value </dd></dl>

</div>
</div>
<a id="af4b8bc4b6db684d0006d2c6c70b1e891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b8bc4b6db684d0006d2c6c70b1e891">&#9670;&nbsp;</a></span>fields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a>&amp; <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an access to the fields of the message. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd>Reference to the fields of the message. </dd></dl>

</div>
</div>
<a id="a2dceebaa69e966780a805b1d4276386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dceebaa69e966780a805b1d4276386e">&#9670;&nbsp;</a></span>fields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a>&amp; <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an access to the fields of the message. </p>
<p>The function doesn't exist if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option wasn't provided to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a>. </p><dl class="section return"><dt>Returns</dt><dd>Const reference to the fields of the message. </dd></dl>

</div>
</div>
<a id="aaac9fd890f4efb1263179c3799d52098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9fd890f4efb1263179c3799d52098">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve ID of the message. </p>
<p>Invokes pure virtual <a class="el" href="classcomms_1_1MessageBase.html#a2194842a823f51fb02f2e3622550798a">getIdImpl()</a>. This function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option was used to specify type of the ID value and <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option are used. </p><dl class="section return"><dt>Returns</dt><dd>ID of the message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">hasGetId()</a>; </dd></dl>

</div>
</div>
<a id="a2194842a823f51fb02f2e3622550798a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2194842a823f51fb02f2e3622550798a">&#9670;&nbsp;</a></span>getIdImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">MsgIdParamType</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::getIdImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of ID retrieval functionality. </p>
<p>This function may exist only if ID retrieval is possible, i.e. the ID type has been privded to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> using <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> option and the polymorphic ID retrieval functionality was requested (using <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a>). In addition to the conditions listed earlier this function is provided if local <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality.">doGetId()</a> function was generated. If not, it may still be provided if the derived class is known (<a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used) and the <a class="el" href="structcomms_1_1option_1_1def_1_1HasDoGetId.html">comms::option::def::HasDoGetId</a> option is used to declare the derived type having <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality.">doGetId()</a> member function defined. </p><dl class="section return"><dt>Returns</dt><dd>ID value passed as template parameter to <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option. </dd></dl>

<p>Implements <a class="el" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a91dba816185287db6d38a3274743f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dba816185287db6d38a3274743f6cf">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of bytes required to serialise this message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a9bc67df1b7b19a2a4263173d3badf8b8" title="Implementation of polymorphic length calculation functionality.">lengthImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes required to serialise this message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">hasLength()</a> </dd></dl>

</div>
</div>
<a id="a9bc67df1b7b19a2a4263173d3badf8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc67df1b7b19a2a4263173d3badf8b8">&#9670;&nbsp;</a></span>lengthImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::lengthImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic length calculation functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoLengthImpl.html">comms::option::app::NoLengthImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br  />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27" title="Default implementation of length calculation functionality.">doLength()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27" title="Default implementation of length calculation functionality.">comms::MessageBase::doLength()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="section return"><dt>Returns</dt><dd>Serialisation length of the message. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ad7ec1d8f1eb313d3fc4b21febe118f6e">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="acdc8a1db5b023e576dd74f906dd547ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc8a1db5b023e576dd74f906dd547ad">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of the message. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">nameImpl()</a> function. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">hasName()</a> </dd></dl>

</div>
</div>
<a id="a4b6888dd9d8d070ac042a13ac48fc334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6888dd9d8d070ac042a13ac48fc334">&#9670;&nbsp;</a></span>nameImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::nameImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic name retrieval functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> as well as <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> options ware used for this class. This function downcasts <b>this</b> pointer to actual message type and invokes <b>doName()</b> member function. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> in case fields were updated, <b>false</b> if nothing has changed. </dd></dl>

<p>Implements <a class="el" href="classcomms_1_1Message.html#a36eeed2ffee7614b73cb5af211a263d6">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a77396db2ec7a29de4bf335af49e1d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77396db2ec7a29de4bf335af49e1d760">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a>. The contents of the message are updated with bytes being read. The buffer is external and maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114" title="Implementation of polymorphic read functionality.">readImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">hasRead()</a> </dd></dl>

</div>
</div>
<a id="ac484455094ac1eb1aa189bdc6d527ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac484455094ac1eb1aa189bdc6d527ded">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input area. </p>
<p>Use this function to read data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a51c517d87946dea783a006f34a9868c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c517d87946dea783a006f34a9868c8">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input area. </p>
<p>Use this function to read partial data from the input area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a53bf76bcd33967e6fc543480c1643114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bf76bcd33967e6fc543480c1643114">&#9670;&nbsp;</a></span>readImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::readImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#a463c7edb3734bffca6c41b9cee3d3f0a">ReadIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic read functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoReadImpl.html">comms::option::app::NoReadImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br  />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">doRead()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4" title="Default implementation of read functionality.">comms::MessageBase::doRead()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="adf78ac63decb13777fd7d203de01fdd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf78ac63decb13777fd7d203de01fdd1">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refresh to contents of the message. </p>
<p>Many protocols define their messages in a way that the content of some fields may depend on the value of the other field(s). For example, providing in one field the information about number of elements in the list that will follow later. Another example is having bits in a bitmask field specifying whether other optional fields exist. In this case, directly modifying value of some fields may leave a message contents in an inconsistent state. Having <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1" title="Refresh to contents of the message.">refresh()</a> member function allows the developer to bring the message into a consistent state prior to sending it over I/O link . <br  />
 The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba" title="Implementation of polymorphic refresh functionality.">refreshImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true in case the contents of the message were modified, false if all the fields of the message remained unchanged. </dd></dl>

</div>
</div>
<a id="a49b9cea8e73c2f592ffd55fd274893ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b9cea8e73c2f592ffd55fd274893ba">&#9670;&nbsp;</a></span>refreshImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::refreshImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic refresh functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> option was used (either on on of the fields or when defining a message class) to to notify about existence of custom refresh functionality. If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual message class, the <b>this</b> pointer will be downcasted to it to invoke <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec" title="Default implementation of refreshing functionality.">doRefresh()</a> member function defined there. If such is not defined the default <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec" title="Default implementation of refreshing functionality.">doRefresh()</a> member function from this class will be used. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> in case fields were updated, <b>false</b> if nothing has changed. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a6da7116040cb3e35912aa4b82a2a66b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da7116040cb3e35912aa4b82a2a66b1">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to extra transport fields. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. Some protocols may use additional values in transport information, such as message version for example. Such values may influence the way message data is being serialized / deserialized. The provided extra transport fields are <b>NOT</b> serialised as part of message payload. Their values are expected to be set by transport layer(s) when such information is read. The transport layers are also responsible to take the updated information from the relevant field and write it when message contents being written. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aa610b5478c6c6926ffc83ed5c91b7954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610b5478c6c6926ffc83ed5c91b7954">&#9670;&nbsp;</a></span>transportFields() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::transportFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const version of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been provided to <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class to specify them. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">hasTransportFields()</a> </dd></dl>

</div>
</div>
<a id="aeb62f73f8c7db3745491ce668171af5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62f73f8c7db3745491ce668171af5f">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check validity of message contents. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a>. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#abeab1fe69accb75656f90e903da24fdc" title="Implementation of polymorphic validity check functionality.">validImpl()</a> function. </p><dl class="section return"><dt>Returns</dt><dd>true for valid contents, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">hasValid()</a> </dd></dl>

</div>
</div>
<a id="abeab1fe69accb75656f90e903da24fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeab1fe69accb75656f90e903da24fdc">&#9670;&nbsp;</a></span>validImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::validImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic validity check functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoValidImpl.html">comms::option::app::NoValidImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br  />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330" title="Default implementation of validity check functionality.">doValid()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330" title="Default implementation of validity check functionality.">comms::MessageBase::doValid()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#a7c16f0064741a8fad3ff76a4b5654bf5">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<a id="a5ad5c5b59d08590aba3b1e97f4e8149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad5c5b59d08590aba3b1e97f4e8149c">&#9670;&nbsp;</a></span>version() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="a472075590eb54b5c660ffc74927f1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472075590eb54b5c660ffc74927f1afc">&#9670;&nbsp;</a></span>version() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">VersionType</a>&amp; <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const access to version information. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option has been provided. </p>

</div>
</div>
<a id="ac861cf1ef73973117f7842e567b05a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac861cf1ef73973117f7842e567b05a13">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write message contents using provided iterator. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> to specify type of the <a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a>. The contents of the message are serialised into buffer. The buffer is external and is maintained by the caller. The provided iterator is advanced. The function invokes virtual <a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf" title="Implementation of polymorphic write functionality.">writeImpl()</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">hasWrite()</a> </dd></dl>

</div>
</div>
<a id="a5ebf1dd77a1c6458392a9001d187ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf1dd77a1c6458392a9001d187ad45">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output area. </p>
<p>Use this function to write data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="abe23293aedd424af62bd5f4d05571b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23293aedd424af62bd5f4d05571b59">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Message.html">comms::Message</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output area. </p>
<p>Use this function to write partial data to the output area using provided iterator. This function requires knowledge about serialisation endian. It exists only if endian type was specified using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a7b58412054c729f562ed1d99fda27fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58412054c729f562ed1d99fda27fbf">&#9670;&nbsp;</a></span>writeImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt; TMessage, TOptions &gt;::writeImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1Message.html#aee6698a41e3975ed6047dac727fe9a0c">WriteIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of polymorphic write functionality. </p>
<p>This function exists if <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option was provided to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class when specifying interface, and <a class="el" href="structcomms_1_1option_1_1app_1_1NoWriteImpl.html">comms::option::app::NoWriteImpl</a> option was <b>NOT</b> used to inhibit the implementation. <br  />
 If <a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> option was used to specify the actual type of the message, and if it contains custom <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality.">doWrite()</a> function, it will be invoked. Otherwise, the invocation of <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468" title="Default implementation of write functionality.">comms::MessageBase::doWrite()</a> will be chosen in case fields were specified using <a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classcomms_1_1Message.html#ae7ae2afc3e5059b9728644dd7034f817">comms::Message&lt; TOptions &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a43c008e2ba360d9dd4917a1c9f80bd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c008e2ba360d9dd4917a1c9f80bd38">&#9670;&nbsp;</a></span>COMMS_MSG_FIELD_ALIAS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELD_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">COMMS_MSG_FIELD_ALIAS_ACCESS</a>(f_, __VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_ALIAS_TYPEDEF(Field_, f_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_ab20effdb4cb453bd6b2eb86246b6ede1"><div class="ttname"><a href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">comms::MessageBase::COMMS_MSG_FIELD_ALIAS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_FIELD_ALIAS_ACCESS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for other member fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:979</div></div>
</div><!-- fragment -->
<p>Generate convinience alias types and access member functions for other member fields. </p>
<p>The <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> macro generates inner types and convenience access member functions for member fields. Sometimes the fields may get renamed or moved to be a member of other fields, like <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> or <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In such case the compilation of the existing client code (that already uses published protocol definition) may fail. To avoid such scenarios and make the transition to newer versions of the protocol easier, the <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> macro can be used to create alias to other fields. For example, let's assume that some message class was defined: like this. </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a2c70987da383935a4cf0ceb5228f497a"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">comms::MessageBase::COMMS_MSG_FIELDS_NAMES</a></div><div class="ttdeci">#define COMMS_MSG_FIELDS_NAMES(...)</div><div class="ttdoc">Provide names for message fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:963</div></div>
</div><!-- fragment --><p> In the future versions of the protocol "name3" was renamed to "newName3". To keep the existing code (that uses "name3" name) compiling it is possible to create an alias access function(s) with: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(name3, newName3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a43c008e2ba360d9dd4917a1c9f80bd38"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">comms::MessageBase::COMMS_MSG_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_MSG_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias types and access member functions for other member fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:1081</div></div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions as well as type defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> Field_name3 = Field_newName3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(field_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(field_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Another example would be a replacing a <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> with <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> in the future version of the protocol. It can happen when the developer decides to split the used storage into multiple values (because the range of the used/valid values allows so). In order to keep the old client code compiling, the access to the replaced field needs to be an alias to the first member of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In this case the usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> will look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(name3, newName3, member1);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> Field_name3 = <span class="keyword">typename</span> Field_newName3::Field_member1;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(field_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(field_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> needs to be used before <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1" title="Generate convinience alias access member functions for other member fields.">COMMS_MSG_FIELD_ALIAS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="ab20effdb4cb453bd6b2eb86246b6ede1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20effdb4cb453bd6b2eb86246b6ede1">&#9670;&nbsp;</a></span>COMMS_MSG_FIELD_ALIAS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELD_ALIAS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;COMMS_DO_ALIAS(field_, f_, __VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias access member functions for other member fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> but requires usage of <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> instead of <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> and does NOT create alias to the field type, only access functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> needs to be used before <a class="el" href="classcomms_1_1MessageBase.html#ab20effdb4cb453bd6b2eb86246b6ede1">COMMS_MSG_FIELD_ALIAS_ACCESS()</a> to define convenience access functions.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> </dd></dl>

</div>
</div>
<a id="a25cd34ed5b338241067433c45d7345ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cd34ed5b338241067433c45d7345ac">&#9670;&nbsp;</a></span>COMMS_MSG_FIELDS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELDS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(COMMS_DEFINE_FIELD_ENUM(__VA_ARGS__)) \</div>
<div class="line">    COMMS_MSG_FIELDS_ACCESS_FUNC { \</div>
<div class="line">        auto&amp; val = <a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*this).fields(); \</div>
<div class="line">        using AllFieldsTuple = <span class="keyword">typename</span> std::decay&lt;decltype(val)&gt;::type; \</div>
<div class="line">        static_assert(std::tuple_size&lt;AllFieldsTuple&gt;::value == FieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for fields tuple&quot;</span>); \</div>
<div class="line">        return val; \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_MSG_FIELDS_ACCESS_CONST_FUNC { \</div>
<div class="line">        auto&amp; val = <a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*this).fields(); \</div>
<div class="line">        using AllFieldsTuple =  <span class="keyword">typename</span> std::decay&lt;decltype(val)&gt;::type; \</div>
<div class="line">        static_assert(std::tuple_size&lt;AllFieldsTuple&gt;::value == FieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for fields tuple&quot;</span>); \</div>
<div class="line">        return val; \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_ACC_FUNC(<a class="code" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a>, <a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>(), __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a108df722c6d6e5016ab6b35b961b43cd"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">comms::MessageBase::AllFields</a></div><div class="ttdeci">FieldsProvidedWithOption AllFields</div><div class="ttdoc">All field classes provided with comms::option::def::FieldsImpl option.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:91</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_af4b8bc4b6db684d0006d2c6c70b1e891"><div class="ttname"><a href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields</a></div><div class="ttdeci">AllFields &amp; fields()</div><div class="ttdoc">Get an access to the fields of the message.</div></div>
<div class="ttc" id="anamespacecomms_html_a0f13fefc26f742c9d1b8715264a116de"><div class="ttname"><a href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a></div><div class="ttdeci">MessageBase&lt; TMessage, TOptions... &gt; &amp; toMessageBase(MessageBase&lt; TMessage, TOptions... &gt; &amp;msg)</div><div class="ttdoc">Upcast type of the message object to comms::MessageBase in order to have access to its internal types...</div><div class="ttdef"><b>Definition:</b> MessageBase.h:776</div></div>
</div><!-- fragment -->
<p>Add convenience access enum and functions to message fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>Field_*</b> types for used fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="a2c70987da383935a4cf0ceb5228f497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c70987da383935a4cf0ceb5228f497a">&#9670;&nbsp;</a></span>COMMS_MSG_FIELDS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_FIELDS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS</a>(__VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_TYPEDEF(<span class="keyword">typename</span> Base::AllFields, Field_, FieldIdx_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a25cd34ed5b338241067433c45d7345ac"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">comms::MessageBase::COMMS_MSG_FIELDS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_FIELDS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to message fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:811</div></div>
</div><!-- fragment -->
<p>Provide names for message fields. </p>
<p>The <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class provides access to its fields via <a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields()</a> member function(s). The fields are bundled into <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and can be accessed using indices with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. For convenience, the fields should be named. The <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a" title="Provide names for message fields.">COMMS_MSG_FIELDS_NAMES()</a> macro does exactly that. <br  />
 As an example, let's assume that custom message uses 3 fields of any types: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Field1 = ... <span class="comment">/* some field definition */</span>;</div>
<div class="line"><span class="keyword">using</span> Field2 = ... <span class="comment">/* some field definition */</span>;</div>
<div class="line"><span class="keyword">using</span> Field3 = ... <span class="comment">/* some field definition */</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> Message1Fields = std::tuple&lt;Field1, Field2, Field3&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        MyInterface,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&gt;,</div>
<div class="line">        ... <span class="comment">/* some other options */</span>&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Base class (re) definition required by COMMS_MSG_FIELDS_NAMES()</span></div>
<div class="line">    <span class="keyword">using</span> Base =</div>
<div class="line">        <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">            MyInterface,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl&lt;Message1Fields&gt;</a>,</div>
<div class="line">            ... <span class="comment">/* some other options */</span>&gt;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for message fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FieldsImpl_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a></div><div class="ttdoc">Option used to specify fields of the message and force implementation of default read,...</div><div class="ttdef"><b>Definition:</b> options.h:234</div></div>
</div><!-- fragment --><p> <b>NOTE</b> that there is a required to have <b>Base</b> member type that specifies base class used. It is needed to be able to access <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">comms::MessageBase::AllFields</a> type definition.</p>
<p>The usage of the <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a" title="Provide names for message fields.">COMMS_MSG_FIELDS_NAMES()</a> macro with the list of the field's names is equivalent to having the following definitions inside the message class </p><div class="fragment"><div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Indices of the fields</span></div>
<div class="line">    <span class="keyword">enum</span> FieldIdx {</div>
<div class="line">        FieldIdx_name1,</div>
<div class="line">        FieldIdx_name2,</div>
<div class="line">        FieldIdx_name3,</div>
<div class="line">        FieldIdx_nameOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    static_assert(std::tuple_size&lt;Base::AllFields&gt;::value == FieldIdx_nameOfValues,</div>
<div class="line">        <span class="stringliteral">&quot;Number of expected fields is incorrect&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name1() -&gt; decltype(std::get&lt;FieldIdx_name1&gt;(Base::fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name1() const -&gt; decltype(std::get&lt;FieldIdx_name1&gt;(Base::<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name1&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name2() -&gt; decltype(std::get&lt;FieldIdx_name2&gt;(Base::fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name2() const -&gt; decltype(std::get&lt;FieldIdx_name2&gt;(Base::<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name2&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name3() -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(Base::fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> field_name3() const -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(Base::<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(Base::fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redefinition of the field types:</span></div>
<div class="line">    <span class="keyword">using</span> Field_name1 = Field1;</div>
<div class="line">    <span class="keyword">using</span> Field_name2 = Field2;</div>
<div class="line">    <span class="keyword">using</span> Field_name3 = Field3;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>name1</b>, <b>name2</b>, and <b>name3</b> have found their way to the following definitions: </p><ul>
<li><b>FieldIdx</b> enum. The names are prefixed with <b>FieldIdx_</b>. The <b>FieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>field_*</b> </li>
<li>Types of fields prefixed with <b>Field_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using <b>FieldIdx</b> enum </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; allFields = msg.fields();</div>
<div class="line">    <span class="keyword">auto</span>&amp; field1 = std::get&lt;Message1::FieldIdx_name1&gt;(allFields);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field2 = std::get&lt;Message1::FieldIdx_name2&gt;(allFields);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field3 = std::get&lt;Message1::FieldIdx_name3&gt;(allFields);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> value1 = field1.value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = field2.value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = field3.value();</div>
<div class="line">}</div>
</div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> value1 = field_name1().value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = field_name2().value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = field_name3().value();</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires (re)definition of the message base class as inner <b>Base</b> member type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac" title="Add convenience access enum and functions to message fields.">COMMS_MSG_FIELDS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/MessageBase.h" </dd></dl>

</div>
</div>
<a id="adfa416afa2a8a77af9c46b42d3034f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa416afa2a8a77af9c46b42d3034f3e">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a>(f_, __VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_ALIAS_TYPEDEF(TransportField_, f_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a33954a8d8c1b0e04175ada3e840bcb83"><div class="ttname"><a href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">comms::Message::COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for extra member transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:724</div></div>
</div><!-- fragment -->
<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro generates alias type as well as convenience access member functions for extra transport fields. Sometimes the fields may get renamed or moved to be a member of other fields, like <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> or <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In such case the compilation of the existing client code (that already uses published protocol definition) may fail. To avoid such scenarios and make the transition to newer versions of the protocol easier, the <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> macro can be used to create alias to other fields. For example, let's assume that some common interface class was defined: like this. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a00912bb201d47afbb0c3e51fff95b338"><div class="ttname"><a href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_NAMES</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES(...)</div><div class="ttdoc">Provide names for extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:707</div></div>
</div><!-- fragment --><p> In the future versions of the protocol "name3" was renamed to "newName3". To keep the existing code (that uses "name3" name) compiling it is possible to create an alias access function(s) with: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1Message_html_adfa416afa2a8a77af9c46b42d3034f3e"><div class="ttname"><a href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">comms::Message::COMMS_MSG_TRANSPORT_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for extra member transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:836</div></div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following type and functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Another example would be a replacing a <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> with <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> in the future version of the protocol. It can happen when the developer decides to split the used storage into multiple values (because the range of the used/valid values allows so). In order to keep the old client code compiling, the access to the replaced field needs to be an alias to the first member of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>. In this case the usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> will look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, newName3);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(name3, newName3, member1);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> in the code above is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField_newName3::Field_Member1;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(transportField_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(transportField_newName3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> transportField_newName3().field_member1();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="Message_8h.html#a6fe96d7272148945853ce61572b3d4b1">COMMS_MSG_TRANSPORT_FIELD_ALIAS_NOTEMPLATE()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a33954a8d8c1b0e04175ada3e840bcb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33954a8d8c1b0e04175ada3e840bcb83">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;COMMS_EXPAND(COMMS_DO_ALIAS(transportField_, f_, __VA_ARGS__))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate convinience alias access member functions for extra member transport fields. </p>
<p>Similar to <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> but requires usage of <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> instead of <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> and does NOT create alias to the field type, only access functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f_</td><td>Alias field name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The macro <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> needs to be used before <a class="el" href="classcomms_1_1Message.html#a33954a8d8c1b0e04175ada3e840bcb83">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS()</a> to define convenience access functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Message_8h.html#ad869d496cd7e59771fb13079970cd102">COMMS_MSG_TRANSPORT_FIELD_ALIAS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="ada784673f02d483a88fcf0c451cb72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada784673f02d483a88fcf0c451cb72bd">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(COMMS_DEFINE_TRANSPORT_FIELD_ENUM(__VA_ARGS__)) \</div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_FUNC { \</div>
<div class="line">        auto&amp; msgBase = <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*<span class="keyword">this</span>); \</div>
<div class="line">        using MsgBase = <span class="keyword">typename</span> std::decay&lt;decltype(msgBase)&gt;::type; \</div>
<div class="line">        static_assert(MsgBase::hasTransportFields(), \</div>
<div class="line">            <span class="stringliteral">&quot;Message interface class doesn&#39;t define extra transport fields.&quot;</span>); \</div>
<div class="line">        using TransportFieldsTuple = <span class="keyword">typename</span> MsgBase::TransportFields; \</div>
<div class="line">        static_assert(std::tuple_size&lt;TransportFieldsTuple&gt;::value == TransportFieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for transport fields tuple&quot;</span>); \</div>
<div class="line">        return msgBase.transportFields(); \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_ACCESS_CONST_FUNC { \</div>
<div class="line">        return <a class="code" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a>(*this).transportFields(); \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_TRANSPORT_FIELD_ACC_FUNC(<a class="code" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a>, <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>(), __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a1a7c7b92d38774a038fbdedb3e0f99cc"><div class="ttname"><a href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">comms::Message::TransportFields</a></div><div class="ttdeci">FieldsProvidedWithOption TransportFields</div><div class="ttdoc">std::tuple of extra fields from transport layers that may affect the way the message fields get seria...</div><div class="ttdef"><b>Definition:</b> Message.h:316</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a6da7116040cb3e35912aa4b82a2a66b1"><div class="ttname"><a href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">comms::Message::transportFields</a></div><div class="ttdeci">TransportFields &amp; transportFields()</div><div class="ttdoc">Get access to extra transport fields.</div></div>
<div class="ttc" id="anamespacecomms_html_a6cfdaf9bcb9780874bac5b1f69601f6d"><div class="ttname"><a href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">comms::toMessage</a></div><div class="ttdeci">Message&lt; TOptions... &gt; &amp; toMessage(Message&lt; TOptions... &gt; &amp;msg)</div><div class="ttdoc">Upcast type of the message object to comms::Message in order to have access to its internal types.</div><div class="ttdef"><b>Definition:</b> Message.h:515</div></div>
</div><!-- fragment -->
<p>Add convenience access enum and functions to extra transport fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>TransportField_*</b> types for used fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a00912bb201d47afbb0c3e51fff95b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00912bb201d47afbb0c3e51fff95b338">&#9670;&nbsp;</a></span>COMMS_MSG_TRANSPORT_FIELDS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(__VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_TYPEDEF(<span class="keyword">typename</span> Base::TransportFields, TransportField_, TransportFieldIdx_, __VA_ARGS__))</div>
<div class="ttc" id="aclasscomms_1_1Message_html_ada784673f02d483a88fcf0c451cb72bd"><div class="ttname"><a href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:566</div></div>
</div><!-- fragment -->
<p>Provide names for extra transport fields. </p>
<p>The <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> class provides access to its extra transport fields via <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1" title="Get access to extra transport fields.">comms::MessageBase::transportFields()</a> member function(s). The fields are bundled into <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and can be accessed using indices with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. For convenience, the fields should be named. The <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro does exactly that. <br  />
 As an example, let's assume that custom message uses 3 fields of any types: </p><div class="fragment"><div class="line"><span class="keyword">using</span> TransportField1 = ...;</div>
<div class="line"><span class="keyword">using</span> TransportField2 = ...;</div>
<div class="line"><span class="keyword">using</span> TransportField3 = ...;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::tuple&lt;TransportField1, TransportField2, TransportField3&gt; MyExtraTransportFields</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        ...</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt; &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div>
<div class="line">    <span class="comment">// required by the COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(name1, name2, name3);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of the <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338" title="Provide names for extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro with the list of the extra transport field's names is equivalent to having the following definitions inside the message class </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInterface : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> TransportFieldIdx {</div>
<div class="line">        TransportFieldIdx_name1,</div>
<div class="line">        TransportFieldIdx_name2,</div>
<div class="line">        TransportFieldIdx_name3,</div>
<div class="line">        TransportFieldIdx_nameOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    static_assert(std::tuple_size&lt;Base::TransportFields&gt;::value == TransportFieldIdx_nameOfValues,</div>
<div class="line">        <span class="stringliteral">&quot;Number of expected transport fields is incorrect&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; transport field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name1() -&gt; decltype(std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name1&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name1() const -&gt; decltype(std::get&lt;TransportFieldIdx_name1&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name1&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name2() -&gt; decltype(std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name2&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name2() const -&gt; decltype(std::get&lt;TransportFieldIdx_name2&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name2&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() -&gt; decltype(std::get&lt;TransportFieldIdx_name3&gt;(Base::transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_name3&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;name3&quot; field.</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_name3() const -&gt; decltype(std::get&lt;FieldIdx_name3&gt;(Base::<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_name3&gt;(Base::transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redefinition of the transport field types:</span></div>
<div class="line">    <span class="keyword">using</span> TransportField_name1 = TransportField1;</div>
<div class="line">    <span class="keyword">using</span> TransportField_name2 = TransportField2;</div>
<div class="line">    <span class="keyword">using</span> TransportField_name3 = TransportField3;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>name1</b>, <b>name2</b>, and <b>name3</b> have found their way to the following definitions: </p><ul>
<li><b>TransportFieldIdx</b> enum. The names are prefixed with <b>TransportFieldIdx_</b>. The <b>TransportFieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>transportField_*</b> </li>
<li>Types of fields prefixed with <b>TransportField_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using <b>TransportFieldIdx</b> enum </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; <a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a> = msg.transportFields();</div>
<div class="line">    <span class="keyword">auto</span>&amp; field1 = std::get&lt;Message1::TransportFieldIdx_name1&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field2 = std::get&lt;Message1::TransportFieldIdx_name2&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line">    <span class="keyword">auto</span>&amp; field3 = std::get&lt;Message1::TransportFieldIdx_name3&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> value1 = field1.value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = field2.value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = field3.value();</div>
<div class="line">}</div>
</div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Message1&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> value1 = transportField_name1().value();</div>
<div class="line">    <span class="keyword">auto</span> value2 = transportField_name2().value();</div>
<div class="line">    <span class="keyword">auto</span> value3 = transportField_name3().value();</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires (re)definition of the message base class as inner <b>Base</b> member type. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd" title="Add convenience access enum and functions to extra transport fields.">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/Message.h" </dd></dl>

</div>
</div>
<a id="a05ecd276ccd033225ecfdc4909f2d211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ecd276ccd033225ecfdc4909f2d211">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage1 , typename TMessage2 , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object inequality comparison operator. </p>
<p>Messages are considered not equal if any their fields are considered inequal. </p>

</div>
</div>
<a id="ad59f49a279a7f24e25156bacfd3a9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59f49a279a7f24e25156bacfd3a9ccc">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage1 , typename TMessage2 , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage1, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage2, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object equality comparison operator. </p>
<p>Messages are considered equal if all their fields are considered equal </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/<a class="el" href="MessageBase_8h_source.html">MessageBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
