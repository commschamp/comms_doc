<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::MsgFactory&lt; TMsgBase, TAllMessages, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="classcomms_1_1MsgFactory.html">MsgFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcomms_1_1MsgFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::MsgFactory&lt; TMsgBase, TAllMessages, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="MsgFactory_8h_source.html">comms/MsgFactory.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TMsgBase, typename TAllMessages, typename... TOptions&gt;<br />
class comms::MsgFactory&lt; TMsgBase, TAllMessages, TOptions &gt;</h3>

<p><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> factory class. </p>
<p>It is responsible to create message objects given the ID of the message. This class <b>DOESN'T</b> use dynamic memory allocation to store its internal data structures, hence can be used in any bare-metal and other embedded environment.<br  />
 The types of all messages provided in <b>TAllMessages</b> are analysed at compile time and best "id to message object" mapping strategy is chosen, unless the "dispatch" type forcing options are used (see description below). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsgBase</td><td>Common base class for all the messages, smart pointer to this type is returned when allocation of specify message is requested. </td></tr>
    <tr><td class="paramname">TAllMessages</td><td>All custom message types, that this factory is capable of creating, bundled in std::tuple&lt;&gt;. The message types must be sorted based on their IDs. Different variants of the same message (reporting same ID, but implemented as different classes) are also supported. However they must follow one another in this std::tuple, i.e. be sorted. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Zero or more options. The supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> - Option to specify that custom message objects are <b>NOT</b> allocated using dynamic memory, instead an uninitialised area of memory in private members is used to contain any type of custom message (provided with TAllMessages template parameter) and placement "new" operator is used to initialise requested message in this area. The allocated message objects are returned from <a class="el" href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3" title="Create message object given the ID of the message.">createMsg()</a> function wrapped in the smart pointer (variant of std::unique_ptr). If <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option is used, then the smart pointer definition contains custom deleter, which will explicitly invoke destructor of the message when the smart pointer is out of scope. It means that it is <b>NOT</b> possible to create new message with this factory if previously allocated one wasn't destructed yet. If <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option is NOT used, than the requested message objects are allocated using dynamic memory and returned wrapped in std::unique_ptr without custom deleter. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> - Option used to allow allocation of <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>. If such option is provided, the <a class="el" href="classcomms_1_1MsgFactory.html#a8c818022da2e8efbf3fd715951cc5c1b" title="Allocate and initialise comms::GenericMessage object.">createGenericMsg()</a> member function will be able to allocate <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> object. <b>NOTE</b>, that the base class of <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> type (first template parameter) must be equal to <b>TMsgBase</b> (first template parameter) of <b>this</b> class. </li>
<li><a class="el" href="namespacecomms_1_1option_1_1app.html#acef1e5bc54eacc4fd744cde7bcb7f615">comms::option::app::ForceDispatchPolymorphic</a>, <a class="el" href="namespacecomms_1_1option_1_1app.html#ab065559cdb35c6a86bbb2224d3239d13">comms::option::app::ForceDispatchStaticBinSearch</a>, or <a class="el" href="namespacecomms_1_1option_1_1app.html#a9d319ff4279bc91c590741551898e744">comms::option::app::ForceDispatchLinearSwitch</a> - Force a particular dispatch way when creating message object given the numeric ID (see <a class="el" href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3">comms::MsgFactory::createMsg()</a>). The dispatch methods are properly described in <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. If none of these options are provided, then the <a class="el" href="classcomms_1_1MsgFactory.html" title="Message factory class.">MsgFactory</a> used a default way, which is equivalent to calling <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">comms::dispatchMsgType()</a> (see also <a class="el" href="page_dispatch.html#page_dispatch_message_type_default">Default Way to Dispatch</a>). To inquire what actual dispatch type is used, please use one of the following constexpr member functions: <a class="el" href="classcomms_1_1MsgFactory.html#ac18168c1dad7c06c2cee17e04e6bd611">comms::MsgFactory::isDispatchPolymorphic()</a>, <a class="el" href="classcomms_1_1MsgFactory.html#a44b9375c3b500011e2a4045b1e84ba16">comms::MsgFactory::isDispatchStaticBinSearch()</a>, and <a class="el" href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">comms::MsgFactory::isDispatchLinearSwitch()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TMsgBase is a base class for all the messages in TAllMessages. </dd>
<dd>
<a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> type is TAllMessages must be sorted based on their IDs. </dd>
<dd>
If <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option is provided, only one custom message can be allocated. The next one can be allocated only after previous message has been destructed. </dd></dl>
</div>
<p>Inherits comms::details::MsgFactoryBase&lt; TMsgBase, TAllMessages, TOptions... &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9bfccfddae66f917b11dc8ca05128402"><td class="memItemLeft" align="right" valign="top"><a id="a9bfccfddae66f917b11dc8ca05128402"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402">AllMessages</a> = typename Base::AllMessages</td></tr>
<tr class="memdesc:a9bfccfddae66f917b11dc8ca05128402"><td class="mdescLeft">&#160;</td><td class="mdescRight">All messages provided as template parameter to this class. <br /></td></tr>
<tr class="separator:a9bfccfddae66f917b11dc8ca05128402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30eb5aaaeec995982e2a2fb9bfe814fe"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fe">CreateFailureReason</a> { <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fea6adf97f83acf6453d4a6a4b1070f3754">None</a>
, <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fead17cc4f1cee6075d7b5a9d48873d6041">InvalidId</a>
, <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fea0d8eeb3fc020c6669c92b4ff0e2e27ff">AllocFailure</a>
, <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fea0bb4f6beda4f34c57166e6c1e14eb6f7">NumOfValues</a>
 }</td></tr>
<tr class="separator:a30eb5aaaeec995982e2a2fb9bfe814fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9752974bea52f5c1d0da9baccca19c08"><td class="memItemLeft" align="right" valign="top"><a id="a9752974bea52f5c1d0da9baccca19c08"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a9752974bea52f5c1d0da9baccca19c08">Message</a> = typename Base::Message</td></tr>
<tr class="memdesc:a9752974bea52f5c1d0da9baccca19c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the common base class of all the messages. <br /></td></tr>
<tr class="separator:a9752974bea52f5c1d0da9baccca19c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfb76e2cf3661edb7741d0a926d2da0"><td class="memItemLeft" align="right" valign="top"><a id="aabfb76e2cf3661edb7741d0a926d2da0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a> = typename Base::MsgIdParamType</td></tr>
<tr class="memdesc:aabfb76e2cf3661edb7741d0a926d2da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message ID when passed as a parameter. <br /></td></tr>
<tr class="separator:aabfb76e2cf3661edb7741d0a926d2da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1005da310eff2117edb16b92fd2dbb88"><td class="memItemLeft" align="right" valign="top"><a id="a1005da310eff2117edb16b92fd2dbb88"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a1005da310eff2117edb16b92fd2dbb88">MsgIdType</a> = typename Base::MsgIdType</td></tr>
<tr class="memdesc:a1005da310eff2117edb16b92fd2dbb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the message ID. <br /></td></tr>
<tr class="separator:a1005da310eff2117edb16b92fd2dbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa8fb1cd206c2fd25a97bd0a4e57cd7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a> = typename Base::MsgPtr</td></tr>
<tr class="memdesc:adfa8fb1cd206c2fd25a97bd0a4e57cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer to <a class="el" href="classcomms_1_1Message.html">Message</a> which holds allocated message object.  <a href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">More...</a><br /></td></tr>
<tr class="separator:adfa8fb1cd206c2fd25a97bd0a4e57cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d36f974687e689c1bf3e3a0339eea"><td class="memItemLeft" align="right" valign="top"><a id="a610d36f974687e689c1bf3e3a0339eea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a610d36f974687e689c1bf3e3a0339eea">ParsedOptions</a> = typename Base::ParsedOptions</td></tr>
<tr class="memdesc:a610d36f974687e689c1bf3e3a0339eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options. <br /></td></tr>
<tr class="separator:a610d36f974687e689c1bf3e3a0339eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a131a0770e85ceafb405fcf5cbfcb06be"><td class="memItemLeft" align="right" valign="top"><a id="a131a0770e85ceafb405fcf5cbfcb06be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a131a0770e85ceafb405fcf5cbfcb06be">canAllocate</a> () const</td></tr>
<tr class="memdesc:a131a0770e85ceafb405fcf5cbfcb06be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inquiry whether allocation is possible. <br /></td></tr>
<tr class="separator:a131a0770e85ceafb405fcf5cbfcb06be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c818022da2e8efbf3fd715951cc5c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a8c818022da2e8efbf3fd715951cc5c1b">createGenericMsg</a> (<a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a> id, unsigned idx=0U) const</td></tr>
<tr class="memdesc:a8c818022da2e8efbf3fd715951cc5c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialise <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> object.  <a href="classcomms_1_1MsgFactory.html#a8c818022da2e8efbf3fd715951cc5c1b">More...</a><br /></td></tr>
<tr class="separator:a8c818022da2e8efbf3fd715951cc5c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1ad877b2b4c26ed0e64675e0b245d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3">createMsg</a> (<a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a> id, unsigned idx=0U, <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fe">CreateFailureReason</a> *reason=nullptr) const</td></tr>
<tr class="memdesc:a5b1ad877b2b4c26ed0e64675e0b245d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID of the message.  <a href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3">More...</a><br /></td></tr>
<tr class="separator:a5b1ad877b2b4c26ed0e64675e0b245d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b48fb5d596981572ccbaff84cc7d1af"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a4b48fb5d596981572ccbaff84cc7d1af">msgCount</a> (<a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a> id) const</td></tr>
<tr class="memdesc:a4b48fb5d596981572ccbaff84cc7d1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of message types from <a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402">AllMessages</a>, that have the specified ID.  <a href="classcomms_1_1MsgFactory.html#a4b48fb5d596981572ccbaff84cc7d1af">More...</a><br /></td></tr>
<tr class="separator:a4b48fb5d596981572ccbaff84cc7d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a845efd38ef0e7ecf3069c7912f44032f"><td class="memItemLeft" align="right" valign="top"><a id="a845efd38ef0e7ecf3069c7912f44032f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a845efd38ef0e7ecf3069c7912f44032f">hasUniqueIds</a> ()</td></tr>
<tr class="memdesc:a845efd38ef0e7ecf3069c7912f44032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether all the message classes in the <b>TAllMessages</b> bundle have unique IDs. <br /></td></tr>
<tr class="separator:a845efd38ef0e7ecf3069c7912f44032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583aa46c2595202c6e281bb4960e6664"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">isDispatchLinearSwitch</a> ()</td></tr>
<tr class="memdesc:a583aa46c2595202c6e281bb4960e6664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether linear switch dispatch is generated internally to map message ID to actual type.  <a href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">More...</a><br /></td></tr>
<tr class="separator:a583aa46c2595202c6e281bb4960e6664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18168c1dad7c06c2cee17e04e6bd611"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#ac18168c1dad7c06c2cee17e04e6bd611">isDispatchPolymorphic</a> ()</td></tr>
<tr class="memdesc:ac18168c1dad7c06c2cee17e04e6bd611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether polymorphic dispatch tables are generated internally to map message ID to actual type.  <a href="classcomms_1_1MsgFactory.html#ac18168c1dad7c06c2cee17e04e6bd611">More...</a><br /></td></tr>
<tr class="separator:ac18168c1dad7c06c2cee17e04e6bd611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b9375c3b500011e2a4045b1e84ba16"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html#a44b9375c3b500011e2a4045b1e84ba16">isDispatchStaticBinSearch</a> ()</td></tr>
<tr class="memdesc:a44b9375c3b500011e2a4045b1e84ba16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether static binary search dispatch is generated internally to map message ID to actual type.  <a href="classcomms_1_1MsgFactory.html#a44b9375c3b500011e2a4045b1e84ba16">More...</a><br /></td></tr>
<tr class="separator:a44b9375c3b500011e2a4045b1e84ba16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="adfa8fb1cd206c2fd25a97bd0a4e57cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa8fb1cd206c2fd25a97bd0a4e57cd7">&#9670;&nbsp;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::<a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a> =  typename Base::MsgPtr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer to <a class="el" href="classcomms_1_1Message.html">Message</a> which holds allocated message object. </p>
<p>It is a variant of std::unique_ptr, based on whether <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option was used. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a30eb5aaaeec995982e2a2fb9bfe814fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30eb5aaaeec995982e2a2fb9bfe814fe">&#9670;&nbsp;</a></span>CreateFailureReason</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fe">comms::MsgFactory::CreateFailureReason</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30eb5aaaeec995982e2a2fb9bfe814fea6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No reason. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30eb5aaaeec995982e2a2fb9bfe814fead17cc4f1cee6075d7b5a9d48873d6041"></a>InvalidId&#160;</td><td class="fielddoc"><p>Invalid message id. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30eb5aaaeec995982e2a2fb9bfe814fea0d8eeb3fc020c6669c92b4ff0e2e27ff"></a>AllocFailure&#160;</td><td class="fielddoc"><p>Allocation of the object has failied. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30eb5aaaeec995982e2a2fb9bfe814fea0bb4f6beda4f34c57166e6c1e14eb6f7"></a>NumOfValues&#160;</td><td class="fielddoc"><p>Number of available values, must be last. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c818022da2e8efbf3fd715951cc5c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c818022da2e8efbf3fd715951cc5c1b">&#9670;&nbsp;</a></span>createGenericMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a> <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::createGenericMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0U</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialise <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> object. </p>
<p>If <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option hasn't been provided, this function will return empty <b>MsgPtr</b> pointer. Otherwise the relevant allocator will be used to allocate <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message, will be passed as a parameter to the constructor of the <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> class </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>Relative index (or offset) of the message with the same ID. In case protocol implementation contains multiple distinct message types that report same ID value, it must be possible to choose the relative index of such message from the first message type reporting the same ID. This parameter provides such an ability. However, most protocols will implement single message class for single ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b1ad877b2b4c26ed0e64675e0b245d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1ad877b2b4c26ed0e64675e0b245d3">&#9670;&nbsp;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgPtr</a> <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0U</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1MsgFactory.html#a30eb5aaaeec995982e2a2fb9bfe814fe">CreateFailureReason</a> *&#160;</td>
          <td class="paramname"><em>reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create message object given the ID of the message. </p>
<p>The id to mapping is performed using the chosen (or default) <b>dispatch</b> policy described in the class options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>Relative index (or offset) of the message with the same ID. In case protocol implementation contains multiple distinct message types that report same ID value, it must be possible to choose the relative index of such message from the first message type reporting the same ID. This parameter provides such an ability. However, most protocols will implement single message class for single ID. For such implementations, use default value of this parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reason</td><td>Failure reason in case creation has failed. May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to <a class="el" href="classcomms_1_1Message.html">Message</a> type, which is a common base class of all the messages (provided as first template parameter to this class). If <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option was used and previously allocated message wasn't de-allocated yet, the empty (null) pointer will be returned. </dd></dl>

</div>
</div>
<a id="a583aa46c2595202c6e281bb4960e6664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583aa46c2595202c6e281bb4960e6664">&#9670;&nbsp;</a></span>isDispatchLinearSwitch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::isDispatchLinearSwitch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry whether linear switch dispatch is generated internally to map message ID to actual type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#a44b9375c3b500011e2a4045b1e84ba16">comms::MsgFactory::isDispatchStaticBinSearch()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">comms::MsgFactory::isDispatchLinearSwitch()</a> </dd></dl>

</div>
</div>
<a id="ac18168c1dad7c06c2cee17e04e6bd611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18168c1dad7c06c2cee17e04e6bd611">&#9670;&nbsp;</a></span>isDispatchPolymorphic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::isDispatchPolymorphic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry whether polymorphic dispatch tables are generated internally to map message ID to actual type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#a44b9375c3b500011e2a4045b1e84ba16">comms::MsgFactory::isDispatchStaticBinSearch()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">comms::MsgFactory::isDispatchLinearSwitch()</a> </dd></dl>

</div>
</div>
<a id="a44b9375c3b500011e2a4045b1e84ba16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b9375c3b500011e2a4045b1e84ba16">&#9670;&nbsp;</a></span>isDispatchStaticBinSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::isDispatchStaticBinSearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry whether static binary search dispatch is generated internally to map message ID to actual type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#ac18168c1dad7c06c2cee17e04e6bd611">comms::MsgFactory::isDispatchPolymorphic()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1MsgFactory.html#a583aa46c2595202c6e281bb4960e6664">comms::MsgFactory::isDispatchLinearSwitch()</a> </dd></dl>

</div>
</div>
<a id="a4b48fb5d596981572ccbaff84cc7d1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b48fb5d596981572ccbaff84cc7d1af">&#9670;&nbsp;</a></span>msgCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsgBase , typename TAllMessages , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>&lt; TMsgBase, TAllMessages, TOptions &gt;::msgCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1MsgFactory.html#aabfb76e2cf3661edb7741d0a926d2da0">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of message types from <a class="el" href="classcomms_1_1MsgFactory.html#a9bfccfddae66f917b11dc8ca05128402">AllMessages</a>, that have the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of message classes that report same ID. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/<a class="el" href="MsgFactory_8h_source.html">MsgFactory.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
