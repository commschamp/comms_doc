<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::field::ArrayList&lt; TFieldBase, TElement, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1field.html">field</a></li><li class="navelem"><a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classcomms_1_1field_1_1ArrayList-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comms::field::ArrayList&lt; TFieldBase, TElement, TOptions &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ArrayList_8h_source.html">comms/field/ArrayList.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TFieldBase, typename TElement, typename... TOptions&gt;<br />
class comms::field::ArrayList&lt; TFieldBase, TElement, TOptions &gt;</div><p><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that represents a sequential collection of fields. </p>
<p>By default uses <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>, for internal storage, unless <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> option is used, which forces usage of <a class="el" href="classcomms_1_1util_1_1StaticVector.html" title="Replacement to std::vector when no dynamic memory allocation is allowed.">comms::util::StaticVector</a> instead. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFieldBase</td><td>Base class for this field, expected to be a variant of <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">comms::Field</a>. </td></tr>
    <tr><td class="paramname">TElement</td><td>Element of the collection, can be either basic integral value (such as std::uint8_t) or any other field from <a class="el" href="namespacecomms_1_1field.html" title="Namespace that contains definitions of all message fields.">comms::field</a> namespace.<br  />
 For example: <div class="fragment"><div class="line"><span class="keyword">using </span>MyFieldBase = <a class="code hl_class" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>RawDataSeqField =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::uint8_t</div>
<div class="line">    &gt;;</div>
<div class="line"><span class="keyword">using </span>CollectionOfBundlesField =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::field::Bundle&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            std::tuple&lt;</div>
<div class="line">                <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a></div>
<div class="line">                <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a></div>
<div class="line">                <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a></div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition</b> Field.h:33</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1ArrayList_html"><div class="ttname"><a href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a></div><div class="ttdoc">Field that represents a sequential collection of fields.</div><div class="ttdef"><b>Definition</b> ArrayList.h:195</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a></div><div class="ttdoc">Field that represent integral value.</div><div class="ttdef"><b>Definition</b> IntValue.h:75</div></div>
</div><!-- fragment --> </td></tr>
    <tr><td class="paramname">TOptions</td><td>Zero or more options that modify/refine default behaviour of the field.<br  />
 Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FieldType.html">comms::option::def::FieldType</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FixedValue.html">comms::option::def::FixedValue</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRead.html">comms::option::def::HasCustomRead</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1IgnoreInvalid.html">comms::option::def::IgnoreInvalid</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceLengthForcingEnabled.html">comms::option::def::SequenceLengthForcingEnabled</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1CustomStorageType.html">comms::option::app::CustomStorageType</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a> (valid only if TElement is integral type of 1 byte size. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::field::ArrayList&lt; TFieldBase, TElement, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1field_1_1ArrayList.png" usemap="#comms::field::ArrayList_3C_20TFieldBase_2C_20TElement_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::field::ArrayList_3C_20TFieldBase_2C_20TElement_2C_20TOptions_20_3E_map" name="comms::field::ArrayList_3C_20TFieldBase_2C_20TElement_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1Field.html" title="Base class to all the field classes." alt="comms::Field&lt; TOptions &gt;" shape="rect" coords="0,0,344,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeee92513d1af83785461e53891434b42" id="r_aeee92513d1af83785461e53891434b42"><td class="memItemLeft" align="right" valign="top"><a id="aeee92513d1af83785461e53891434b42" name="aeee92513d1af83785461e53891434b42"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CommsTag</b> = typename BaseImpl::CommsTag</td></tr>
<tr class="memdesc:aeee92513d1af83785461e53891434b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating type of the field. <br /></td></tr>
<tr class="separator:aeee92513d1af83785461e53891434b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c59e1e23b4dc83d698b68e6d490a6a" id="r_a11c59e1e23b4dc83d698b68e6d490a6a"><td class="memItemLeft" align="right" valign="top"><a id="a11c59e1e23b4dc83d698b68e6d490a6a" name="a11c59e1e23b4dc83d698b68e6d490a6a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ElementType</b> = typename BaseImpl::ElementType</td></tr>
<tr class="memdesc:a11c59e1e23b4dc83d698b68e6d490a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the element. <br /></td></tr>
<tr class="separator:a11c59e1e23b4dc83d698b68e6d490a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77cc166bef350024ea587f01efb39eb" id="r_ac77cc166bef350024ea587f01efb39eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ac77cc166bef350024ea587f01efb39eb">ElemFixedSerLengthFieldPrefix</a> = typename ParsedOptions::SequenceElemFixedSerLengthFieldPrefix</td></tr>
<tr class="memdesc:ac77cc166bef350024ea587f01efb39eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of element's fixed length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a>.  <br /></td></tr>
<tr class="separator:ac77cc166bef350024ea587f01efb39eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12cdd6cd03fb0dff0cef144ba526b6" id="r_a9b12cdd6cd03fb0dff0cef144ba526b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a9b12cdd6cd03fb0dff0cef144ba526b6">ElemSerLengthFieldPrefix</a> = typename ParsedOptions::SequenceElemSerLengthFieldPrefix</td></tr>
<tr class="memdesc:a9b12cdd6cd03fb0dff0cef144ba526b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of element's length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a>.  <br /></td></tr>
<tr class="separator:a9b12cdd6cd03fb0dff0cef144ba526b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550728194d30747c2f663be1af9bcbe5" id="r_a550728194d30747c2f663be1af9bcbe5"><td class="memItemLeft" align="right" valign="top"><a id="a550728194d30747c2f663be1af9bcbe5" name="a550728194d30747c2f663be1af9bcbe5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Endian</b> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a550728194d30747c2f663be1af9bcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endian used for serialisation. <br /></td></tr>
<tr class="separator:a550728194d30747c2f663be1af9bcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b0c08d9a523174bbced80173d3feed" id="r_ac7b0c08d9a523174bbced80173d3feed"><td class="memItemLeft" align="right" valign="top"><a id="ac7b0c08d9a523174bbced80173d3feed" name="ac7b0c08d9a523174bbced80173d3feed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FieldBase</b> = TFieldBase</td></tr>
<tr class="memdesc:ac7b0c08d9a523174bbced80173d3feed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class provided in the first template parameter. <br /></td></tr>
<tr class="separator:ac7b0c08d9a523174bbced80173d3feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc572a08258d685fb036df21007bb46" id="r_abbc572a08258d685fb036df21007bb46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#abbc572a08258d685fb036df21007bb46">FieldType</a> = typename ParsedOptions::FieldType</td></tr>
<tr class="memdesc:abbc572a08258d685fb036df21007bb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of actual extending field specified via <a class="el" href="structcomms_1_1option_1_1def_1_1FieldType.html">comms::option::def::FieldType</a>.  <br /></td></tr>
<tr class="separator:abbc572a08258d685fb036df21007bb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f9bab464d0a44b122b3f53af029dde" id="r_ae8f9bab464d0a44b122b3f53af029dde"><td class="memItemLeft" align="right" valign="top"><a id="ae8f9bab464d0a44b122b3f53af029dde" name="ae8f9bab464d0a44b122b3f53af029dde"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParsedOptions</b> = details::OptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:ae8f9bab464d0a44b122b3f53af029dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:ae8f9bab464d0a44b122b3f53af029dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6904af096ad9d12fb674205dff48eca" id="r_ac6904af096ad9d12fb674205dff48eca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ac6904af096ad9d12fb674205dff48eca">SerLengthFieldPrefix</a> = typename ParsedOptions::SequenceSerLengthFieldPrefix</td></tr>
<tr class="memdesc:ac6904af096ad9d12fb674205dff48eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a>.  <br /></td></tr>
<tr class="separator:ac6904af096ad9d12fb674205dff48eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f342e8225cf41b961c5f594c4dfdf60" id="r_a8f342e8225cf41b961c5f594c4dfdf60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a8f342e8225cf41b961c5f594c4dfdf60">SizeFieldPrefix</a> = typename ParsedOptions::SequenceSizeFieldPrefix</td></tr>
<tr class="memdesc:a8f342e8225cf41b961c5f594c4dfdf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of size field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>.  <br /></td></tr>
<tr class="separator:a8f342e8225cf41b961c5f594c4dfdf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef376152c7b332c70d2841d7ee292cb6" id="r_aef376152c7b332c70d2841d7ee292cb6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#aef376152c7b332c70d2841d7ee292cb6">TerminationFieldSuffix</a> = typename ParsedOptions::SequenceTerminationFieldSuffix</td></tr>
<tr class="memdesc:aef376152c7b332c70d2841d7ee292cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of termination field suffix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a>.  <br /></td></tr>
<tr class="separator:aef376152c7b332c70d2841d7ee292cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3e78d50542be7221e39571bfd2cdcd" id="r_a3d3e78d50542be7221e39571bfd2cdcd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a3d3e78d50542be7221e39571bfd2cdcd">TrailingFieldSuffix</a> = typename ParsedOptions::SequenceTrailingFieldSuffix</td></tr>
<tr class="memdesc:a3d3e78d50542be7221e39571bfd2cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of trailing field suffix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a>.  <br /></td></tr>
<tr class="separator:a3d3e78d50542be7221e39571bfd2cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e82da497de6abd350b0a3fb86100e5" id="r_aa8e82da497de6abd350b0a3fb86100e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> = typename BaseImpl::ValueType</td></tr>
<tr class="memdesc:aa8e82da497de6abd350b0a3fb86100e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of underlying value.  <br /></td></tr>
<tr class="separator:aa8e82da497de6abd350b0a3fb86100e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123505d87f81499a9b3a2e32a9948175" id="r_a123505d87f81499a9b3a2e32a9948175"><td class="memItemLeft" align="right" valign="top"><a id="a123505d87f81499a9b3a2e32a9948175" name="a123505d87f81499a9b3a2e32a9948175"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VersionType</b> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:a123505d87f81499a9b3a2e32a9948175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version type. <br /></td></tr>
<tr class="separator:a123505d87f81499a9b3a2e32a9948175"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af3ad69987714384cf3fcd8020c67fce1" id="r_af3ad69987714384cf3fcd8020c67fce1"><td class="memItemLeft" align="right" valign="top"><a id="af3ad69987714384cf3fcd8020c67fce1" name="af3ad69987714384cf3fcd8020c67fce1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> ()=default</td></tr>
<tr class="memdesc:af3ad69987714384cf3fcd8020c67fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af3ad69987714384cf3fcd8020c67fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade41adcfbc72abe92b862bb6504c57a0" id="r_ade41adcfbc72abe92b862bb6504c57a0"><td class="memItemLeft" align="right" valign="top"><a id="ade41adcfbc72abe92b862bb6504c57a0" name="ade41adcfbc72abe92b862bb6504c57a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:ade41adcfbc72abe92b862bb6504c57a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:ade41adcfbc72abe92b862bb6504c57a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b41d4b403a4a077ab80a5a3fe3cdda8" id="r_a9b41d4b403a4a077ab80a5a3fe3cdda8"><td class="memItemLeft" align="right" valign="top"><a id="a9b41d4b403a4a077ab80a5a3fe3cdda8" name="a9b41d4b403a4a077ab80a5a3fe3cdda8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;)=default</td></tr>
<tr class="memdesc:a9b41d4b403a4a077ab80a5a3fe3cdda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a9b41d4b403a4a077ab80a5a3fe3cdda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aef27831dd2c69206c96fad2ebd484" id="r_a89aef27831dd2c69206c96fad2ebd484"><td class="memItemLeft" align="right" valign="top"><a id="a89aef27831dd2c69206c96fad2ebd484" name="a89aef27831dd2c69206c96fad2ebd484"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:a89aef27831dd2c69206c96fad2ebd484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value constructor. <br /></td></tr>
<tr class="separator:a89aef27831dd2c69206c96fad2ebd484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77ff7605c3da77b919772b00882317a" id="r_af77ff7605c3da77b919772b00882317a"><td class="memItemLeft" align="right" valign="top"><a id="af77ff7605c3da77b919772b00882317a" name="af77ff7605c3da77b919772b00882317a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayList</b> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:af77ff7605c3da77b919772b00882317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value constructor. <br /></td></tr>
<tr class="separator:af77ff7605c3da77b919772b00882317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d7ecf0e33726a0f1362cce4e53f219" id="r_aa0d7ecf0e33726a0f1362cce4e53f219"><td class="memItemLeft" align="right" valign="top"><a id="aa0d7ecf0e33726a0f1362cce4e53f219" name="aa0d7ecf0e33726a0f1362cce4e53f219"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~ArrayList</b> () noexcept=default</td></tr>
<tr class="memdesc:aa0d7ecf0e33726a0f1362cce4e53f219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aa0d7ecf0e33726a0f1362cce4e53f219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9a02767dd19138db4611aec19646f1" id="r_ade9a02767dd19138db4611aec19646f1"><td class="memItemLeft" align="right" valign="top"><a id="ade9a02767dd19138db4611aec19646f1" name="ade9a02767dd19138db4611aec19646f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canWrite</b> () const</td></tr>
<tr class="memdesc:ade9a02767dd19138db4611aec19646f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of whether the field has a consistent value for writing. <br /></td></tr>
<tr class="separator:ade9a02767dd19138db4611aec19646f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05c1e12acff6d7495d743ba812b901c" id="r_ae05c1e12acff6d7495d743ba812b901c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ae05c1e12acff6d7495d743ba812b901c">clearReadElemCount</a> ()</td></tr>
<tr class="memdesc:ae05c1e12acff6d7495d743ba812b901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear forcing of the number of elements that must be read in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation.  <br /></td></tr>
<tr class="separator:ae05c1e12acff6d7495d743ba812b901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8e803cfa8f3d995d1e1816df59c93b" id="r_a1c8e803cfa8f3d995d1e1816df59c93b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a1c8e803cfa8f3d995d1e1816df59c93b">clearReadElemLengthForcing</a> ()</td></tr>
<tr class="memdesc:a1c8e803cfa8f3d995d1e1816df59c93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear forcing the serialisation length of the single element.  <br /></td></tr>
<tr class="separator:a1c8e803cfa8f3d995d1e1816df59c93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571e0dde7a7fd82c9c1ef2b096e10dc1" id="r_a571e0dde7a7fd82c9c1ef2b096e10dc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a571e0dde7a7fd82c9c1ef2b096e10dc1">clearReadLengthForcing</a> ()</td></tr>
<tr class="memdesc:a571e0dde7a7fd82c9c1ef2b096e10dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear forcing of the available length in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation.  <br /></td></tr>
<tr class="separator:a571e0dde7a7fd82c9c1ef2b096e10dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94688b8f24a97e863dbfd6b537410c43" id="r_a94688b8f24a97e863dbfd6b537410c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a94688b8f24a97e863dbfd6b537410c43">forceReadElemCount</a> (std::size_t count)</td></tr>
<tr class="memdesc:a94688b8f24a97e863dbfd6b537410c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force number of elements that must be read in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation.  <br /></td></tr>
<tr class="separator:a94688b8f24a97e863dbfd6b537410c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc0795d98464b2825ff25815a68f3fb" id="r_a9cc0795d98464b2825ff25815a68f3fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a9cc0795d98464b2825ff25815a68f3fb">forceReadElemLength</a> (std::size_t count)</td></tr>
<tr class="memdesc:a9cc0795d98464b2825ff25815a68f3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force serialisation length of a single element.  <br /></td></tr>
<tr class="separator:a9cc0795d98464b2825ff25815a68f3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae388a59eda51483a88ff7e791ec8ebff" id="r_ae388a59eda51483a88ff7e791ec8ebff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ae388a59eda51483a88ff7e791ec8ebff">forceReadLength</a> (std::size_t count)</td></tr>
<tr class="memdesc:ae388a59eda51483a88ff7e791ec8ebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force available length for the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation.  <br /></td></tr>
<tr class="separator:ae388a59eda51483a88ff7e791ec8ebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4066db0a3a4539719f61e67bf76e2a" id="r_abd4066db0a3a4539719f61e67bf76e2a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#abd4066db0a3a4539719f61e67bf76e2a">getValue</a> () const</td></tr>
<tr class="memdesc:abd4066db0a3a4539719f61e67bf76e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value.  <br /></td></tr>
<tr class="separator:abd4066db0a3a4539719f61e67bf76e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbdf15224e585e1cb03524d24ae3a9f" id="r_a4cbdf15224e585e1cb03524d24ae3a9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a123505d87f81499a9b3a2e32a9948175">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4cbdf15224e585e1cb03524d24ae3a9f">getVersion</a> () const</td></tr>
<tr class="memdesc:a4cbdf15224e585e1cb03524d24ae3a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version of the field.  <br /></td></tr>
<tr class="separator:a4cbdf15224e585e1cb03524d24ae3a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba7955f744fbd09f3e85c41da0e38b4" id="r_a9ba7955f744fbd09f3e85c41da0e38b4"><td class="memItemLeft" align="right" valign="top"><a id="a9ba7955f744fbd09f3e85c41da0e38b4" name="a9ba7955f744fbd09f3e85c41da0e38b4"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> () const</td></tr>
<tr class="memdesc:a9ba7955f744fbd09f3e85c41da0e38b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of serialised data. <br /></td></tr>
<tr class="separator:a9ba7955f744fbd09f3e85c41da0e38b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c013f95e6d5e2d88c9268577914edf" id="r_a64c013f95e6d5e2d88c9268577914edf"><td class="memItemLeft" align="right" valign="top"><a id="a64c013f95e6d5e2d88c9268577914edf" name="a64c013f95e6d5e2d88c9268577914edf"></a>
<a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a64c013f95e6d5e2d88c9268577914edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a64c013f95e6d5e2d88c9268577914edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949264c3fe6d2f48ff966aac1dbc56a4" id="r_a949264c3fe6d2f48ff966aac1dbc56a4"><td class="memItemLeft" align="right" valign="top"><a id="a949264c3fe6d2f48ff966aac1dbc56a4" name="a949264c3fe6d2f48ff966aac1dbc56a4"></a>
<a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> &amp;)=default</td></tr>
<tr class="memdesc:a949264c3fe6d2f48ff966aac1dbc56a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:a949264c3fe6d2f48ff966aac1dbc56a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233253138dfdb176deaf65102b50246" id="r_a4233253138dfdb176deaf65102b50246"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a4233253138dfdb176deaf65102b50246"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a4233253138dfdb176deaf65102b50246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence.  <br /></td></tr>
<tr class="separator:a4233253138dfdb176deaf65102b50246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a42596d618d73c7efd092d30e7e554b" id="r_a8a42596d618d73c7efd092d30e7e554b"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a8a42596d618d73c7efd092d30e7e554b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a8a42596d618d73c7efd092d30e7e554b">readNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a8a42596d618d73c7efd092d30e7e554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence without error check and status report.  <br /></td></tr>
<tr class="separator:a8a42596d618d73c7efd092d30e7e554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e48d5f60d73d5e622addccc1b05db9" id="r_aa0e48d5f60d73d5e622addccc1b05db9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa0e48d5f60d73d5e622addccc1b05db9">refresh</a> ()</td></tr>
<tr class="memdesc:aa0e48d5f60d73d5e622addccc1b05db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the field.  <br /></td></tr>
<tr class="separator:aa0e48d5f60d73d5e622addccc1b05db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0cd4f67a87582369fae48ddc3a1a1" id="r_a5cf0cd4f67a87582369fae48ddc3a1a1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5cf0cd4f67a87582369fae48ddc3a1a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a5cf0cd4f67a87582369fae48ddc3a1a1">setValue</a> (U &amp;&amp;val)</td></tr>
<tr class="memdesc:a5cf0cd4f67a87582369fae48ddc3a1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value.  <br /></td></tr>
<tr class="separator:a5cf0cd4f67a87582369fae48ddc3a1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22333577a097b85bbf829ec728b8258" id="r_ab22333577a097b85bbf829ec728b8258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ab22333577a097b85bbf829ec728b8258">setVersion</a> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html#a123505d87f81499a9b3a2e32a9948175">VersionType</a> <a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>)</td></tr>
<tr class="memdesc:ab22333577a097b85bbf829ec728b8258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of version update.  <br /></td></tr>
<tr class="separator:ab22333577a097b85bbf829ec728b8258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ee618672993ad8cfd6161caf1cb828" id="r_ad2ee618672993ad8cfd6161caf1cb828"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ad2ee618672993ad8cfd6161caf1cb828">terminationFieldSuffix</a> () -&gt; decltype(BaseImpl::terminationFieldSuffix())</td></tr>
<tr class="memdesc:ad2ee618672993ad8cfd6161caf1cb828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access list termination field.  <br /></td></tr>
<tr class="separator:ad2ee618672993ad8cfd6161caf1cb828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c261a4141ac0708a941a976a3bc26" id="r_abb6c261a4141ac0708a941a976a3bc26"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#abb6c261a4141ac0708a941a976a3bc26">terminationFieldSuffix</a> () const -&gt; decltype(BaseImpl::terminationFieldSuffix())</td></tr>
<tr class="memdesc:abb6c261a4141ac0708a941a976a3bc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access list termination field (const variant)  <br /></td></tr>
<tr class="separator:abb6c261a4141ac0708a941a976a3bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac061e86727a2e38074e34a73ae35fb09" id="r_ac061e86727a2e38074e34a73ae35fb09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ac061e86727a2e38074e34a73ae35fb09">valid</a> () const</td></tr>
<tr class="memdesc:ac061e86727a2e38074e34a73ae35fb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of the field value.  <br /></td></tr>
<tr class="separator:ac061e86727a2e38074e34a73ae35fb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba1bef445fa3b32cdb1dbea0b45a4b" id="r_a6eba1bef445fa3b32cdb1dbea0b45a4b"><td class="memItemLeft" align="right" valign="top"><a id="a6eba1bef445fa3b32cdb1dbea0b45a4b" name="a6eba1bef445fa3b32cdb1dbea0b45a4b"></a>
<a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> ()</td></tr>
<tr class="memdesc:a6eba1bef445fa3b32cdb1dbea0b45a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the value storage. <br /></td></tr>
<tr class="separator:a6eba1bef445fa3b32cdb1dbea0b45a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d59deba384b1d482c9a6ab38f4b2b1" id="r_a05d59deba384b1d482c9a6ab38f4b2b1"><td class="memItemLeft" align="right" valign="top"><a id="a05d59deba384b1d482c9a6ab38f4b2b1" name="a05d59deba384b1d482c9a6ab38f4b2b1"></a>
const <a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> () const</td></tr>
<tr class="memdesc:a05d59deba384b1d482c9a6ab38f4b2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the value storage. <br /></td></tr>
<tr class="separator:a05d59deba384b1d482c9a6ab38f4b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21f0f2ce4d9700a29dc4d9bb27cda30" id="r_ad21f0f2ce4d9700a29dc4d9bb27cda30"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:ad21f0f2ce4d9700a29dc4d9bb27cda30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ad21f0f2ce4d9700a29dc4d9bb27cda30">write</a> (TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:ad21f0f2ce4d9700a29dc4d9bb27cda30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence.  <br /></td></tr>
<tr class="separator:ad21f0f2ce4d9700a29dc4d9bb27cda30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d43e0ecf5c1e5a227ccd38fc1289d" id="r_a376d43e0ecf5c1e5a227ccd38fc1289d"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a376d43e0ecf5c1e5a227ccd38fc1289d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a376d43e0ecf5c1e5a227ccd38fc1289d">writeNoStatus</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:a376d43e0ecf5c1e5a227ccd38fc1289d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence without error check and status report.  <br /></td></tr>
<tr class="separator:a376d43e0ecf5c1e5a227ccd38fc1289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07c7bd49761eeb71e159d49818cd09f0" id="r_a07c7bd49761eeb71e159d49818cd09f0"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">canWrite</a> ()</td></tr>
<tr class="memdesc:a07c7bd49761eeb71e159d49818cd09f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default check of whether the field has a consistent value for writing.  <br /></td></tr>
<tr class="separator:a07c7bd49761eeb71e159d49818cd09f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b998a5cc8b2fd374821a3b382a06f0" id="r_aa6b998a5cc8b2fd374821a3b382a06f0"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa6b998a5cc8b2fd374821a3b382a06f0">fixedSize</a> ()</td></tr>
<tr class="memdesc:aa6b998a5cc8b2fd374821a3b382a06f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of fixed size provided via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option.  <br /></td></tr>
<tr class="separator:aa6b998a5cc8b2fd374821a3b382a06f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6fec2a05f329d3266e891152293f88" id="r_abe6fec2a05f329d3266e891152293f88"><td class="memItemLeft" align="right" valign="top"><a id="abe6fec2a05f329d3266e891152293f88" name="abe6fec2a05f329d3266e891152293f88"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasElemFixedSerLengthFieldPrefix</b> ()</td></tr>
<tr class="memdesc:abe6fec2a05f329d3266e891152293f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a> option has been used. <br /></td></tr>
<tr class="separator:abe6fec2a05f329d3266e891152293f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4e49fba01a9a800f61dd55cad9d6d1" id="r_a1e4e49fba01a9a800f61dd55cad9d6d1"><td class="memItemLeft" align="right" valign="top"><a id="a1e4e49fba01a9a800f61dd55cad9d6d1" name="a1e4e49fba01a9a800f61dd55cad9d6d1"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasElemSerLengthFieldPrefix</b> ()</td></tr>
<tr class="memdesc:a1e4e49fba01a9a800f61dd55cad9d6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a> option has been used. <br /></td></tr>
<tr class="separator:a1e4e49fba01a9a800f61dd55cad9d6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0040b51d3a7bf059d2cdd7792f628497" id="r_a0040b51d3a7bf059d2cdd7792f628497"><td class="memItemLeft" align="right" valign="top"><a id="a0040b51d3a7bf059d2cdd7792f628497" name="a0040b51d3a7bf059d2cdd7792f628497"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasEmptySerialization</b> ()</td></tr>
<tr class="memdesc:a0040b51d3a7bf059d2cdd7792f628497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> option has been used. <br /></td></tr>
<tr class="separator:a0040b51d3a7bf059d2cdd7792f628497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f97f096d9b30cb2064e5e4d5385ab31" id="r_a3f97f096d9b30cb2064e5e4d5385ab31"><td class="memItemLeft" align="right" valign="top"><a id="a3f97f096d9b30cb2064e5e4d5385ab31" name="a3f97f096d9b30cb2064e5e4d5385ab31"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasFailOnInvalid</b> ()</td></tr>
<tr class="memdesc:a3f97f096d9b30cb2064e5e4d5385ab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> option has been used. <br /></td></tr>
<tr class="separator:a3f97f096d9b30cb2064e5e4d5385ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbbf994d31d766aa0517df24b72e310" id="r_addbbf994d31d766aa0517df24b72e310"><td class="memItemLeft" align="right" valign="top"><a id="addbbf994d31d766aa0517df24b72e310" name="addbbf994d31d766aa0517df24b72e310"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasFieldType</b> ()</td></tr>
<tr class="memdesc:addbbf994d31d766aa0517df24b72e310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1FieldType.html">comms::option::def::FieldType</a> option has been used. <br /></td></tr>
<tr class="separator:addbbf994d31d766aa0517df24b72e310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c53e3bee6c0ce2f7985d0fb718872b" id="r_a10c53e3bee6c0ce2f7985d0fb718872b"><td class="memItemLeft" align="right" valign="top"><a id="a10c53e3bee6c0ce2f7985d0fb718872b" name="a10c53e3bee6c0ce2f7985d0fb718872b"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasFixedSize</b> ()</td></tr>
<tr class="memdesc:a10c53e3bee6c0ce2f7985d0fb718872b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option has been used. <br /></td></tr>
<tr class="separator:a10c53e3bee6c0ce2f7985d0fb718872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f929f709348f045eee12caea5251a62" id="r_a5f929f709348f045eee12caea5251a62"><td class="memItemLeft" align="right" valign="top"><a id="a5f929f709348f045eee12caea5251a62" name="a5f929f709348f045eee12caea5251a62"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasFixedValue</b> ()</td></tr>
<tr class="memdesc:a5f929f709348f045eee12caea5251a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1FixedValue.html">comms::option::def::FixedValue</a> option has been used. <br /></td></tr>
<tr class="separator:a5f929f709348f045eee12caea5251a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28815c3000ef5566107fd251051d45c" id="r_ac28815c3000ef5566107fd251051d45c"><td class="memItemLeft" align="right" valign="top"><a id="ac28815c3000ef5566107fd251051d45c" name="ac28815c3000ef5566107fd251051d45c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasIgnoreInvalid</b> ()</td></tr>
<tr class="memdesc:ac28815c3000ef5566107fd251051d45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1IgnoreInvalid.html">comms::option::def::IgnoreInvalid</a> option has been used. <br /></td></tr>
<tr class="separator:ac28815c3000ef5566107fd251051d45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ebb2ab4b16a30c958a4aafbadaff9c" id="r_a42ebb2ab4b16a30c958a4aafbadaff9c"><td class="memItemLeft" align="right" valign="top"><a id="a42ebb2ab4b16a30c958a4aafbadaff9c" name="a42ebb2ab4b16a30c958a4aafbadaff9c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasName</b> ()</td></tr>
<tr class="memdesc:a42ebb2ab4b16a30c958a4aafbadaff9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> option has been used. <br /></td></tr>
<tr class="separator:a42ebb2ab4b16a30c958a4aafbadaff9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ce81157dd782b86f202ba46862651" id="r_ae61ce81157dd782b86f202ba46862651"><td class="memItemLeft" align="right" valign="top"><a id="ae61ce81157dd782b86f202ba46862651" name="ae61ce81157dd782b86f202ba46862651"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasNonDefaultRefresh</b> ()</td></tr>
<tr class="memdesc:ae61ce81157dd782b86f202ba46862651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class has non-default refresh functionality. <br /></td></tr>
<tr class="separator:ae61ce81157dd782b86f202ba46862651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431495375e6e100d75f243e32a6dd0b4" id="r_a431495375e6e100d75f243e32a6dd0b4"><td class="memItemLeft" align="right" valign="top"><a id="a431495375e6e100d75f243e32a6dd0b4" name="a431495375e6e100d75f243e32a6dd0b4"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasReadNoStatus</b> ()</td></tr>
<tr class="memdesc:a431495375e6e100d75f243e32a6dd0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a8a42596d618d73c7efd092d30e7e554b">readNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:a431495375e6e100d75f243e32a6dd0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c1840a0cb266effeb0438850f9e52" id="r_ab26c1840a0cb266effeb0438850f9e52"><td class="memItemLeft" align="right" valign="top"><a id="ab26c1840a0cb266effeb0438850f9e52" name="ab26c1840a0cb266effeb0438850f9e52"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasSerLengthFieldPrefix</b> ()</td></tr>
<tr class="memdesc:ab26c1840a0cb266effeb0438850f9e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a> option has been used. <br /></td></tr>
<tr class="separator:ab26c1840a0cb266effeb0438850f9e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbcbeb223d3b1db3a54bad76c86f088" id="r_afdbcbeb223d3b1db3a54bad76c86f088"><td class="memItemLeft" align="right" valign="top"><a id="afdbcbeb223d3b1db3a54bad76c86f088" name="afdbcbeb223d3b1db3a54bad76c86f088"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasSizeFieldPrefix</b> ()</td></tr>
<tr class="memdesc:afdbcbeb223d3b1db3a54bad76c86f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a> option has been used. <br /></td></tr>
<tr class="separator:afdbcbeb223d3b1db3a54bad76c86f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c341cf96dfb314e2ab1633816468a75" id="r_a5c341cf96dfb314e2ab1633816468a75"><td class="memItemLeft" align="right" valign="top"><a id="a5c341cf96dfb314e2ab1633816468a75" name="a5c341cf96dfb314e2ab1633816468a75"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTerminationFieldSuffix</b> ()</td></tr>
<tr class="memdesc:a5c341cf96dfb314e2ab1633816468a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> option has been used. <br /></td></tr>
<tr class="separator:a5c341cf96dfb314e2ab1633816468a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab272d6ca78fce309914c305290acd7" id="r_a1ab272d6ca78fce309914c305290acd7"><td class="memItemLeft" align="right" valign="top"><a id="a1ab272d6ca78fce309914c305290acd7" name="a1ab272d6ca78fce309914c305290acd7"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasTrailingFieldSuffix</b> ()</td></tr>
<tr class="memdesc:a1ab272d6ca78fce309914c305290acd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a> option has been used. <br /></td></tr>
<tr class="separator:a1ab272d6ca78fce309914c305290acd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff46470efbd63ba545801326e6b7f76" id="r_acff46470efbd63ba545801326e6b7f76"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#acff46470efbd63ba545801326e6b7f76">hasVarLength</a> ()</td></tr>
<tr class="memdesc:acff46470efbd63ba545801326e6b7f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default check of whether the field has variable length definition via <a class="el" href="structcomms_1_1option_1_1def_1_1VarLength.html">comms::option::def::VarLength</a> option.  <br /></td></tr>
<tr class="separator:acff46470efbd63ba545801326e6b7f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf012bab0c56bacd6050974d414e8970" id="r_abf012bab0c56bacd6050974d414e8970"><td class="memItemLeft" align="right" valign="top"><a id="abf012bab0c56bacd6050974d414e8970" name="abf012bab0c56bacd6050974d414e8970"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasWriteNoStatus</b> ()</td></tr>
<tr class="memdesc:abf012bab0c56bacd6050974d414e8970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a376d43e0ecf5c1e5a227ccd38fc1289d">writeNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:abf012bab0c56bacd6050974d414e8970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e1fcfb07d410e34e3228cfd7bdb424" id="r_a45e1fcfb07d410e34e3228cfd7bdb424"><td class="memItemLeft" align="right" valign="top"><a id="a45e1fcfb07d410e34e3228cfd7bdb424" name="a45e1fcfb07d410e34e3228cfd7bdb424"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isVersionDependent</b> ()</td></tr>
<tr class="memdesc:a45e1fcfb07d410e34e3228cfd7bdb424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class is version dependent. <br /></td></tr>
<tr class="separator:a45e1fcfb07d410e34e3228cfd7bdb424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae786da6079ea0dbdc67a1c997de7e08f" id="r_ae786da6079ea0dbdc67a1c997de7e08f"><td class="memItemLeft" align="right" valign="top"><a id="ae786da6079ea0dbdc67a1c997de7e08f" name="ae786da6079ea0dbdc67a1c997de7e08f"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxLength</b> ()</td></tr>
<tr class="memdesc:ae786da6079ea0dbdc67a1c997de7e08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise field of this type. <br /></td></tr>
<tr class="separator:ae786da6079ea0dbdc67a1c997de7e08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb6e0c0dda082f7935ae167afae7387" id="r_a9fb6e0c0dda082f7935ae167afae7387"><td class="memItemLeft" align="right" valign="top"><a id="a9fb6e0c0dda082f7935ae167afae7387" name="a9fb6e0c0dda082f7935ae167afae7387"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>minLength</b> ()</td></tr>
<tr class="memdesc:a9fb6e0c0dda082f7935ae167afae7387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise field of this type. <br /></td></tr>
<tr class="separator:a9fb6e0c0dda082f7935ae167afae7387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7d5f9c7a7167869590974d46edf5d" id="r_abbc7d5f9c7a7167869590974d46edf5d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">valid</a> ()</td></tr>
<tr class="memdesc:abbc7d5f9c7a7167869590974d46edf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default validity check.  <br /></td></tr>
<tr class="separator:abbc7d5f9c7a7167869590974d46edf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8" id="r_a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a625b2614fc28507e11476c4dfa168cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input buffer.  <br /></td></tr>
<tr class="separator:a625b2614fc28507e11476c4dfa168cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868" id="r_aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aa2fc07d0015fc88421311ac8c1a55868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input buffer.  <br /></td></tr>
<tr class="separator:aa2fc07d0015fc88421311ac8c1a55868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480" id="r_a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a6eba1bef445fa3b32cdb1dbea0b45a4b">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output buffer.  <br /></td></tr>
<tr class="separator:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a" id="r_aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a6eba1bef445fa3b32cdb1dbea0b45a4b">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output buffer.  <br /></td></tr>
<tr class="separator:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:aae4b127753cf01403a892815130e347e" id="r_aae4b127753cf01403a892815130e347e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae4b127753cf01403a892815130e347e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#aae4b127753cf01403a892815130e347e">isArrayList</a> ()</td></tr>
<tr class="memdesc:aae4b127753cf01403a892815130e347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a>.  <br /></td></tr>
<tr class="separator:aae4b127753cf01403a892815130e347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8266ed267e8616dd13ad580fa263358" id="r_ae8266ed267e8616dd13ad580fa263358"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </td></tr>
<tr class="memitem:ae8266ed267e8616dd13ad580fa263358"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#ae8266ed267e8616dd13ad580fa263358">operator!=</a> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:ae8266ed267e8616dd13ad580fa263358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equality comparison operator.  <br /></td></tr>
<tr class="separator:ae8266ed267e8616dd13ad580fa263358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887809c0ca169fddd4d7a4d5c325f05c" id="r_a887809c0ca169fddd4d7a4d5c325f05c"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </td></tr>
<tr class="memitem:a887809c0ca169fddd4d7a4d5c325f05c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a887809c0ca169fddd4d7a4d5c325f05c">operator&lt;</a> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a887809c0ca169fddd4d7a4d5c325f05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <br /></td></tr>
<tr class="separator:a887809c0ca169fddd4d7a4d5c325f05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7101e31de6406141da2f2bb24d7b1a1" id="r_af7101e31de6406141da2f2bb24d7b1a1"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </td></tr>
<tr class="memitem:af7101e31de6406141da2f2bb24d7b1a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#af7101e31de6406141da2f2bb24d7b1a1">operator==</a> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:af7101e31de6406141da2f2bb24d7b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <br /></td></tr>
<tr class="separator:af7101e31de6406141da2f2bb24d7b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbb933655ae5019a2c99686111c3608" id="r_a9fbb933655ae5019a2c99686111c3608"><td class="memTemplParams" colspan="2"><a id="a9fbb933655ae5019a2c99686111c3608" name="a9fbb933655ae5019a2c99686111c3608"></a>
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </td></tr>
<tr class="memitem:a9fbb933655ae5019a2c99686111c3608"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toFieldBase</b> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:a9fbb933655ae5019a2c99686111c3608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a9fbb933655ae5019a2c99686111c3608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff60e9130a3e0640241f4041a7bbe9b" id="r_a4ff60e9130a3e0640241f4041a7bbe9b"><td class="memTemplParams" colspan="2"><a id="a4ff60e9130a3e0640241f4041a7bbe9b" name="a4ff60e9130a3e0640241f4041a7bbe9b"></a>
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </td></tr>
<tr class="memitem:a4ff60e9130a3e0640241f4041a7bbe9b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>toFieldBase</b> (const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:a4ff60e9130a3e0640241f4041a7bbe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a4ff60e9130a3e0640241f4041a7bbe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac77cc166bef350024ea587f01efb39eb" name="ac77cc166bef350024ea587f01efb39eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77cc166bef350024ea587f01efb39eb">&#9670;&#160;</a></span>ElemFixedSerLengthFieldPrefix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::ElemFixedSerLengthFieldPrefix =  typename ParsedOptions::SequenceElemFixedSerLengthFieldPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of element's fixed length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a> is not used. </p>

</div>
</div>
<a id="a9b12cdd6cd03fb0dff0cef144ba526b6" name="a9b12cdd6cd03fb0dff0cef144ba526b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b12cdd6cd03fb0dff0cef144ba526b6">&#9670;&#160;</a></span>ElemSerLengthFieldPrefix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::ElemSerLengthFieldPrefix =  typename ParsedOptions::SequenceElemSerLengthFieldPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of element's length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a> is not used. </p>

</div>
</div>
<a id="abbc572a08258d685fb036df21007bb46" name="abbc572a08258d685fb036df21007bb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc572a08258d685fb036df21007bb46">&#9670;&#160;</a></span>FieldType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::FieldType =  typename ParsedOptions::FieldType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of actual extending field specified via <a class="el" href="structcomms_1_1option_1_1def_1_1FieldType.html">comms::option::def::FieldType</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1FieldType.html">comms::option::def::FieldType</a> hasn't been applied. </p>

</div>
</div>
<a id="ac6904af096ad9d12fb674205dff48eca" name="ac6904af096ad9d12fb674205dff48eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6904af096ad9d12fb674205dff48eca">&#9670;&#160;</a></span>SerLengthFieldPrefix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::SerLengthFieldPrefix =  typename ParsedOptions::SequenceSerLengthFieldPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of length field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a> is not used. </p>

</div>
</div>
<a id="a8f342e8225cf41b961c5f594c4dfdf60" name="a8f342e8225cf41b961c5f594c4dfdf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f342e8225cf41b961c5f594c4dfdf60">&#9670;&#160;</a></span>SizeFieldPrefix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::SizeFieldPrefix =  typename ParsedOptions::SequenceSizeFieldPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of size field prefix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a> is not used. </p>

</div>
</div>
<a id="aef376152c7b332c70d2841d7ee292cb6" name="aef376152c7b332c70d2841d7ee292cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef376152c7b332c70d2841d7ee292cb6">&#9670;&#160;</a></span>TerminationFieldSuffix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::TerminationFieldSuffix =  typename ParsedOptions::SequenceTerminationFieldSuffix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of termination field suffix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> is not used. </p>

</div>
</div>
<a id="a3d3e78d50542be7221e39571bfd2cdcd" name="a3d3e78d50542be7221e39571bfd2cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3e78d50542be7221e39571bfd2cdcd">&#9670;&#160;</a></span>TrailingFieldSuffix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::TrailingFieldSuffix =  typename ParsedOptions::SequenceTrailingFieldSuffix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of trailing field suffix specified via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a>. </p>
<p><b>void</b> if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a> is not used. </p>

</div>
</div>
<a id="aa8e82da497de6abd350b0a3fb86100e5" name="aa8e82da497de6abd350b0a3fb86100e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e82da497de6abd350b0a3fb86100e5">&#9670;&#160;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::ValueType =  typename BaseImpl::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of underlying value. </p>
<p>If <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> option is NOT used, the ValueType is std::vector&lt;TElement&gt;, otherwise it becomes comms::util::StaticVector&lt;TElement, TSize&gt;, where TSize is a size provided to <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> option. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a07c7bd49761eeb71e159d49818cd09f0" name="a07c7bd49761eeb71e159d49818cd09f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c7bd49761eeb71e159d49818cd09f0">&#9670;&#160;</a></span>canWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::canWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default check of whether the field has a consistent value for writing. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>true</b>. </dd></dl>

</div>
</div>
<a id="ae05c1e12acff6d7495d743ba812b901c" name="ae05c1e12acff6d7495d743ba812b901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05c1e12acff6d7495d743ba812b901c">&#9670;&#160;</a></span>clearReadElemCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::clearReadElemCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear forcing of the number of elements that must be read in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a> option has been used. </p>

</div>
</div>
<a id="a1c8e803cfa8f3d995d1e1816df59c93b" name="a1c8e803cfa8f3d995d1e1816df59c93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8e803cfa8f3d995d1e1816df59c93b">&#9670;&#160;</a></span>clearReadElemLengthForcing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::clearReadElemLengthForcing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear forcing the serialisation length of the single element. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemLengthForcingEnabled.html">comms::option::def::SequenceElemLengthForcingEnabled</a> option has been used. </p>

</div>
</div>
<a id="a571e0dde7a7fd82c9c1ef2b096e10dc1" name="a571e0dde7a7fd82c9c1ef2b096e10dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571e0dde7a7fd82c9c1ef2b096e10dc1">&#9670;&#160;</a></span>clearReadLengthForcing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::clearReadLengthForcing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear forcing of the available length in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceLengthForcingEnabled.html">comms::option::def::SequenceLengthForcingEnabled</a> option has been used. </p>

</div>
</div>
<a id="aa6b998a5cc8b2fd374821a3b382a06f0" name="aa6b998a5cc8b2fd374821a3b382a06f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b998a5cc8b2fd374821a3b382a06f0">&#9670;&#160;</a></span>fixedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::fixedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry of fixed size provided via <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option. </p>
<p>If the <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option hasn't been used <b>std::numeric_limits&lt;std::size_t&gt;::max()</b> is returned. </p>

</div>
</div>
<a id="a94688b8f24a97e863dbfd6b537410c43" name="a94688b8f24a97e863dbfd6b537410c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94688b8f24a97e863dbfd6b537410c43">&#9670;&#160;</a></span>forceReadElemCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::forceReadElemCount </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force number of elements that must be read in the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a> option has been used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to read during following read operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cc0795d98464b2825ff25815a68f3fb" name="a9cc0795d98464b2825ff25815a68f3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc0795d98464b2825ff25815a68f3fb">&#9670;&#160;</a></span>forceReadElemLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::forceReadElemLength </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force serialisation length of a single element. </p>
<p>The function can be used to force a serialisation length of a single element within the <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">ArrayList</a>. Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemLengthForcingEnabled.html">comms::option::def::SequenceElemLengthForcingEnabled</a> option has been used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to read during following read operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae388a59eda51483a88ff7e791ec8ebff" name="ae388a59eda51483a88ff7e791ec8ebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae388a59eda51483a88ff7e791ec8ebff">&#9670;&#160;</a></span>forceReadLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::forceReadLength </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force available length for the next <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246" title="Read field value from input data sequence.">read()</a> invocation. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceLengthForcingEnabled.html">comms::option::def::SequenceLengthForcingEnabled</a> option has been used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to read during following read operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4066db0a3a4539719f61e67bf76e2a" name="abd4066db0a3a4539719f61e67bf76e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4066db0a3a4539719f61e67bf76e2a">&#9670;&#160;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa8e82da497de6abd350b0a3fb86100e5">ValueType</a> &amp; <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value. </p>
<p>Implemented by calling <b><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a6eba1bef445fa3b32cdb1dbea0b45a4b" title="Get access to the value storage.">value()</a></b>, but can be overriden in the derived class </p>

</div>
</div>
<a id="a4cbdf15224e585e1cb03524d24ae3a9f" name="a4cbdf15224e585e1cb03524d24ae3a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbdf15224e585e1cb03524d24ae3a9f">&#9670;&#160;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a123505d87f81499a9b3a2e32a9948175">VersionType</a> <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version of the field. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> option has been provided. </p>

</div>
</div>
<a id="acff46470efbd63ba545801326e6b7f76" name="acff46470efbd63ba545801326e6b7f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff46470efbd63ba545801326e6b7f76">&#9670;&#160;</a></span>hasVarLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::hasVarLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default check of whether the field has variable length definition via <a class="el" href="structcomms_1_1option_1_1def_1_1VarLength.html">comms::option::def::VarLength</a> option. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>false</b>. </dd></dl>

</div>
</div>
<a id="a4233253138dfdb176deaf65102b50246" name="a4233253138dfdb176deaf65102b50246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4233253138dfdb176deaf65102b50246">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence. </p>
<p>By default, the read operation will try to consume all the data available, unless size limiting option (such as <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>, <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a>, <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a>, <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceLengthForcingEnabled.html">comms::option::def::SequenceLengthForcingEnabled</a>) is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a625b2614fc28507e11476c4dfa168cf8" name="a625b2614fc28507e11476c4dfa168cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625b2614fc28507e11476c4dfa168cf8">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa2fc07d0015fc88421311ac8c1a55868" name="aa2fc07d0015fc88421311ac8c1a55868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc07d0015fc88421311ac8c1a55868">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a8a42596d618d73c7efd092d30e7e554b" name="a8a42596d618d73c7efd092d30e7e554b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a42596d618d73c7efd092d30e7e554b">&#9670;&#160;</a></span>readNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::readNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="aa0e48d5f60d73d5e622addccc1b05db9" name="aa0e48d5f60d73d5e622addccc1b05db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e48d5f60d73d5e622addccc1b05db9">&#9670;&#160;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the field. </p>
<p>Calls <a class="el" href="classcomms_1_1field_1_1ArrayList.html#aa0e48d5f60d73d5e622addccc1b05db9" title="Refresh the field.">refresh()</a> on all the elements (if they are fields and not raw bytes).</p>
<p>Returns true if any of the elements has been updated, false otherwise. </p>

</div>
</div>
<a id="a5cf0cd4f67a87582369fae48ddc3a1a1" name="a5cf0cd4f67a87582369fae48ddc3a1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf0cd4f67a87582369fae48ddc3a1a1">&#9670;&#160;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value. </p>
<p>Implemented as re-assigning to <b><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a6eba1bef445fa3b32cdb1dbea0b45a4b" title="Get access to the value storage.">value()</a></b>, but can be overriden in the derived class. </p>

</div>
</div>
<a id="ab22333577a097b85bbf829ec728b8258" name="ab22333577a097b85bbf829ec728b8258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22333577a097b85bbf829ec728b8258">&#9670;&#160;</a></span>setVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::setVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a123505d87f81499a9b3a2e32a9948175">VersionType</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of version update. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the field contents have changed, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="ad2ee618672993ad8cfd6161caf1cb828" name="ad2ee618672993ad8cfd6161caf1cb828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ee618672993ad8cfd6161caf1cb828">&#9670;&#160;</a></span>terminationFieldSuffix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::terminationFieldSuffix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(BaseImpl::terminationFieldSuffix())
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access list termination field. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> option has been used. The function can be used to access the termination field value after the <b>read</b> and/or before the <b>write</b> operations. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a5c341cf96dfb314e2ab1633816468a75">hasTerminationFieldSuffix()</a> returns true. </dd></dl>

</div>
</div>
<a id="abb6c261a4141ac0708a941a976a3bc26" name="abb6c261a4141ac0708a941a976a3bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6c261a4141ac0708a941a976a3bc26">&#9670;&#160;</a></span>terminationFieldSuffix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::terminationFieldSuffix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(BaseImpl::terminationFieldSuffix())
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access list termination field (const variant) </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> option has been used. The function can be used to access the termination field value after the <b>read</b> and/or before the <b>write</b> operations. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classcomms_1_1field_1_1ArrayList.html#a5c341cf96dfb314e2ab1633816468a75">hasTerminationFieldSuffix()</a> returns true. </dd></dl>

</div>
</div>
<a id="abbc7d5f9c7a7167869590974d46edf5d" name="abbc7d5f9c7a7167869590974d46edf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7d5f9c7a7167869590974d46edf5d">&#9670;&#160;</a></span>valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default validity check. </p>
<p>Always returns true, can be overriden by the derived class </p><dl class="section return"><dt>Returns</dt><dd>Always <b>true</b> </dd></dl>

</div>
</div>
<a id="ac061e86727a2e38074e34a73ae35fb09" name="ac061e86727a2e38074e34a73ae35fb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac061e86727a2e38074e34a73ae35fb09">&#9670;&#160;</a></span>valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check validity of the field value. </p>
<p>The collection is valid if all the elements are valid. </p><dl class="section return"><dt>Returns</dt><dd>true in case the field's value is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="ad21f0f2ce4d9700a29dc4d9bb27cda30" name="ad21f0f2ce4d9700a29dc4d9bb27cda30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21f0f2ce4d9700a29dc4d9bb27cda30">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence. </p>
<p>By default, the write operation will write all the elements the field contains. If <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option is used, the number of elements, that is going to be written, is exactly as the option specifies. If underlying vector storage doesn't contain enough data, the default constructed elements will be appended to the written sequence until the required amount of elements is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a0bd63c4d88caa3e2c7ec36810f4ef480" name="a0bd63c4d88caa3e2c7ec36810f4ef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd63c4d88caa3e2c7ec36810f4ef480">&#9670;&#160;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output buffer. </p>
<p>Use this function to write data to the the buffer maintained by the caller. The endianness of the data will be as specified in the options provided to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa03f444fd95e5ab123f8cdadd5f0a24a" name="aa03f444fd95e5ab123f8cdadd5f0a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03f444fd95e5ab123f8cdadd5f0a24a">&#9670;&#160;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output buffer. </p>
<p>Use this function to write partial data to the buffer maintained by the caller. The endianness of the data will be as specified the class options. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a376d43e0ecf5c1e5a227ccd38fc1289d" name="a376d43e0ecf5c1e5a227ccd38fc1289d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376d43e0ecf5c1e5a227ccd38fc1289d">&#9670;&#160;</a></span>writeNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, TElement, TOptions &gt;::writeNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1ArrayList.html#ad21f0f2ce4d9700a29dc4d9bb27cda30">write()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aae4b127753cf01403a892815130e347e" name="aae4b127753cf01403a892815130e347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b127753cf01403a892815130e347e">&#9670;&#160;</a></span>isArrayList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool isArrayList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case provided type is any variant of <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a> </dd></dl>

</div>
</div>
<a id="ae8266ed267e8616dd13ad580fa263358" name="ae8266ed267e8616dd13ad580fa263358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8266ed267e8616dd13ad580fa263358">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are NOT equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a887809c0ca169fddd4d7a4d5c325f05c" name="a887809c0ca169fddd4d7a4d5c325f05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887809c0ca169fddd4d7a4d5c325f05c">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<p>Performs lexicographical compare of two array fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case first field is less than second field. </dd></dl>

</div>
</div>
<a id="af7101e31de6406141da2f2bb24d7b1a1" name="af7101e31de6406141da2f2bb24d7b1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7101e31de6406141da2f2bb24d7b1a1">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TElement , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1ArrayList.html">ArrayList</a>&lt; TFieldBase, TElement, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are equal, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/field/<a class="el" href="ArrayList_8h_source.html">ArrayList.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
