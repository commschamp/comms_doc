<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::field::BitmaskValue&lt; TFieldBase, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1field.html">field</a></li><li class="navelem"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1field_1_1BitmaskValue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::field::BitmaskValue&lt; TFieldBase, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="BitmaskValue_8h_source.html">comms/field/BitmaskValue.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TFieldBase, typename... TOptions&gt;<br />
class comms::field::BitmaskValue&lt; TFieldBase, TOptions &gt;</h3>

<p>Bitmask value field. </p>
<p>Quite often communication protocols specify bitmask values, where any bit has a specific meaning. Although such masks are can be handled as unsigned integer values using <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value.">comms::field::IntValue</a> field type, using comms::field::Bitmask may be a bit more convenient. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFieldBase</td><td>Base class for this field, expected to be a variant of <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">comms::Field</a>. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Zero or more options that modify/refine default behaviour of the field. If no option is provided, the underlying type is assumed to be "unsigned", which is usually 4 bytes long. To redefined the length of the bitmask field, use <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a> option. For example: <div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> MyField =<a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase&gt;</a>;</div>
</div><!-- fragment --> The serialised value of the field in the example above will consume sizeof(unsigned) bytes, because the underlying type chosen to be "unsigned" by default. Example below specifies simple bitmask value field with 2 bytes serialisation length: <div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> MyField =<a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;2&gt;</a> &gt;;</div>
</div><!-- fragment --> Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FixedBitLength.html">comms::option::def::FixedBitLength</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605" title="Alias to DefaultValueInitialiser, it defines initialiser class that assigns numeric value provided as...">comms::option::def::DefaultNumValue</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#ab250f5104df4cfe83741d63e6db70505" title="Alias to ContentsValidator, it defines validator class that checks that reserved bits of the field ha...">comms::option::def::BitmaskReservedBits</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsRefresher.html">comms::option::def::ContentsRefresher</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRead.html">comms::option::def::HasCustomRead</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1IgnoreInvalid.html">comms::option::def::IgnoreInvalid</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee" title="Provide names for bits in comms::field::BitmaskValue field.">COMMS_BITMASK_BITS()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b" title="Generate access functions for bits in comms::field::BitmaskValue field.">COMMS_BITMASK_BITS_ACCESS()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1" title="Similar to COMMS_BITMASK_BITS_ACCESS(), but dedicated for non-template classes.">COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62" title="Combine usage of COMMS_BITMASK_BITS() and COMMS_BITMASK_BITS_ACCESS().">COMMS_BITMASK_BITS_SEQ()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3" title="Similar to COMMS_BITMASK_BITS_SEQ(), but dedicated for non-template classes.">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE()</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::field::BitmaskValue&lt; TFieldBase, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1field_1_1BitmaskValue.png" usemap="#comms::field::BitmaskValue_3C_20TFieldBase_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::field::BitmaskValue_3C_20TFieldBase_2C_20TOptions_20_3E_map" name="comms::field::BitmaskValue_3C_20TFieldBase_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1Field.html" title="Base class to all the field classes." alt="comms::Field&lt; TOptions &gt;" shape="rect" coords="0,0,307,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc6dfef8d0cda8fa5f576d7286899ffa"><td class="memItemLeft" align="right" valign="top"><a id="afc6dfef8d0cda8fa5f576d7286899ffa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#afc6dfef8d0cda8fa5f576d7286899ffa">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:afc6dfef8d0cda8fa5f576d7286899ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endian used for serialisation. <br /></td></tr>
<tr class="separator:afc6dfef8d0cda8fa5f576d7286899ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d29846e17c15c61cef8eeb7dc90f82a"><td class="memItemLeft" align="right" valign="top"><a id="a9d29846e17c15c61cef8eeb7dc90f82a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a9d29846e17c15c61cef8eeb7dc90f82a">ParsedOptions</a> = OptionsBundle</td></tr>
<tr class="memdesc:a9d29846e17c15c61cef8eeb7dc90f82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:a9d29846e17c15c61cef8eeb7dc90f82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7e7bf2ddc1cb9d67235442b171f4a"><td class="memItemLeft" align="right" valign="top"><a id="a3eb7e7bf2ddc1cb9d67235442b171f4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3eb7e7bf2ddc1cb9d67235442b171f4a">Tag</a> = tag::Bitmask</td></tr>
<tr class="memdesc:a3eb7e7bf2ddc1cb9d67235442b171f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating type of the field. <br /></td></tr>
<tr class="separator:a3eb7e7bf2ddc1cb9d67235442b171f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206c111ea8c0f208b46011aa86a5add"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> = typename <a class="el" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">IntValueField::ValueType</a></td></tr>
<tr class="memdesc:a3206c111ea8c0f208b46011aa86a5add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of underlying integral value.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">More...</a><br /></td></tr>
<tr class="separator:a3206c111ea8c0f208b46011aa86a5add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4025c3b2b48ad52563d30031b4ceb5"><td class="memItemLeft" align="right" valign="top"><a id="a4c4025c3b2b48ad52563d30031b4ceb5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4c4025c3b2b48ad52563d30031b4ceb5">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:a4c4025c3b2b48ad52563d30031b4ceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version type. <br /></td></tr>
<tr class="separator:a4c4025c3b2b48ad52563d30031b4ceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad49d22114335c0fe8c80a5fa5ad120b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad49d22114335c0fe8c80a5fa5ad120b0">BitmaskValue</a> ()=default</td></tr>
<tr class="memdesc:ad49d22114335c0fe8c80a5fa5ad120b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcomms_1_1field_1_1BitmaskValue.html#ad49d22114335c0fe8c80a5fa5ad120b0">More...</a><br /></td></tr>
<tr class="separator:ad49d22114335c0fe8c80a5fa5ad120b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a473cdef4aa5c596c2caa9e5de761c"><td class="memItemLeft" align="right" valign="top"><a id="ab3a473cdef4aa5c596c2caa9e5de761c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ab3a473cdef4aa5c596c2caa9e5de761c">BitmaskValue</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> &amp;)=default</td></tr>
<tr class="memdesc:ab3a473cdef4aa5c596c2caa9e5de761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ab3a473cdef4aa5c596c2caa9e5de761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa552e2eee02c4876e05e9aad9b34c3ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aa552e2eee02c4876e05e9aad9b34c3ec">BitmaskValue</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:aa552e2eee02c4876e05e9aad9b34c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classcomms_1_1field_1_1BitmaskValue.html#aa552e2eee02c4876e05e9aad9b34c3ec">More...</a><br /></td></tr>
<tr class="separator:aa552e2eee02c4876e05e9aad9b34c3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c949a61c6dab8c84e7708cbf3aa426"><td class="memItemLeft" align="right" valign="top"><a id="a98c949a61c6dab8c84e7708cbf3aa426"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a98c949a61c6dab8c84e7708cbf3aa426">~BitmaskValue</a> () noexcept=default</td></tr>
<tr class="memdesc:a98c949a61c6dab8c84e7708cbf3aa426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a98c949a61c6dab8c84e7708cbf3aa426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807805576ec3ecd1e4115cc5713b6356"><td class="memItemLeft" align="right" valign="top"><a id="a807805576ec3ecd1e4115cc5713b6356"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a807805576ec3ecd1e4115cc5713b6356">canWrite</a> () const</td></tr>
<tr class="memdesc:a807805576ec3ecd1e4115cc5713b6356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of whether the field has a consistent value for writing. <br /></td></tr>
<tr class="separator:a807805576ec3ecd1e4115cc5713b6356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff5cdfab4b92448ce4a5bf0097921c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0ff5cdfab4b92448ce4a5bf0097921c5">clearBits</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> mask)</td></tr>
<tr class="memdesc:a0ff5cdfab4b92448ce4a5bf0097921c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the provided bits.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a0ff5cdfab4b92448ce4a5bf0097921c5">More...</a><br /></td></tr>
<tr class="separator:a0ff5cdfab4b92448ce4a5bf0097921c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba03ea117a584dafb99e27e47ee8819"><td class="memItemLeft" align="right" valign="top"><a id="a3ba03ea117a584dafb99e27e47ee8819"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a> (unsigned bitNum) const</td></tr>
<tr class="memdesc:a3ba03ea117a584dafb99e27e47ee8819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bit value. <br /></td></tr>
<tr class="separator:a3ba03ea117a584dafb99e27e47ee8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144137f34cf51bc42957919d52d98bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4c4025c3b2b48ad52563d30031b4ceb5">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a144137f34cf51bc42957919d52d98bfa">getVersion</a> () const</td></tr>
<tr class="memdesc:a144137f34cf51bc42957919d52d98bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version of the field.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a144137f34cf51bc42957919d52d98bfa">More...</a><br /></td></tr>
<tr class="separator:a144137f34cf51bc42957919d52d98bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ecda531caa8a9d53e6d7d8fa17836e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#af6ecda531caa8a9d53e6d7d8fa17836e">hasAllBitsSet</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> mask) const</td></tr>
<tr class="memdesc:af6ecda531caa8a9d53e6d7d8fa17836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all bits from provided mask are set.  <a href="classcomms_1_1field_1_1BitmaskValue.html#af6ecda531caa8a9d53e6d7d8fa17836e">More...</a><br /></td></tr>
<tr class="separator:af6ecda531caa8a9d53e6d7d8fa17836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9934aaa79c653de2845f354bdbfff1b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a9934aaa79c653de2845f354bdbfff1b4">hasAnyBitsSet</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> mask) const</td></tr>
<tr class="memdesc:a9934aaa79c653de2845f354bdbfff1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any bits from provided mask are set.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a9934aaa79c653de2845f354bdbfff1b4">More...</a><br /></td></tr>
<tr class="separator:a9934aaa79c653de2845f354bdbfff1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae777fa79938d399944f4177896e82dd"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aae777fa79938d399944f4177896e82dd">length</a> () const</td></tr>
<tr class="memdesc:aae777fa79938d399944f4177896e82dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise the current field value.  <a href="classcomms_1_1field_1_1BitmaskValue.html#aae777fa79938d399944f4177896e82dd">More...</a><br /></td></tr>
<tr class="separator:aae777fa79938d399944f4177896e82dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887e8fbb131a4c7831b93d6aa53430d4"><td class="memItemLeft" align="right" valign="top"><a id="a887e8fbb131a4c7831b93d6aa53430d4"></a>
<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a887e8fbb131a4c7831b93d6aa53430d4">operator=</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> &amp;)=default</td></tr>
<tr class="memdesc:a887e8fbb131a4c7831b93d6aa53430d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:a887e8fbb131a4c7831b93d6aa53430d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a748e7ff8ccb08cfc47948dacefd8e"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a14a748e7ff8ccb08cfc47948dacefd8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a14a748e7ff8ccb08cfc47948dacefd8e">read</a> (TIter &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a14a748e7ff8ccb08cfc47948dacefd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a14a748e7ff8ccb08cfc47948dacefd8e">More...</a><br /></td></tr>
<tr class="separator:a14a748e7ff8ccb08cfc47948dacefd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9afe89747b4dff2c5f88be181f646f"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a5f9afe89747b4dff2c5f88be181f646f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a5f9afe89747b4dff2c5f88be181f646f">readNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a5f9afe89747b4dff2c5f88be181f646f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence without error check and status report.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a5f9afe89747b4dff2c5f88be181f646f">More...</a><br /></td></tr>
<tr class="separator:a5f9afe89747b4dff2c5f88be181f646f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993aca85b9b0970916ef0c044e4da4ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a993aca85b9b0970916ef0c044e4da4ad">refresh</a> ()</td></tr>
<tr class="memdesc:a993aca85b9b0970916ef0c044e4da4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh contents of the field.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a993aca85b9b0970916ef0c044e4da4ad">More...</a><br /></td></tr>
<tr class="separator:a993aca85b9b0970916ef0c044e4da4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9116ee69aa6d1ed0551b360ac9d660c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ac9116ee69aa6d1ed0551b360ac9d660c">setBits</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> mask)</td></tr>
<tr class="memdesc:ac9116ee69aa6d1ed0551b360ac9d660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the provided bits.  <a href="classcomms_1_1field_1_1BitmaskValue.html#ac9116ee69aa6d1ed0551b360ac9d660c">More...</a><br /></td></tr>
<tr class="separator:ac9116ee69aa6d1ed0551b360ac9d660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae5a5fde24cc9498e34e087b8f571ea"><td class="memItemLeft" align="right" valign="top"><a id="a7ae5a5fde24cc9498e34e087b8f571ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a> (unsigned bitNum, bool val)</td></tr>
<tr class="memdesc:a7ae5a5fde24cc9498e34e087b8f571ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit value. <br /></td></tr>
<tr class="separator:a7ae5a5fde24cc9498e34e087b8f571ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f33fe5ae1d8d13bc5e6ae7079b482e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a5f33fe5ae1d8d13bc5e6ae7079b482e2">setVersion</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4c4025c3b2b48ad52563d30031b4ceb5">VersionType</a> <a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>)</td></tr>
<tr class="memdesc:a5f33fe5ae1d8d13bc5e6ae7079b482e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of version update.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a5f33fe5ae1d8d13bc5e6ae7079b482e2">More...</a><br /></td></tr>
<tr class="separator:a5f33fe5ae1d8d13bc5e6ae7079b482e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaf97b8a6c3a581afef7a6e8a1f4414"><td class="memItemLeft" align="right" valign="top"><a id="a4aaf97b8a6c3a581afef7a6e8a1f4414"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4aaf97b8a6c3a581afef7a6e8a1f4414">valid</a> () const</td></tr>
<tr class="memdesc:a4aaf97b8a6c3a581afef7a6e8a1f4414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of the field value. <br /></td></tr>
<tr class="separator:a4aaf97b8a6c3a581afef7a6e8a1f4414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b6463c07245c8f9517914262053c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a36b6463c07245c8f9517914262053c09">value</a> ()</td></tr>
<tr class="memdesc:a36b6463c07245c8f9517914262053c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to underlying mask value storage.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a36b6463c07245c8f9517914262053c09">More...</a><br /></td></tr>
<tr class="separator:a36b6463c07245c8f9517914262053c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4767f2e098d0b96b8fcd902044ec9c51"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a> () const</td></tr>
<tr class="memdesc:a4767f2e098d0b96b8fcd902044ec9c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to underlying mask value storage.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">More...</a><br /></td></tr>
<tr class="separator:a4767f2e098d0b96b8fcd902044ec9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabbc8260c7887e1a6b1600ae9610a7c"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:aaabbc8260c7887e1a6b1600ae9610a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aaabbc8260c7887e1a6b1600ae9610a7c">write</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:aaabbc8260c7887e1a6b1600ae9610a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence.  <a href="classcomms_1_1field_1_1BitmaskValue.html#aaabbc8260c7887e1a6b1600ae9610a7c">More...</a><br /></td></tr>
<tr class="separator:aaabbc8260c7887e1a6b1600ae9610a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef773cacb1f7a7a30e8fbb50577cff31"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:aef773cacb1f7a7a30e8fbb50577cff31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aef773cacb1f7a7a30e8fbb50577cff31">writeNoStatus</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:aef773cacb1f7a7a30e8fbb50577cff31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1BitmaskValue.html#aef773cacb1f7a7a30e8fbb50577cff31">More...</a><br /></td></tr>
<tr class="separator:aef773cacb1f7a7a30e8fbb50577cff31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07c7bd49761eeb71e159d49818cd09f0"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">canWrite</a> ()</td></tr>
<tr class="memdesc:a07c7bd49761eeb71e159d49818cd09f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default check of whether the field has a consistent value for writing.  <a href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">More...</a><br /></td></tr>
<tr class="separator:a07c7bd49761eeb71e159d49818cd09f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed704e0f52fb23548d75180664600a9c"><td class="memItemLeft" align="right" valign="top"><a id="aed704e0f52fb23548d75180664600a9c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aed704e0f52fb23548d75180664600a9c">hasNonDefaultRefresh</a> ()</td></tr>
<tr class="memdesc:aed704e0f52fb23548d75180664600a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class has non-default refresh functionality. <br /></td></tr>
<tr class="separator:aed704e0f52fb23548d75180664600a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473ac96cdcd9e63fde31678691144abb"><td class="memItemLeft" align="right" valign="top"><a id="a473ac96cdcd9e63fde31678691144abb"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a473ac96cdcd9e63fde31678691144abb">hasReadNoStatus</a> ()</td></tr>
<tr class="memdesc:a473ac96cdcd9e63fde31678691144abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a5f9afe89747b4dff2c5f88be181f646f">readNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:a473ac96cdcd9e63fde31678691144abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f74185f8dcae83f9867fc0db967a8d9"><td class="memItemLeft" align="right" valign="top"><a id="a3f74185f8dcae83f9867fc0db967a8d9"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3f74185f8dcae83f9867fc0db967a8d9">hasWriteNoStatus</a> ()</td></tr>
<tr class="memdesc:a3f74185f8dcae83f9867fc0db967a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aef773cacb1f7a7a30e8fbb50577cff31">writeNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:a3f74185f8dcae83f9867fc0db967a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc69424e52be0f3218fc5d5b90542e"><td class="memItemLeft" align="right" valign="top"><a id="a44bc69424e52be0f3218fc5d5b90542e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a44bc69424e52be0f3218fc5d5b90542e">isVersionDependent</a> ()</td></tr>
<tr class="memdesc:a44bc69424e52be0f3218fc5d5b90542e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class is version dependent. <br /></td></tr>
<tr class="separator:a44bc69424e52be0f3218fc5d5b90542e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46ec0c561959e2a7473ed77068f63e8"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ac46ec0c561959e2a7473ed77068f63e8">maxLength</a> ()</td></tr>
<tr class="memdesc:ac46ec0c561959e2a7473ed77068f63e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise field of this type.  <a href="classcomms_1_1field_1_1BitmaskValue.html#ac46ec0c561959e2a7473ed77068f63e8">More...</a><br /></td></tr>
<tr class="separator:ac46ec0c561959e2a7473ed77068f63e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6514dc95fe4c0ca72b7cc93f133239a5"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a6514dc95fe4c0ca72b7cc93f133239a5">minLength</a> ()</td></tr>
<tr class="memdesc:a6514dc95fe4c0ca72b7cc93f133239a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise field of this type.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a6514dc95fe4c0ca72b7cc93f133239a5">More...</a><br /></td></tr>
<tr class="separator:a6514dc95fe4c0ca72b7cc93f133239a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7d5f9c7a7167869590974d46edf5d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">valid</a> ()</td></tr>
<tr class="memdesc:abbc7d5f9c7a7167869590974d46edf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default validity check.  <a href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">More...</a><br /></td></tr>
<tr class="separator:abbc7d5f9c7a7167869590974d46edf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a625b2614fc28507e11476c4dfa168cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input buffer.  <a href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">More...</a><br /></td></tr>
<tr class="separator:a625b2614fc28507e11476c4dfa168cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aa2fc07d0015fc88421311ac8c1a55868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input buffer.  <a href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">More...</a><br /></td></tr>
<tr class="separator:aa2fc07d0015fc88421311ac8c1a55868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output buffer.  <a href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">More...</a><br /></td></tr>
<tr class="separator:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output buffer.  <a href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">More...</a><br /></td></tr>
<tr class="separator:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad73b3130afa08a1155ac8b7e7ad915ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(...)&#160;&#160;&#160;COMMS_DEFINE_ENUM(BitIdx, __VA_ARGS__)</td></tr>
<tr class="memdesc:ad73b3130afa08a1155ac8b7e7ad915ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for bits in <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> field.  <a href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">More...</a><br /></td></tr>
<tr class="separator:ad73b3130afa08a1155ac8b7e7ad915ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0649d4ce913efb2b067ed2f33fdbce8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:a0649d4ce913efb2b067ed2f33fdbce8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate access functions for bits in <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> field.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">More...</a><br /></td></tr>
<tr class="separator:a0649d4ce913efb2b067ed2f33fdbce8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df004ba882635103d9e409c932412a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1">COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE</a>(...)&#160;&#160;&#160;COMMS_DO_BIT_ACC_FUNC((*this), __VA_ARGS__)</td></tr>
<tr class="memdesc:a3df004ba882635103d9e409c932412a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a>, but dedicated for non-template classes.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1">More...</a><br /></td></tr>
<tr class="separator:a3df004ba882635103d9e409c932412a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8a230b0b02d5e2bfc3a3c5a42e4f62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(...)</td></tr>
<tr class="memdesc:abe8a230b0b02d5e2bfc3a3c5a42e4f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine usage of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a>.  <a href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">More...</a><br /></td></tr>
<tr class="separator:abe8a230b0b02d5e2bfc3a3c5a42e4f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0008a7140153cb20e0ff6cd03be5dba3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE</a>(...)</td></tr>
<tr class="memdesc:a0008a7140153cb20e0ff6cd03be5dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a>, but dedicated for non-template classes.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">More...</a><br /></td></tr>
<tr class="separator:a0008a7140153cb20e0ff6cd03be5dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb05193bea781a2a378abcc96cef643"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cb05193bea781a2a378abcc96cef643"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a6cb05193bea781a2a378abcc96cef643">isBitmaskValue</a> ()</td></tr>
<tr class="memdesc:a6cb05193bea781a2a378abcc96cef643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a>.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a6cb05193bea781a2a378abcc96cef643">More...</a><br /></td></tr>
<tr class="separator:a6cb05193bea781a2a378abcc96cef643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6293c45acbb2c4a59c286ce56070340"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename... TOptions&gt; </td></tr>
<tr class="memitem:ab6293c45acbb2c4a59c286ce56070340"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ab6293c45acbb2c4a59c286ce56070340">operator!=</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:ab6293c45acbb2c4a59c286ce56070340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equality comparison operator.  <a href="classcomms_1_1field_1_1BitmaskValue.html#ab6293c45acbb2c4a59c286ce56070340">More...</a><br /></td></tr>
<tr class="separator:ab6293c45acbb2c4a59c286ce56070340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261d7162e9ed49e25f9a9b0b29afacc5"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename... TOptions&gt; </td></tr>
<tr class="memitem:a261d7162e9ed49e25f9a9b0b29afacc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a261d7162e9ed49e25f9a9b0b29afacc5">operator&lt;</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a261d7162e9ed49e25f9a9b0b29afacc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <a href="classcomms_1_1field_1_1BitmaskValue.html#a261d7162e9ed49e25f9a9b0b29afacc5">More...</a><br /></td></tr>
<tr class="separator:a261d7162e9ed49e25f9a9b0b29afacc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bbfe2c8af9e2f54189c420f08b86e4"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename... TOptions&gt; </td></tr>
<tr class="memitem:af2bbfe2c8af9e2f54189c420f08b86e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#af2bbfe2c8af9e2f54189c420f08b86e4">operator==</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:af2bbfe2c8af9e2f54189c420f08b86e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classcomms_1_1field_1_1BitmaskValue.html#af2bbfe2c8af9e2f54189c420f08b86e4">More...</a><br /></td></tr>
<tr class="separator:af2bbfe2c8af9e2f54189c420f08b86e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea6111b6586a7e00d5f7bb9a171f1db"><td class="memTemplParams" colspan="2"><a id="aeea6111b6586a7e00d5f7bb9a171f1db"></a>
template&lt;typename TFieldBase , typename... TOptions&gt; </td></tr>
<tr class="memitem:aeea6111b6586a7e00d5f7bb9a171f1db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aeea6111b6586a7e00d5f7bb9a171f1db">toFieldBase</a> (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:aeea6111b6586a7e00d5f7bb9a171f1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:aeea6111b6586a7e00d5f7bb9a171f1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96318041e0604f0ed0f109889a04b83f"><td class="memTemplParams" colspan="2"><a id="a96318041e0604f0ed0f109889a04b83f"></a>
template&lt;typename TFieldBase , typename... TOptions&gt; </td></tr>
<tr class="memitem:a96318041e0604f0ed0f109889a04b83f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a96318041e0604f0ed0f109889a04b83f">toFieldBase</a> (const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:a96318041e0604f0ed0f109889a04b83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a96318041e0604f0ed0f109889a04b83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3206c111ea8c0f208b46011aa86a5add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3206c111ea8c0f208b46011aa86a5add">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> =  typename <a class="el" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">IntValueField::ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of underlying integral value. </p>
<p>Unsigned integral type, which depends on the length of the mask determined by the <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a> option. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad49d22114335c0fe8c80a5fa5ad120b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49d22114335c0fe8c80a5fa5ad120b0">&#9670;&nbsp;</a></span>BitmaskValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial bitmask has all bits cleared (equals 0) </p>

</div>
</div>
<a id="aa552e2eee02c4876e05e9aad9b34c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa552e2eee02c4876e05e9aad9b34c3ec">&#9670;&nbsp;</a></span>BitmaskValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value of the field to initialise it with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a07c7bd49761eeb71e159d49818cd09f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c7bd49761eeb71e159d49818cd09f0">&#9670;&nbsp;</a></span>canWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::canWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default check of whether the field has a consistent value for writing. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>true</b>. </dd></dl>

</div>
</div>
<a id="a0ff5cdfab4b92448ce4a5bf0097921c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff5cdfab4b92448ce4a5bf0097921c5">&#9670;&nbsp;</a></span>clearBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::clearBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the provided bits. </p>
<p>Equivalent to</p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>() &amp;= (~mask); </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of bits to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a144137f34cf51bc42957919d52d98bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144137f34cf51bc42957919d52d98bfa">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4c4025c3b2b48ad52563d30031b4ceb5">VersionType</a> <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version of the field. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> option has been provided. </p>

</div>
</div>
<a id="af6ecda531caa8a9d53e6d7d8fa17836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ecda531caa8a9d53e6d7d8fa17836e">&#9670;&nbsp;</a></span>hasAllBitsSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::hasAllBitsSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether all bits from provided mask are set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case all the bits are set, false otherwise </dd></dl>

</div>
</div>
<a id="a9934aaa79c653de2845f354bdbfff1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9934aaa79c653de2845f354bdbfff1b4">&#9670;&nbsp;</a></span>hasAnyBitsSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::hasAnyBitsSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any bits from provided mask are set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case at least one of the bits is set, false otherwise. </dd></dl>

</div>
</div>
<a id="aae777fa79938d399944f4177896e82dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae777fa79938d399944f4177896e82dd">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get length required to serialise the current field value. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the field value. </dd></dl>

</div>
</div>
<a id="ac46ec0c561959e2a7473ed77068f63e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46ec0c561959e2a7473ed77068f63e8">&#9670;&nbsp;</a></span>maxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::maxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise field of this type. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximal number of bytes required serialise the field value. </dd></dl>

</div>
</div>
<a id="a6514dc95fe4c0ca72b7cc93f133239a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6514dc95fe4c0ca72b7cc93f133239a5">&#9670;&nbsp;</a></span>minLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::minLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise field of this type. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required serialise the field value. </dd></dl>

</div>
</div>
<a id="a14a748e7ff8ccb08cfc47948dacefd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a748e7ff8ccb08cfc47948dacefd8e">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a625b2614fc28507e11476c4dfa168cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625b2614fc28507e11476c4dfa168cf8">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa2fc07d0015fc88421311ac8c1a55868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc07d0015fc88421311ac8c1a55868">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a5f9afe89747b4dff2c5f88be181f646f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9afe89747b4dff2c5f88be181f646f">&#9670;&nbsp;</a></span>readNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::readNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a14a748e7ff8ccb08cfc47948dacefd8e">read()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a993aca85b9b0970916ef0c044e4da4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993aca85b9b0970916ef0c044e4da4ad">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh contents of the field. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the field's value has been updated, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="ac9116ee69aa6d1ed0551b360ac9d660c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9116ee69aa6d1ed0551b360ac9d660c">&#9670;&nbsp;</a></span>setBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::setBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all the provided bits. </p>
<p>Equivalent to</p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>() |= mask; </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of bits to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f33fe5ae1d8d13bc5e6ae7079b482e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f33fe5ae1d8d13bc5e6ae7079b482e2">&#9670;&nbsp;</a></span>setVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::setVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a4c4025c3b2b48ad52563d30031b4ceb5">VersionType</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of version update. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the field contents have changed, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="abbc7d5f9c7a7167869590974d46edf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7d5f9c7a7167869590974d46edf5d">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default validity check. </p>
<p>Always returns true, can be overriden by the derived class </p><dl class="section return"><dt>Returns</dt><dd>Always <b>true</b> </dd></dl>

</div>
</div>
<a id="a36b6463c07245c8f9517914262053c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b6463c07245c8f9517914262053c09">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&amp; <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to underlying mask value storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the underlying stored value. </dd></dl>

</div>
</div>
<a id="a4767f2e098d0b96b8fcd902044ec9c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4767f2e098d0b96b8fcd902044ec9c51">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3206c111ea8c0f208b46011aa86a5add">ValueType</a>&amp; <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to underlying mask value storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the underlying stored value. </dd></dl>

</div>
</div>
<a id="aaabbc8260c7887e1a6b1600ae9610a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabbc8260c7887e1a6b1600ae9610a7c">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a0bd63c4d88caa3e2c7ec36810f4ef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd63c4d88caa3e2c7ec36810f4ef480">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output buffer. </p>
<p>Use this function to write data to the the buffer maintained by the caller. The endianness of the data will be as specified in the options provided to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa03f444fd95e5ab123f8cdadd5f0a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03f444fd95e5ab123f8cdadd5f0a24a">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output buffer. </p>
<p>Use this function to write partial data to the buffer maintained by the caller. The endianness of the data will be as specified the class options. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aef773cacb1f7a7a30e8fbb50577cff31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef773cacb1f7a7a30e8fbb50577cff31">&#9670;&nbsp;</a></span>writeNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt; TFieldBase, TOptions &gt;::writeNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#aaabbc8260c7887e1a6b1600ae9610a7c">write()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad73b3130afa08a1155ac8b7e7ad915ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73b3130afa08a1155ac8b7e7ad915ee">&#9670;&nbsp;</a></span>COMMS_BITMASK_BITS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_BITMASK_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;COMMS_DEFINE_ENUM(BitIdx, __VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names for bits in <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> field. </p>
<p>Defines BitIdx enum with all the provided values prefixed with "BitIdx_". For example usage of </p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, second, third, fourth);</div>
</div><!-- fragment --><p> will generate the following enum type: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> BitIdx</div>
<div class="line">{</div>
<div class="line">    BitIdx_first,</div>
<div class="line">    BitIdx_second,</div>
<div class="line">    BitIdx_third,</div>
<div class="line">    BitIdx_fourth,</div>
<div class="line">    BitIdx_numOfValues</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>first</b>, <b>second</b>, <b>third</b>, and <b>fourth</b> have found their way to the enum <b>BitIdx</b>. <br  />
 Also note, that there is automatically added <b>BitIdx_nameOfValues</b> value to the end of <b>BitIdx</b> enum.</p>
<p>It is possible to assign values to the provided names. It could be useful when skipping some unused bits. For example </p><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first=1, third=3, fourth);</div>
</div><!-- fragment --><p> will generate the following enum type: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> BitIdx</div>
<div class="line">{</div>
<div class="line">    BitIdx_first=1,</div>
<div class="line">    BitIdx_third=3,</div>
<div class="line">    BitIdx_fourth,</div>
<div class="line">    BitIdx_numOfValues</div>
<div class="line">};</div>
</div><!-- fragment --><p>The macro <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee" title="Provide names for bits in comms::field::BitmaskValue field.">COMMS_BITMASK_BITS()</a> should be used inside definition of the bitmask field to provide names for the bits for external use: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, second, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Defined in "comms/field/BitmaskValue.h" </dd></dl>

</div>
</div>
<a id="a0649d4ce913efb2b067ed2f33fdbce8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0649d4ce913efb2b067ed2f33fdbce8b">&#9670;&nbsp;</a></span>COMMS_BITMASK_BITS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_BITMASK_BITS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_AS_BITMASK_FUNC { \</div>
<div class="line">        return <a class="code" href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a>(*<span class="keyword">this</span>); \</div>
<div class="line">    }\</div>
<div class="line">    COMMS_AS_BITMASK_CONST_FUNC { \</div>
<div class="line">        return <a class="code" href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a>(*<span class="keyword">this</span>); \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_DO_BIT_ACC_FUNC(asBitmask(), __VA_ARGS__)</div>
</div><!-- fragment -->
<p>Generate access functions for bits in <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a> field. </p>
<p>The <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> macro defines <b>BitIdx</b> enum to be able to access internal bits. However, an ability to provide values to the enumeration values using <b>=val</b> suffixes doesn't allow generation of convenience access functions to the bits. That's why <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b" title="Generate access functions for bits in comms::field::BitmaskValue field.">COMMS_BITMASK_BITS_ACCESS()</a> macro was introduced. For every name listed in the parameters list, <b>getBitValue_*</b>() and <b>setBitValue_*</b>() functions will be generated. For example, having the following definition </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(first, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --><p> is equivalent to having following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_first()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a>(BitIdx_first);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_first(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a>(BitIdx_first, <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_third()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a>(BitIdx_third);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_third(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a>(BitIdx_third, <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_fourth()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a>(BitIdx_fourth);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_fourth(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a>(BitIdx_fourth, <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b>, that generated <b>getBitValue_*</b>() and <b>setBitValue_*</b>() functions use <b>BitIdx_*</b> enum values generated by <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a>. It means that <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b" title="Generate access functions for bits in comms::field::BitmaskValue field.">COMMS_BITMASK_BITS_ACCESS()</a> macro can NOT be used without <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, third=2, fourth);</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(first, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>Must be used together with <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Some compilers, such as <b>clang</b> or early versions of <b>g++</b> may have problems compiling code generated by this macro even though it uses valid C++11 constructs in attempt to automatically identify the type of the base class. If the compilation fails, and this macro resides inside a <b>NON-template</b> class, please use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1">COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE()</a> macro instead. In case this macro needs to reside inside a <b>template</b> class, then there is a need to define inner <b>Base</b> type, which specifies exact type of the <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a> class. For example: <div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div>
<div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        comms::field::FixedLength&lt;1&gt;,</div>
<div class="line">        comms::field::BitmaskReservedBits&lt;0xf2, 0&gt;,</div>
<div class="line">        TExtraOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Duplicate definition of the base class</span></div>
<div class="line">    <span class="keyword">using</span> Base =</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            comms::field::FixedLength&lt;1&gt;,</div>
<div class="line">            scomms::field::BitmaskReservedBits&lt;0xf2, 0&gt;,</div>
<div class="line">            TExtraOptions...</div>
<div class="line">        &gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, third=2, fourth);</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(first, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/field/BitmaskValue.h" </dd></dl>

</div>
</div>
<a id="a3df004ba882635103d9e409c932412a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df004ba882635103d9e409c932412a1">&#9670;&nbsp;</a></span>COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;COMMS_DO_BIT_ACC_FUNC((*this), __VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a>, but dedicated for non-template classes. </p>
<p>The <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> macro is a generic one, which can be used in any class (template, or non-template). However, some compilers (such as <b>g++-4.9</b> and below, <b>clang-4.0</b> and below) may fail to compile it even though it uses valid C++11 constructs. If the compilation fails and the class it is being used in is <b>NOT</b> a template one, please use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1">COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE()</a> instead. </p>

</div>
</div>
<a id="abe8a230b0b02d5e2bfc3a3c5a42e4f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8a230b0b02d5e2bfc3a3c5a42e4f62">&#9670;&nbsp;</a></span>COMMS_BITMASK_BITS_SEQ</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_BITMASK_BITS_SEQ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(__VA_ARGS__) \</div>
<div class="line">    COMMS_BITMASK_BITS_ACCESS(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Combine usage of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a>. </p>
<p>When assigned bit names start at bit 0 and go sequentially without any gaps in the middle, i.e. don't have any <b>=val</b> suffixes, then use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62" title="Combine usage of COMMS_BITMASK_BITS() and COMMS_BITMASK_BITS_ACCESS().">COMMS_BITMASK_BITS_SEQ()</a> macro to name the bits. It is defined to use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> with the same bit names. For example </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(first, second, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --><p> is equivalent to having </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> BitIdx</div>
<div class="line">    {</div>
<div class="line">        BitIdx_first,</div>
<div class="line">        BitIdx_second,</div>
<div class="line">        BitIdx_third,</div>
<div class="line">        BitIdx_fourth,</div>
<div class="line">        BitIdx_numOfValues</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_first()<span class="keyword"> const </span>{...}</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_first(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {...}</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_second()<span class="keyword"> const </span>{...}</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_second(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {...}</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_third()<span class="keyword"> const </span>{...}</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_third(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {...}</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_fourth()<span class="keyword"> const </span>{...}</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_fourth(<span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">value</a>) {...}</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Some compilers, such as <b>clang</b> or early versions of <b>g++</b> may have problems compiling code generated by this macro even though it uses valid C++11 constructs in attempt to automatically identify the type of the base class. If the compilation fails, and this macro resides inside a <b>NON-template</b> class, please use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE()</a> macro instead. In case this macro needs to reside inside a <b>template</b> class, then there is a need to define inner <b>Base</b> type, which specifies exact type of the <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a> class. For example: <div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div>
<div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        comms::field::FixedLength&lt;1&gt;,</div>
<div class="line">        comms::field::BitmaskReservedBits&lt;0xf0, 0&gt;,</div>
<div class="line">        TExtraOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Duplicate definition of the base class</span></div>
<div class="line">    <span class="keyword">using</span> Base =</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            comms::field::FixedLength&lt;1&gt;,</div>
<div class="line">            scomms::field::BitmaskReservedBits&lt;0xf0, 0&gt;,</div>
<div class="line">            TExtraOptions...</div>
<div class="line">        &gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(first, second, third, fourth);</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/field/BitmaskValue.h" </dd></dl>

</div>
</div>
<a id="a0008a7140153cb20e0ff6cd03be5dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0008a7140153cb20e0ff6cd03be5dba3">&#9670;&nbsp;</a></span>COMMS_BITMASK_BITS_SEQ_NOTEMPLATE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_BITMASK_BITS_SEQ_NOTEMPLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(__VA_ARGS__) \</div>
<div class="line">    COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Similar to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a>, but dedicated for non-template classes. </p>
<p>The <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a> macro is a generic one, which can be used in any class (template, or non-template). However, some compilers (such as <b>g++-4.9</b> and below, <b>clang-4.0</b> and below) may fail to compile it even though it uses valid C++11 constructs. If the compilation fails and the class it is being used in is <b>NOT</b> a template one, please use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/field/BitmaskValue.h" </dd></dl>

</div>
</div>
<a id="a6cb05193bea781a2a378abcc96cef643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb05193bea781a2a378abcc96cef643">&#9670;&nbsp;</a></span>isBitmaskValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool isBitmaskValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field.">comms::field::BitmaskValue</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case provided type is any variant of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a> </dd></dl>

</div>
</div>
<a id="ab6293c45acbb2c4a59c286ce56070340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6293c45acbb2c4a59c286ce56070340">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are NOT equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a261d7162e9ed49e25f9a9b0b29afacc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261d7162e9ed49e25f9a9b0b29afacc5">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case value of the first field is lower than than the value of the second. </dd></dl>

</div>
</div>
<a id="af2bbfe2c8af9e2f54189c420f08b86e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bbfe2c8af9e2f54189c420f08b86e4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">BitmaskValue</a>&lt; TFieldBase, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are equal, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/field/<a class="el" href="BitmaskValue_8h_source.html">BitmaskValue.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_abe8a230b0b02d5e2bfc3a3c5a42e4f62"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">comms::field::BitmaskValue::COMMS_BITMASK_BITS_SEQ</a></div><div class="ttdeci">#define COMMS_BITMASK_BITS_SEQ(...)</div><div class="ttdoc">Combine usage of COMMS_BITMASK_BITS() and COMMS_BITMASK_BITS_ACCESS().</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:705</div></div>
<div class="ttc" id="anamespacecomms_1_1field_html_a9127363faf239beb7a9d44afc5c5665f"><div class="ttname"><a href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a></div><div class="ttdeci">Bundle&lt; TFieldBase, TMembers, TOptions... &gt; &amp; toFieldBase(Bundle&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field)</div><div class="ttdoc">Upcast type of the field definition to its parent comms::field::Bundle type in order to have access t...</div><div class="ttdef"><b>Definition:</b> Bundle.h:756</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a4767f2e098d0b96b8fcd902044ec9c51"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a4767f2e098d0b96b8fcd902044ec9c51">comms::field::BitmaskValue::value</a></div><div class="ttdeci">const ValueType &amp; value() const</div><div class="ttdoc">Get access to underlying mask value storage.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:157</div></div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition:</b> Field.h:32</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a0649d4ce913efb2b067ed2f33fdbce8b"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">comms::field::BitmaskValue::COMMS_BITMASK_BITS_ACCESS</a></div><div class="ttdeci">#define COMMS_BITMASK_BITS_ACCESS(...)</div><div class="ttdoc">Generate access functions for bits in comms::field::BitmaskValue field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:613</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1EnumValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a></div><div class="ttdoc">Enumerator value field.</div><div class="ttdef"><b>Definition:</b> EnumValue.h:73</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a></div><div class="ttdoc">Bitmask value field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:101</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a3ba03ea117a584dafb99e27e47ee8819"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">comms::field::BitmaskValue::getBitValue</a></div><div class="ttdeci">bool getBitValue(unsigned bitNum) const</div><div class="ttdoc">Get bit value.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:300</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a7ae5a5fde24cc9498e34e087b8f571ea"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">comms::field::BitmaskValue::setBitValue</a></div><div class="ttdeci">void setBitValue(unsigned bitNum, bool val)</div><div class="ttdoc">Set bit value.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:307</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_ad73b3130afa08a1155ac8b7e7ad915ee"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">comms::field::BitmaskValue::COMMS_BITMASK_BITS</a></div><div class="ttdeci">#define COMMS_BITMASK_BITS(...)</div><div class="ttdoc">Provide names for bits in comms::field::BitmaskValue field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:519</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
