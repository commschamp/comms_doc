<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::field::Bundle&lt; TFieldBase, TMembers, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1field.html">field</a></li><li class="navelem"><a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1field_1_1Bundle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::field::Bundle&lt; TFieldBase, TMembers, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="Bundle_8h_source.html">comms/field/Bundle.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TFieldBase, typename TMembers, typename... TOptions&gt;<br />
class comms::field::Bundle&lt; TFieldBase, TMembers, TOptions &gt;</h3>

<p>Bundles multiple fields into a single field. </p>
<p>The class wraps nicely multiple fields and provides expected single field API functions, such as <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2" title="Get length required to serialise bundled fields.">length()</a>, <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a>, <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5" title="Write current field value to output data sequence.">write()</a>, <a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d" title="Default validity check.">valid()</a>. It may be useful when a collection (<a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a>) of complex fields is required.</p>
<p>Refer to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bundle">Bundle Fields</a> for tutorial and usage examples. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFieldBase</td><td>Base class for this field, expected to be a variant of <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">comms::Field</a>. </td></tr>
    <tr><td class="paramname">TMembers</td><td>All wrapped fields bundled together in <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Zero or more options that modify/refine default behaviour of the field.<br  />
 Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a> - All wrapped fields may specify their independent default value initialisers. It is also possible to provide initialiser for the <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field.">Bundle</a> field which will set appropriate values to the fields based on some internal logic. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a> - All wrapped fields may specify their independent validators. The bundle field considered to be valid if all the wrapped fields are valid. This option though, provides an ability to add extra validation logic that can observe value of more than one wrapped fields. For example, protocol specifies that if one specific field has value X, than other field is NOT allowed to have value Y. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsRefresher.html">comms::option::def::ContentsRefresher</a> - The default refreshing behaviour is to call the <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#af80c2f4e7c0283dbaf730451757a8ad8" title="Refresh the field&#39;s contents.">refresh()</a></b> member function of every member field. This option provides an ability to set a custom "refreshing" logic. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1CustomValueReader.html">comms::option::def::CustomValueReader</a> - It may be required to implement custom reading functionality instead of default behaviour of invoking <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a> member function of every member field. It is possible to provide cusom reader functionality using <a class="el" href="structcomms_1_1option_1_1def_1_1CustomValueReader.html">comms::option::def::CustomValueReader</a> option. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1RemLengthMemberField.html">comms::option::def::RemLengthMemberField</a> - Specify index of member field that contains remaining length information for all the subsequent fields. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRead.html">comms::option::def::HasCustomRead</a> - Mark field to have custom read functionality </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> - Mark field to have custom refresh functionality. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> - Force empty serialization. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> - Add version storage.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> </dd>
<dd>
<a class="el" href="Field_8h.html#a96226a2c000a3145a48ce074b6a7f847">COMMS_FIELD_MEMBERS_ACCESS()</a> </dd>
<dd>
<a class="el" href="Field_8h.html#a83dcd24efc7be6d3a95eadfb259a6b33">COMMS_FIELD_MEMBERS_ACCESS_NOTEMPLATE()</a> </dd>
<dd>
<a class="el" href="Field_8h.html#a7adc16bdcc59b3f0a646c106816c9cab">COMMS_FIELD_ALIAS()</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::field::Bundle&lt; TFieldBase, TMembers, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1field_1_1Bundle.png" usemap="#comms::field::Bundle_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::field::Bundle_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map" name="comms::field::Bundle_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1Field.html" title="Base class to all the field classes." alt="comms::Field&lt; TOptions &gt;" shape="rect" coords="0,0,339,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a30769880ed1ea3c86d5d47c220efea0d"><td class="memItemLeft" align="right" valign="top"><a id="a30769880ed1ea3c86d5d47c220efea0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a30769880ed1ea3c86d5d47c220efea0d">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a30769880ed1ea3c86d5d47c220efea0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endian used for serialisation. <br /></td></tr>
<tr class="separator:a30769880ed1ea3c86d5d47c220efea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726dab5fd8188765dd6d31f31da17210"><td class="memItemLeft" align="right" valign="top"><a id="a726dab5fd8188765dd6d31f31da17210"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a726dab5fd8188765dd6d31f31da17210">FieldBase</a> = TFieldBase</td></tr>
<tr class="memdesc:a726dab5fd8188765dd6d31f31da17210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class provided in the first template parameter. <br /></td></tr>
<tr class="separator:a726dab5fd8188765dd6d31f31da17210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab531bda1202e4d5fff36c6d4d9fed590"><td class="memItemLeft" align="right" valign="top"><a id="ab531bda1202e4d5fff36c6d4d9fed590"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ab531bda1202e4d5fff36c6d4d9fed590">ParsedOptions</a> = details::OptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:ab531bda1202e4d5fff36c6d4d9fed590"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:ab531bda1202e4d5fff36c6d4d9fed590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abec16cef72318ca936f94c47c60ddb"><td class="memItemLeft" align="right" valign="top"><a id="a9abec16cef72318ca936f94c47c60ddb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a9abec16cef72318ca936f94c47c60ddb">Tag</a> = tag::Bundle</td></tr>
<tr class="memdesc:a9abec16cef72318ca936f94c47c60ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating type of the field. <br /></td></tr>
<tr class="separator:a9abec16cef72318ca936f94c47c60ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f1e820818de256ae61bdb052500a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> = typename BaseImpl::ValueType</td></tr>
<tr class="memdesc:a223f1e820818de256ae61bdb052500a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <a href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">More...</a><br /></td></tr>
<tr class="separator:a223f1e820818de256ae61bdb052500a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f87592dfc9002fd5baac48fa874c67"><td class="memItemLeft" align="right" valign="top"><a id="af5f87592dfc9002fd5baac48fa874c67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#af5f87592dfc9002fd5baac48fa874c67">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:af5f87592dfc9002fd5baac48fa874c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version type. <br /></td></tr>
<tr class="separator:af5f87592dfc9002fd5baac48fa874c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d92cbd0d7e192109edb5ce861507e93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1d92cbd0d7e192109edb5ce861507e93">Bundle</a> ()=default</td></tr>
<tr class="memdesc:a1d92cbd0d7e192109edb5ce861507e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcomms_1_1field_1_1Bundle.html#a1d92cbd0d7e192109edb5ce861507e93">More...</a><br /></td></tr>
<tr class="separator:a1d92cbd0d7e192109edb5ce861507e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c24185396c16efe9a3c2d8db3f931d9"><td class="memItemLeft" align="right" valign="top"><a id="a2c24185396c16efe9a3c2d8db3f931d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a2c24185396c16efe9a3c2d8db3f931d9">Bundle</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:a2c24185396c16efe9a3c2d8db3f931d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a2c24185396c16efe9a3c2d8db3f931d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb6b2eade887be4b3ebc477412197d9"><td class="memItemLeft" align="right" valign="top"><a id="aaeb6b2eade887be4b3ebc477412197d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aaeb6b2eade887be4b3ebc477412197d9">Bundle</a> (<a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:aaeb6b2eade887be4b3ebc477412197d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aaeb6b2eade887be4b3ebc477412197d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5afd4bc0aa17f2e72b2ce1b4b3f90fd"><td class="memItemLeft" align="right" valign="top"><a id="aa5afd4bc0aa17f2e72b2ce1b4b3f90fd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aa5afd4bc0aa17f2e72b2ce1b4b3f90fd">canWrite</a> () const</td></tr>
<tr class="memdesc:aa5afd4bc0aa17f2e72b2ce1b4b3f90fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of whether the field has a consistent value for writing. <br /></td></tr>
<tr class="separator:aa5afd4bc0aa17f2e72b2ce1b4b3f90fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3823038c978a293eea21583ca49e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1Bundle.html#af5f87592dfc9002fd5baac48fa874c67">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a8f3823038c978a293eea21583ca49e8a">getVersion</a> () const</td></tr>
<tr class="memdesc:a8f3823038c978a293eea21583ca49e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version of the field.  <a href="classcomms_1_1field_1_1Bundle.html#a8f3823038c978a293eea21583ca49e8a">More...</a><br /></td></tr>
<tr class="separator:a8f3823038c978a293eea21583ca49e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab26767c780631c6d2ab21ee31cbdd2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2">length</a> () const</td></tr>
<tr class="memdesc:a1ab26767c780631c6d2ab21ee31cbdd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2">More...</a><br /></td></tr>
<tr class="separator:a1ab26767c780631c6d2ab21ee31cbdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79f3356d35185999d12f7c17833703"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:a3d79f3356d35185999d12f7c17833703"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a3d79f3356d35185999d12f7c17833703">lengthFrom</a> () const</td></tr>
<tr class="memdesc:a3d79f3356d35185999d12f7c17833703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise specified bundled member fields.  <a href="classcomms_1_1field_1_1Bundle.html#a3d79f3356d35185999d12f7c17833703">More...</a><br /></td></tr>
<tr class="separator:a3d79f3356d35185999d12f7c17833703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b17a0fcb6d9dbc3815cf697f1c21e"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:ade9b17a0fcb6d9dbc3815cf697f1c21e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ade9b17a0fcb6d9dbc3815cf697f1c21e">lengthFromUntil</a> () const</td></tr>
<tr class="memdesc:ade9b17a0fcb6d9dbc3815cf697f1c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise specified bundled member fields.  <a href="classcomms_1_1field_1_1Bundle.html#ade9b17a0fcb6d9dbc3815cf697f1c21e">More...</a><br /></td></tr>
<tr class="separator:ade9b17a0fcb6d9dbc3815cf697f1c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2627a0221cf2ac3cc1a52d7aa3dce8a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:aa2627a0221cf2ac3cc1a52d7aa3dce8a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aa2627a0221cf2ac3cc1a52d7aa3dce8a">lengthUntil</a> () const</td></tr>
<tr class="memdesc:aa2627a0221cf2ac3cc1a52d7aa3dce8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise specified bundled member fields.  <a href="classcomms_1_1field_1_1Bundle.html#aa2627a0221cf2ac3cc1a52d7aa3dce8a">More...</a><br /></td></tr>
<tr class="separator:aa2627a0221cf2ac3cc1a52d7aa3dce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e516723465cdd9123ae4cde775e89e4"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a9e516723465cdd9123ae4cde775e89e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read</a> (TIter &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:a9e516723465cdd9123ae4cde775e89e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence.  <a href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">More...</a><br /></td></tr>
<tr class="separator:a9e516723465cdd9123ae4cde775e89e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1625733923ab6994747cf14f2a350872"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a1625733923ab6994747cf14f2a350872"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1625733923ab6994747cf14f2a350872">readFrom</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a1625733923ab6994747cf14f2a350872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (from specified index).  <a href="classcomms_1_1field_1_1Bundle.html#a1625733923ab6994747cf14f2a350872">More...</a><br /></td></tr>
<tr class="separator:a1625733923ab6994747cf14f2a350872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2775508ee526810fcdec29a2c3998d"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, typename TIter &gt; </td></tr>
<tr class="memitem:add2775508ee526810fcdec29a2c3998d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#add2775508ee526810fcdec29a2c3998d">readFromAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:add2775508ee526810fcdec29a2c3998d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (from specified index) while updating remaining length information.  <a href="classcomms_1_1field_1_1Bundle.html#add2775508ee526810fcdec29a2c3998d">More...</a><br /></td></tr>
<tr class="separator:add2775508ee526810fcdec29a2c3998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad425f08942ea228a015b536f3efacd28"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ad425f08942ea228a015b536f3efacd28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ad425f08942ea228a015b536f3efacd28">readFromNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:ad425f08942ea228a015b536f3efacd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected member fields from input data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#ad425f08942ea228a015b536f3efacd28">More...</a><br /></td></tr>
<tr class="separator:ad425f08942ea228a015b536f3efacd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb61a1129588cd0247b889ec0c563be6"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:adb61a1129588cd0247b889ec0c563be6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#adb61a1129588cd0247b889ec0c563be6">readFromUntil</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:adb61a1129588cd0247b889ec0c563be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (between specified indices).  <a href="classcomms_1_1field_1_1Bundle.html#adb61a1129588cd0247b889ec0c563be6">More...</a><br /></td></tr>
<tr class="separator:adb61a1129588cd0247b889ec0c563be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64a4a144f9fc7d2b03842eba8ba4ff"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:adc64a4a144f9fc7d2b03842eba8ba4ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#adc64a4a144f9fc7d2b03842eba8ba4ff">readFromUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:adc64a4a144f9fc7d2b03842eba8ba4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (between specified indices) while updating remaining length information.  <a href="classcomms_1_1field_1_1Bundle.html#adc64a4a144f9fc7d2b03842eba8ba4ff">More...</a><br /></td></tr>
<tr class="separator:adc64a4a144f9fc7d2b03842eba8ba4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3626275a7e4e72b433f217a83f79cf45"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a3626275a7e4e72b433f217a83f79cf45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a3626275a7e4e72b433f217a83f79cf45">readFromUntilNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a3626275a7e4e72b433f217a83f79cf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected member fields from input data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#a3626275a7e4e72b433f217a83f79cf45">More...</a><br /></td></tr>
<tr class="separator:a3626275a7e4e72b433f217a83f79cf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538e00d8995223f48757f01953a0b664"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a538e00d8995223f48757f01953a0b664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">readNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a538e00d8995223f48757f01953a0b664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">More...</a><br /></td></tr>
<tr class="separator:a538e00d8995223f48757f01953a0b664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02b27872db689a00dc875b72fe25b1"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a1b02b27872db689a00dc875b72fe25b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1b02b27872db689a00dc875b72fe25b1">readUntil</a> (TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a1b02b27872db689a00dc875b72fe25b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (until specified index).  <a href="classcomms_1_1field_1_1Bundle.html#a1b02b27872db689a00dc875b72fe25b1">More...</a><br /></td></tr>
<tr class="separator:a1b02b27872db689a00dc875b72fe25b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e91d0694ccebdfb1f727b2463fca9"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ad50e91d0694ccebdfb1f727b2463fca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ad50e91d0694ccebdfb1f727b2463fca9">readUntilAndUpdateLen</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ad50e91d0694ccebdfb1f727b2463fca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected number of member fields (until specified index) while updating remaining length information.  <a href="classcomms_1_1field_1_1Bundle.html#ad50e91d0694ccebdfb1f727b2463fca9">More...</a><br /></td></tr>
<tr class="separator:ad50e91d0694ccebdfb1f727b2463fca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794b67b2061cb8e354f02a3f12c1b625"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a794b67b2061cb8e354f02a3f12c1b625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a794b67b2061cb8e354f02a3f12c1b625">readUntilNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a794b67b2061cb8e354f02a3f12c1b625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read selected member fields from input data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#a794b67b2061cb8e354f02a3f12c1b625">More...</a><br /></td></tr>
<tr class="separator:a794b67b2061cb8e354f02a3f12c1b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80c2f4e7c0283dbaf730451757a8ad8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#af80c2f4e7c0283dbaf730451757a8ad8">refresh</a> ()</td></tr>
<tr class="memdesc:af80c2f4e7c0283dbaf730451757a8ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the field's contents.  <a href="classcomms_1_1field_1_1Bundle.html#af80c2f4e7c0283dbaf730451757a8ad8">More...</a><br /></td></tr>
<tr class="separator:af80c2f4e7c0283dbaf730451757a8ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5af1df902a21e27fb1b6c0c2fab27b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac5af1df902a21e27fb1b6c0c2fab27b2">setVersion</a> (<a class="el" href="classcomms_1_1field_1_1Bundle.html#af5f87592dfc9002fd5baac48fa874c67">VersionType</a> <a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>)</td></tr>
<tr class="memdesc:ac5af1df902a21e27fb1b6c0c2fab27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of version update.  <a href="classcomms_1_1field_1_1Bundle.html#ac5af1df902a21e27fb1b6c0c2fab27b2">More...</a><br /></td></tr>
<tr class="separator:ac5af1df902a21e27fb1b6c0c2fab27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae577d21ecf4e6b9d0710c6e579891f"><td class="memItemLeft" align="right" valign="top"><a id="aaae577d21ecf4e6b9d0710c6e579891f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aaae577d21ecf4e6b9d0710c6e579891f">valid</a> () const</td></tr>
<tr class="memdesc:aaae577d21ecf4e6b9d0710c6e579891f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of all the bundled fields. <br /></td></tr>
<tr class="separator:aaae577d21ecf4e6b9d0710c6e579891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca6bbe6991d32eda3f539d58876aa2b"><td class="memItemLeft" align="right" valign="top"><a id="abca6bbe6991d32eda3f539d58876aa2b"></a>
<a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a> ()</td></tr>
<tr class="memdesc:abca6bbe6991d32eda3f539d58876aa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the stored tuple of fields. <br /></td></tr>
<tr class="separator:abca6bbe6991d32eda3f539d58876aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3d32372cc0e11d3b74900d465b4a6a"><td class="memItemLeft" align="right" valign="top"><a id="abc3d32372cc0e11d3b74900d465b4a6a"></a>
const <a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#abc3d32372cc0e11d3b74900d465b4a6a">value</a> () const</td></tr>
<tr class="memdesc:abc3d32372cc0e11d3b74900d465b4a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the stored tuple of fields. <br /></td></tr>
<tr class="separator:abc3d32372cc0e11d3b74900d465b4a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f67eb58a758643e5a3d1ae12429ef5"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a70f67eb58a758643e5a3d1ae12429ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a70f67eb58a758643e5a3d1ae12429ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence.  <a href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">More...</a><br /></td></tr>
<tr class="separator:a70f67eb58a758643e5a3d1ae12429ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9a610b77ecc2c81b216229d3e0f93e"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, typename TIter &gt; </td></tr>
<tr class="memitem:acc9a610b77ecc2c81b216229d3e0f93e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#acc9a610b77ecc2c81b216229d3e0f93e">writeFrom</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:acc9a610b77ecc2c81b216229d3e0f93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence.  <a href="classcomms_1_1field_1_1Bundle.html#acc9a610b77ecc2c81b216229d3e0f93e">More...</a><br /></td></tr>
<tr class="separator:acc9a610b77ecc2c81b216229d3e0f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30fc3e16a5905695fd83aee2c1f5d3a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ac30fc3e16a5905695fd83aee2c1f5d3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac30fc3e16a5905695fd83aee2c1f5d3a">writeFromNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:ac30fc3e16a5905695fd83aee2c1f5d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#ac30fc3e16a5905695fd83aee2c1f5d3a">More...</a><br /></td></tr>
<tr class="separator:ac30fc3e16a5905695fd83aee2c1f5d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff4f155e990db0c61e6385af4ccbc1e"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a7ff4f155e990db0c61e6385af4ccbc1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a7ff4f155e990db0c61e6385af4ccbc1e">writeFromUntil</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a7ff4f155e990db0c61e6385af4ccbc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence.  <a href="classcomms_1_1field_1_1Bundle.html#a7ff4f155e990db0c61e6385af4ccbc1e">More...</a><br /></td></tr>
<tr class="separator:a7ff4f155e990db0c61e6385af4ccbc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d820c7bddb44e76c7b47dae63448258"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:a6d820c7bddb44e76c7b47dae63448258"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a6d820c7bddb44e76c7b47dae63448258">writeFromUntilNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a6d820c7bddb44e76c7b47dae63448258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#a6d820c7bddb44e76c7b47dae63448258">More...</a><br /></td></tr>
<tr class="separator:a6d820c7bddb44e76c7b47dae63448258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d32749b85c4110210e92f524cb71a7"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:ac4d32749b85c4110210e92f524cb71a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">writeNoStatus</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:ac4d32749b85c4110210e92f524cb71a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">More...</a><br /></td></tr>
<tr class="separator:ac4d32749b85c4110210e92f524cb71a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababcf65ddda0e2a662d5f7e953f9c13c"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:ababcf65ddda0e2a662d5f7e953f9c13c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ababcf65ddda0e2a662d5f7e953f9c13c">writeUntil</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:ababcf65ddda0e2a662d5f7e953f9c13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence.  <a href="classcomms_1_1field_1_1Bundle.html#ababcf65ddda0e2a662d5f7e953f9c13c">More...</a><br /></td></tr>
<tr class="separator:ababcf65ddda0e2a662d5f7e953f9c13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabe422e19bfd31ff2b60d5722418bc9"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx, typename TIter &gt; </td></tr>
<tr class="memitem:aeabe422e19bfd31ff2b60d5722418bc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aeabe422e19bfd31ff2b60d5722418bc9">writeUntilNoStatus</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aeabe422e19bfd31ff2b60d5722418bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write selected member fields to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Bundle.html#aeabe422e19bfd31ff2b60d5722418bc9">More...</a><br /></td></tr>
<tr class="separator:aeabe422e19bfd31ff2b60d5722418bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07c7bd49761eeb71e159d49818cd09f0"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">canWrite</a> ()</td></tr>
<tr class="memdesc:a07c7bd49761eeb71e159d49818cd09f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default check of whether the field has a consistent value for writing.  <a href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">More...</a><br /></td></tr>
<tr class="separator:a07c7bd49761eeb71e159d49818cd09f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1769512965ac9bb261d6e5defd122c08"><td class="memItemLeft" align="right" valign="top"><a id="a1769512965ac9bb261d6e5defd122c08"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1769512965ac9bb261d6e5defd122c08">hasNonDefaultRefresh</a> ()</td></tr>
<tr class="memdesc:a1769512965ac9bb261d6e5defd122c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class has non-default refresh functionality. <br /></td></tr>
<tr class="separator:a1769512965ac9bb261d6e5defd122c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c9372e8db7287d77d35ea7adb8a6ae"><td class="memItemLeft" align="right" valign="top"><a id="ad9c9372e8db7287d77d35ea7adb8a6ae"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ad9c9372e8db7287d77d35ea7adb8a6ae">hasReadNoStatus</a> ()</td></tr>
<tr class="memdesc:ad9c9372e8db7287d77d35ea7adb8a6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">readNoStatus()</a> member function (or similar). <br /></td></tr>
<tr class="separator:ad9c9372e8db7287d77d35ea7adb8a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798f9235cc06ddb6ba2f097d49843925"><td class="memItemLeft" align="right" valign="top"><a id="a798f9235cc06ddb6ba2f097d49843925"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a798f9235cc06ddb6ba2f097d49843925">hasWriteNoStatus</a> ()</td></tr>
<tr class="memdesc:a798f9235cc06ddb6ba2f097d49843925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">writeNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:a798f9235cc06ddb6ba2f097d49843925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7c40b2a34b5dce49e15ab7bae085f9"><td class="memItemLeft" align="right" valign="top"><a id="aaf7c40b2a34b5dce49e15ab7bae085f9"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aaf7c40b2a34b5dce49e15ab7bae085f9">isVersionDependent</a> ()</td></tr>
<tr class="memdesc:aaf7c40b2a34b5dce49e15ab7bae085f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class is version dependent. <br /></td></tr>
<tr class="separator:aaf7c40b2a34b5dce49e15ab7bae085f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb5f46fae620123f76c09dbea9ea7e"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a23cb5f46fae620123f76c09dbea9ea7e">maxLength</a> ()</td></tr>
<tr class="memdesc:a23cb5f46fae620123f76c09dbea9ea7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise all bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a23cb5f46fae620123f76c09dbea9ea7e">More...</a><br /></td></tr>
<tr class="separator:a23cb5f46fae620123f76c09dbea9ea7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56df30a9eeccaaaa8e372ead1132ac2e"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:a56df30a9eeccaaaa8e372ead1132ac2e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a56df30a9eeccaaaa8e372ead1132ac2e">maxLengthFrom</a> ()</td></tr>
<tr class="memdesc:a56df30a9eeccaaaa8e372ead1132ac2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a56df30a9eeccaaaa8e372ead1132ac2e">More...</a><br /></td></tr>
<tr class="separator:a56df30a9eeccaaaa8e372ead1132ac2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4ef0849e41a4b1691d0870b8eecd3e"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:a0c4ef0849e41a4b1691d0870b8eecd3e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a0c4ef0849e41a4b1691d0870b8eecd3e">maxLengthFromUntil</a> ()</td></tr>
<tr class="memdesc:a0c4ef0849e41a4b1691d0870b8eecd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a0c4ef0849e41a4b1691d0870b8eecd3e">More...</a><br /></td></tr>
<tr class="separator:a0c4ef0849e41a4b1691d0870b8eecd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d61007dac433de40cd11b38e1d89b"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:a845d61007dac433de40cd11b38e1d89b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a845d61007dac433de40cd11b38e1d89b">maxLengthUntil</a> ()</td></tr>
<tr class="memdesc:a845d61007dac433de40cd11b38e1d89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a845d61007dac433de40cd11b38e1d89b">More...</a><br /></td></tr>
<tr class="separator:a845d61007dac433de40cd11b38e1d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23047e4e5b89a290913f790de1b4f55a"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a23047e4e5b89a290913f790de1b4f55a">minLength</a> ()</td></tr>
<tr class="memdesc:a23047e4e5b89a290913f790de1b4f55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise all bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a23047e4e5b89a290913f790de1b4f55a">More...</a><br /></td></tr>
<tr class="separator:a23047e4e5b89a290913f790de1b4f55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f3d67984e46fd4b25802f9a29c9a4f"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx&gt; </td></tr>
<tr class="memitem:a43f3d67984e46fd4b25802f9a29c9a4f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a43f3d67984e46fd4b25802f9a29c9a4f">minLengthFrom</a> ()</td></tr>
<tr class="memdesc:a43f3d67984e46fd4b25802f9a29c9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#a43f3d67984e46fd4b25802f9a29c9a4f">More...</a><br /></td></tr>
<tr class="separator:a43f3d67984e46fd4b25802f9a29c9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad476848ad3a1d72dcd8500fec24413cb"><td class="memTemplParams" colspan="2">template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:ad476848ad3a1d72dcd8500fec24413cb"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ad476848ad3a1d72dcd8500fec24413cb">minLengthFromUntil</a> ()</td></tr>
<tr class="memdesc:ad476848ad3a1d72dcd8500fec24413cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#ad476848ad3a1d72dcd8500fec24413cb">More...</a><br /></td></tr>
<tr class="separator:ad476848ad3a1d72dcd8500fec24413cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045e15f74295825493052a9b51fca48"><td class="memTemplParams" colspan="2">template&lt;std::size_t TUntilIdx&gt; </td></tr>
<tr class="memitem:ab045e15f74295825493052a9b51fca48"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#ab045e15f74295825493052a9b51fca48">minLengthUntil</a> ()</td></tr>
<tr class="memdesc:ab045e15f74295825493052a9b51fca48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise specified bundled fields.  <a href="classcomms_1_1field_1_1Bundle.html#ab045e15f74295825493052a9b51fca48">More...</a><br /></td></tr>
<tr class="separator:ab045e15f74295825493052a9b51fca48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7d5f9c7a7167869590974d46edf5d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">valid</a> ()</td></tr>
<tr class="memdesc:abbc7d5f9c7a7167869590974d46edf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default validity check.  <a href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">More...</a><br /></td></tr>
<tr class="separator:abbc7d5f9c7a7167869590974d46edf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a625b2614fc28507e11476c4dfa168cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input buffer.  <a href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">More...</a><br /></td></tr>
<tr class="separator:a625b2614fc28507e11476c4dfa168cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aa2fc07d0015fc88421311ac8c1a55868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input buffer.  <a href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">More...</a><br /></td></tr>
<tr class="separator:aa2fc07d0015fc88421311ac8c1a55868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output buffer.  <a href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">More...</a><br /></td></tr>
<tr class="separator:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output buffer.  <a href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">More...</a><br /></td></tr>
<tr class="separator:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a3b34e5a990ca1f78e6cc2ff08bb4220f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b34e5a990ca1f78e6cc2ff08bb4220f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a3b34e5a990ca1f78e6cc2ff08bb4220f">isBundle</a> ()</td></tr>
<tr class="memdesc:a3b34e5a990ca1f78e6cc2ff08bb4220f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field.">comms::field::Bundle</a>.  <a href="classcomms_1_1field_1_1Bundle.html#a3b34e5a990ca1f78e6cc2ff08bb4220f">More...</a><br /></td></tr>
<tr class="separator:a3b34e5a990ca1f78e6cc2ff08bb4220f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa24ca03c6cedbe4d6baf65093f8ec57"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:afa24ca03c6cedbe4d6baf65093f8ec57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#afa24ca03c6cedbe4d6baf65093f8ec57">operator!=</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:afa24ca03c6cedbe4d6baf65093f8ec57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equality comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#afa24ca03c6cedbe4d6baf65093f8ec57">More...</a><br /></td></tr>
<tr class="separator:afa24ca03c6cedbe4d6baf65093f8ec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc5b7d0e35f85ad7b060b5b100f94cf"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:a6dc5b7d0e35f85ad7b060b5b100f94cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a6dc5b7d0e35f85ad7b060b5b100f94cf">operator&lt;</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a6dc5b7d0e35f85ad7b060b5b100f94cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#a6dc5b7d0e35f85ad7b060b5b100f94cf">More...</a><br /></td></tr>
<tr class="separator:a6dc5b7d0e35f85ad7b060b5b100f94cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb9e7bcf3fa9c026230c326d1536954"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:aaeb9e7bcf3fa9c026230c326d1536954"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#aaeb9e7bcf3fa9c026230c326d1536954">operator&lt;=</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:aaeb9e7bcf3fa9c026230c326d1536954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#aaeb9e7bcf3fa9c026230c326d1536954">More...</a><br /></td></tr>
<tr class="separator:aaeb9e7bcf3fa9c026230c326d1536954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d3c305dcbfb5052a58c9533df2f755"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:a78d3c305dcbfb5052a58c9533df2f755"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a78d3c305dcbfb5052a58c9533df2f755">operator==</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a78d3c305dcbfb5052a58c9533df2f755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#a78d3c305dcbfb5052a58c9533df2f755">More...</a><br /></td></tr>
<tr class="separator:a78d3c305dcbfb5052a58c9533df2f755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044dfa73a60b2773c299914c54dc76f"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:a1044dfa73a60b2773c299914c54dc76f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a1044dfa73a60b2773c299914c54dc76f">operator&gt;</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a1044dfa73a60b2773c299914c54dc76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#a1044dfa73a60b2773c299914c54dc76f">More...</a><br /></td></tr>
<tr class="separator:a1044dfa73a60b2773c299914c54dc76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3813fdbed2a073ea8b1933471d30bde3"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:a3813fdbed2a073ea8b1933471d30bde3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Bundle.html#a3813fdbed2a073ea8b1933471d30bde3">operator&gt;=</a> (const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2) noexcept</td></tr>
<tr class="memdesc:a3813fdbed2a073ea8b1933471d30bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalence comparison operator.  <a href="classcomms_1_1field_1_1Bundle.html#a3813fdbed2a073ea8b1933471d30bde3">More...</a><br /></td></tr>
<tr class="separator:a3813fdbed2a073ea8b1933471d30bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a223f1e820818de256ae61bdb052500a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223f1e820818de256ae61bdb052500a3">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1Bundle.html#a223f1e820818de256ae61bdb052500a3">ValueType</a> =  typename BaseImpl::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type. </p>
<p>Same as TMemebers template argument, i.e. it is std::tuple of all the wrapped fields. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d92cbd0d7e192109edb5ce861507e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d92cbd0d7e192109edb5ce861507e93">&#9670;&nbsp;</a></span>Bundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Invokes default constructor of every wrapped field </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a07c7bd49761eeb71e159d49818cd09f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c7bd49761eeb71e159d49818cd09f0">&#9670;&nbsp;</a></span>canWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::canWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default check of whether the field has a consistent value for writing. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>true</b>. </dd></dl>

</div>
</div>
<a id="a8f3823038c978a293eea21583ca49e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3823038c978a293eea21583ca49e8a">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1Bundle.html#af5f87592dfc9002fd5baac48fa874c67">VersionType</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version of the field. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> option has been provided. </p>

</div>
</div>
<a id="a1ab26767c780631c6d2ab21ee31cbdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab26767c780631c6d2ab21ee31cbdd2">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length required to serialise bundled fields. </p>
<p>Summarises all the results returned by the call to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2" title="Get length required to serialise bundled fields.">length()</a> for every field in the bundle. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the field value. </dd></dl>

</div>
</div>
<a id="a3d79f3356d35185999d12f7c17833703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d79f3356d35185999d12f7c17833703">&#9670;&nbsp;</a></span>lengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::lengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length required to serialise specified bundled member fields. </p>
<p>Summarises all the results returned by the call to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2" title="Get length required to serialise bundled fields.">length()</a> for every specified field in the bundle. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="ade9b17a0fcb6d9dbc3815cf697f1c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b17a0fcb6d9dbc3815cf697f1c21e">&#9670;&nbsp;</a></span>lengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::lengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length required to serialise specified bundled member fields. </p>
<p>Summarises all the results returned by the call to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2" title="Get length required to serialise bundled fields.">length()</a> for every specified field in the bundle. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="aa2627a0221cf2ac3cc1a52d7aa3dce8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2627a0221cf2ac3cc1a52d7aa3dce8a">&#9670;&nbsp;</a></span>lengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::lengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length required to serialise specified bundled member fields. </p>
<p>Summarises all the results returned by the call to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1ab26767c780631c6d2ab21ee31cbdd2" title="Get length required to serialise bundled fields.">length()</a> for every specified field in the bundle. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="a23cb5f46fae620123f76c09dbea9ea7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb5f46fae620123f76c09dbea9ea7e">&#9670;&nbsp;</a></span>maxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::maxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise all bundled fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximal number of bytes required serialise the field value. </dd></dl>

</div>
</div>
<a id="a56df30a9eeccaaaa8e372ead1132ac2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56df30a9eeccaaaa8e372ead1132ac2e">&#9670;&nbsp;</a></span>maxLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::maxLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="a0c4ef0849e41a4b1691d0870b8eecd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4ef0849e41a4b1691d0870b8eecd3e">&#9670;&nbsp;</a></span>maxLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::maxLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="a845d61007dac433de40cd11b38e1d89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845d61007dac433de40cd11b38e1d89b">&#9670;&nbsp;</a></span>maxLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::maxLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="a23047e4e5b89a290913f790de1b4f55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23047e4e5b89a290913f790de1b4f55a">&#9670;&nbsp;</a></span>minLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::minLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise all bundled fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required serialise the field value. </dd></dl>

</div>
</div>
<a id="a43f3d67984e46fd4b25802f9a29c9a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f3d67984e46fd4b25802f9a29c9a4f">&#9670;&nbsp;</a></span>minLengthFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::minLengthFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="ad476848ad3a1d72dcd8500fec24413cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad476848ad3a1d72dcd8500fec24413cb">&#9670;&nbsp;</a></span>minLengthFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::minLengthFromUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the field (included) from which the counting must start. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>

</div>
</div>
<a id="ab045e15f74295825493052a9b51fca48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab045e15f74295825493052a9b51fca48">&#9670;&nbsp;</a></span>minLengthUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::minLengthUntil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise specified bundled fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the field (not included) until which the counting must be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimal number of bytes required to serialise the specified member fields. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt;::value </dd></dl>

</div>
</div>
<a id="a9e516723465cdd9123ae4cde775e89e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e516723465cdd9123ae4cde775e89e4">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence. </p>
<p>Invokes <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a> member function over every bundled field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a625b2614fc28507e11476c4dfa168cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625b2614fc28507e11476c4dfa168cf8">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa2fc07d0015fc88421311ac8c1a55868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc07d0015fc88421311ac8c1a55868">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a1625733923ab6994747cf14f2a350872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1625733923ab6994747cf14f2a350872">&#9670;&nbsp;</a></span>readFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (from specified index). </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a></b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="add2775508ee526810fcdec29a2c3998d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2775508ee526810fcdec29a2c3998d">&#9670;&nbsp;</a></span>readFromAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFromAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (from specified index) while updating remaining length information. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1625733923ab6994747cf14f2a350872">readFrom()</a>, but updates provided length information. Number of consumed bytes are subsctruced from provided length value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="ad425f08942ea228a015b536f3efacd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad425f08942ea228a015b536f3efacd28">&#9670;&nbsp;</a></span>readFromNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFromNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected member fields from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">readNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664" title="Read field value from input data sequence without error check and status report.">readNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="adb61a1129588cd0247b889ec0c563be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb61a1129588cd0247b889ec0c563be6">&#9670;&nbsp;</a></span>readFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (between specified indices). </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a></b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="adc64a4a144f9fc7d2b03842eba8ba4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc64a4a144f9fc7d2b03842eba8ba4ff">&#9670;&nbsp;</a></span>readFromUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFromUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (between specified indices) while updating remaining length information. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#adb61a1129588cd0247b889ec0c563be6">readFromUntil()</a>, but updates provided length information. Number of consumed bytes are subsctruced from provided length value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a3626275a7e4e72b433f217a83f79cf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3626275a7e4e72b433f217a83f79cf45">&#9670;&nbsp;</a></span>readFromUntilNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readFromUntilNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected member fields from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">readNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664" title="Read field value from input data sequence without error check and status report.">readNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "read" operation starts </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a538e00d8995223f48757f01953a0b664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538e00d8995223f48757f01953a0b664">&#9670;&nbsp;</a></span>readNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a1b02b27872db689a00dc875b72fe25b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02b27872db689a00dc875b72fe25b1">&#9670;&nbsp;</a></span>readUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (until specified index). </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4" title="Read field value from input data sequence.">read()</a></b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="ad50e91d0694ccebdfb1f727b2463fca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50e91d0694ccebdfb1f727b2463fca9">&#9670;&nbsp;</a></span>readUntilAndUpdateLen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readUntilAndUpdateLen </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected number of member fields (until specified index) while updating remaining length information. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1b02b27872db689a00dc875b72fe25b1">readUntil()</a>, but updates provided length information. Number of consumed bytes are subsctruced from provided length value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a794b67b2061cb8e354f02a3f12c1b625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794b67b2061cb8e354f02a3f12c1b625">&#9670;&nbsp;</a></span>readUntilNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::readUntilNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read selected member fields from input data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664">readNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#a538e00d8995223f48757f01953a0b664" title="Read field value from input data sequence without error check and status report.">readNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "read" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="af80c2f4e7c0283dbaf730451757a8ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80c2f4e7c0283dbaf730451757a8ad8">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the field's contents. </p>
<p>Calls <a class="el" href="classcomms_1_1field_1_1Bundle.html#af80c2f4e7c0283dbaf730451757a8ad8" title="Refresh the field&#39;s contents.">refresh()</a> member function on every member field, will return <b>true</b> if any of the calls returns <b>true</b>. </p>

</div>
</div>
<a id="ac5af1df902a21e27fb1b6c0c2fab27b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af1df902a21e27fb1b6c0c2fab27b2">&#9670;&nbsp;</a></span>setVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::setVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1Bundle.html#af5f87592dfc9002fd5baac48fa874c67">VersionType</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of version update. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the field contents have changed, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="abbc7d5f9c7a7167869590974d46edf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7d5f9c7a7167869590974d46edf5d">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default validity check. </p>
<p>Always returns true, can be overriden by the derived class </p><dl class="section return"><dt>Returns</dt><dd>Always <b>true</b> </dd></dl>

</div>
</div>
<a id="a70f67eb58a758643e5a3d1ae12429ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f67eb58a758643e5a3d1ae12429ef5">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence. </p>
<p>Invokes <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5" title="Write current field value to output data sequence.">write()</a> member function over every bundled field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a0bd63c4d88caa3e2c7ec36810f4ef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd63c4d88caa3e2c7ec36810f4ef480">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output buffer. </p>
<p>Use this function to write data to the the buffer maintained by the caller. The endianness of the data will be as specified in the options provided to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa03f444fd95e5ab123f8cdadd5f0a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03f444fd95e5ab123f8cdadd5f0a24a">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output buffer. </p>
<p>Use this function to write partial data to the buffer maintained by the caller. The endianness of the data will be as specified the class options. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="acc9a610b77ecc2c81b216229d3e0f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9a610b77ecc2c81b216229d3e0f93e">&#9670;&nbsp;</a></span>writeFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeFrom </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write()</a>, but invokes <b>write</b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "write" operation starts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="ac30fc3e16a5905695fd83aee2c1f5d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30fc3e16a5905695fd83aee2c1f5d3a">&#9670;&nbsp;</a></span>writeFromNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeFromNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">writeNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7" title="Write current field value to output data sequence without error check and status report.">writeNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "write" operation starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TFromIdx &lt; std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a7ff4f155e990db0c61e6385af4ccbc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff4f155e990db0c61e6385af4ccbc1e">&#9670;&nbsp;</a></span>writeFromUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeFromUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write()</a>, but invokes <b>write</b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "write" operation starts. </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "write" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd>
<dd>
TFromIdx &lt; TUntilIdx </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a6d820c7bddb44e76c7b47dae63448258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d820c7bddb44e76c7b47dae63448258">&#9670;&nbsp;</a></span>writeFromUntilNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TFromIdx, std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeFromUntilNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">writeNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7" title="Write current field value to output data sequence without error check and status report.">writeNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFromIdx</td><td>Index of the member field (included) from which the "write" operation starts </td></tr>
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "write" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="ac4d32749b85c4110210e92f524cb71a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d32749b85c4110210e92f524cb71a7">&#9670;&nbsp;</a></span>writeNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="ababcf65ddda0e2a662d5f7e953f9c13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababcf65ddda0e2a662d5f7e953f9c13c">&#9670;&nbsp;</a></span>writeUntil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeUntil </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write()</a>, but invokes <b>write</b> member function of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "write" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="aeabe422e19bfd31ff2b60d5722418bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabe422e19bfd31ff2b60d5722418bc9">&#9670;&nbsp;</a></span>writeUntilNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TUntilIdx, typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeUntilNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write selected member fields to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7">writeNoStatus()</a>, but invokes <b><a class="el" href="classcomms_1_1field_1_1Bundle.html#ac4d32749b85c4110210e92f524cb71a7" title="Write current field value to output data sequence without error check and status report.">writeNoStatus()</a></b> of only selected member fields. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TUntilIdx</td><td>Index of the member field (NOT included) until which the "write" operation continues. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TUntilIdx &lt;= std::tuple_size&lt;ValueType&gt; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3b34e5a990ca1f78e6cc2ff08bb4220f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34e5a990ca1f78e6cc2ff08bb4220f">&#9670;&nbsp;</a></span>isBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool isBundle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field.">comms::field::Bundle</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a> </dd></dl>

</div>
</div>
<a id="afa24ca03c6cedbe4d6baf65093f8ec57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa24ca03c6cedbe4d6baf65093f8ec57">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are NOT equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a6dc5b7d0e35f85ad7b060b5b100f94cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc5b7d0e35f85ad7b060b5b100f94cf">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeb9e7bcf3fa9c026230c326d1536954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb9e7bcf3fa9c026230c326d1536954">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78d3c305dcbfb5052a58c9533df2f755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d3c305dcbfb5052a58c9533df2f755">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a1044dfa73a60b2773c299914c54dc76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044dfa73a60b2773c299914c54dc76f">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3813fdbed2a073ea8b1933471d30bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3813fdbed2a073ea8b1933471d30bde3">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Bundle.html">Bundle</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalence comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/field/<a class="el" href="Bundle_8h_source.html">Bundle.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
