<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::field::Variant&lt; TFieldBase, TMembers, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1field.html">field</a></li><li class="navelem"><a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1field_1_1Variant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::field::Variant&lt; TFieldBase, TMembers, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="Variant_8h_source.html">comms/field/Variant.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TFieldBase, typename TMembers, typename... TOptions&gt;<br />
class comms::field::Variant&lt; TFieldBase, TMembers, TOptions &gt;</h3>

<p>Defines a "variant" field, that can contain any of the provided ones. </p>
<p>The <b><a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a></b> object contains uninitialised buffer that can fit any of the provided field types (as second template parameter). At any given point of time this space can be initialised and used to contain <b>at most</b> one of the specified field types. It resembles a classic <b>union</b>, but disallows set value of one field type and read it as other. The <b><a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a></b> field abstraction provides expected single field API functions, such as <a class="el" href="classcomms_1_1field_1_1Variant.html#a791dc2b5273d171ff2a4368e018f296e" title="Get length required to serialise contained fields.">length()</a>, <a class="el" href="classcomms_1_1field_1_1Variant.html#afb3c9b5d48cc2e9368e378dd8da83b21" title="Read field value from input data sequence.">read()</a>, <a class="el" href="classcomms_1_1field_1_1Variant.html#a277462fce87c52bb706423ebfc6e2725" title="Write current field value to output data sequence.">write()</a>, <a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d" title="Default validity check.">valid()</a>.</p>
<p>Refer to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_variant">Variant Fields</a> for tutorial and usage examples. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFieldBase</td><td>Base class for this field, expected to be a variant of <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">comms::Field</a>. </td></tr>
    <tr><td class="paramname">TMembers</td><td>All supported field types bundled together in <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>. This parameter is used to determine the size of the contained buffer to be able to fit any of the specified types. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Zero or more options that modify/refine default behaviour of the field.<br  />
 Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a> - All wrapped fields may specify their independent default value initialisers. It is also possible to provide initialiser for the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field which will set appropriate values to the fields based on some internal logic. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a> - All wrapped fields may specify their independent validators. The bundle field considered to be valid if all the wrapped fields are valid. This option though, provides an ability to add extra validation logic that can observe value of more than one wrapped fields. For example, protocol specifies that if one specific field has value X, than other field is NOT allowed to have value Y. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ContentsRefresher.html">comms::option::def::ContentsRefresher</a> - The default <b><a class="el" href="classcomms_1_1field_1_1Variant.html#a290673e57f4f4bf9a5ad81c9924aabe8" title="Refresh the field&#39;s value.">refresh()</a></b> behavior is to call <b><a class="el" href="classcomms_1_1field_1_1Variant.html#a290673e57f4f4bf9a5ad81c9924aabe8" title="Refresh the field&#39;s value.">refresh()</a></b> member function of the contained field (if such exists). This option allows specifying the custom refreshing behaviour. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1CustomValueReader.html">comms::option::def::CustomValueReader</a> - It may be required to implement custom reading functionality instead of default behaviour of invoking <a class="el" href="classcomms_1_1field_1_1Variant.html#afb3c9b5d48cc2e9368e378dd8da83b21" title="Read field value from input data sequence.">read()</a> member function of every member field. It is possible to provide cusom reader functionality using <a class="el" href="structcomms_1_1option_1_1def_1_1CustomValueReader.html" title="Option that specifies custom value reader class.">comms::option::def::CustomValueReader</a> option. </li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a367246a4a2fa2fb908b760644e699c71">comms::option::def::DefaultVariantIndex</a> - By default the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field doesn't have any valid contents. This option may be used to specify the index of the default member field. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRead.html">comms::option::def::HasCustomRead</a> - Mark field to have custom read functionality </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> - Mark field to have custom refresh functionality. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> - Force empty serialization. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> - Add version storage.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931" title="Provide names for member fields of comms::field::Variant field.">COMMS_VARIANT_MEMBERS_NAMES()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b" title="Add convenience access enum and functions to the members of comms::field::Variant field.">COMMS_VARIANT_MEMBERS_ACCESS()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1field_1_1Variant.html#a7b15e387e5c2a162bb0fad3f8fb77606" title="Similar to COMMS_VARIANT_MEMBERS_ACCESS(), but dedicated for non-template classes.">COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE()</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for comms::field::Variant&lt; TFieldBase, TMembers, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1field_1_1Variant.png" usemap="#comms::field::Variant_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::field::Variant_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map" name="comms::field::Variant_3C_20TFieldBase_2C_20TMembers_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1Field.html" title="Base class to all the field classes." alt="comms::Field&lt; TOptions &gt;" shape="rect" coords="0,0,341,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a85b5497e26b3a8d03da68fed0d5d4a4a"><td class="memItemLeft" align="right" valign="top"><a id="a85b5497e26b3a8d03da68fed0d5d4a4a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a85b5497e26b3a8d03da68fed0d5d4a4a">Endian</a> = typename BaseImpl::Endian</td></tr>
<tr class="memdesc:a85b5497e26b3a8d03da68fed0d5d4a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endian used for serialisation. <br /></td></tr>
<tr class="separator:a85b5497e26b3a8d03da68fed0d5d4a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175572e0bb99994ea8ab70fe66322041"><td class="memItemLeft" align="right" valign="top"><a id="a175572e0bb99994ea8ab70fe66322041"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a175572e0bb99994ea8ab70fe66322041">FieldBase</a> = TFieldBase</td></tr>
<tr class="memdesc:a175572e0bb99994ea8ab70fe66322041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class provided in the first template parameter. <br /></td></tr>
<tr class="separator:a175572e0bb99994ea8ab70fe66322041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eb6294779f735e19e2202bb751a40b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> = typename BaseImpl::Members</td></tr>
<tr class="memdesc:ab2eb6294779f735e19e2202bb751a40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the supported types.  <a href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">More...</a><br /></td></tr>
<tr class="separator:ab2eb6294779f735e19e2202bb751a40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aafe7c1af65cc6b88b1422c0e37af6"><td class="memItemLeft" align="right" valign="top"><a id="a91aafe7c1af65cc6b88b1422c0e37af6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a91aafe7c1af65cc6b88b1422c0e37af6">ParsedOptions</a> = details::OptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a91aafe7c1af65cc6b88b1422c0e37af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the options provided to this class bundled into struct. <br /></td></tr>
<tr class="separator:a91aafe7c1af65cc6b88b1422c0e37af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e4a6aaddc1f522ff997541e13df4b6"><td class="memItemLeft" align="right" valign="top"><a id="ac0e4a6aaddc1f522ff997541e13df4b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ac0e4a6aaddc1f522ff997541e13df4b6">Tag</a> = tag::Variant</td></tr>
<tr class="memdesc:ac0e4a6aaddc1f522ff997541e13df4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag indicating type of the field. <br /></td></tr>
<tr class="separator:ac0e4a6aaddc1f522ff997541e13df4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc09c38e7f2d71ac5d5e98d9780a58c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> = typename BaseImpl::ValueType</td></tr>
<tr class="memdesc:adc09c38e7f2d71ac5d5e98d9780a58c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type.  <a href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">More...</a><br /></td></tr>
<tr class="separator:adc09c38e7f2d71ac5d5e98d9780a58c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b291aac584df09c118e75cc09b51dce"><td class="memItemLeft" align="right" valign="top"><a id="a9b291aac584df09c118e75cc09b51dce"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a9b291aac584df09c118e75cc09b51dce">VersionType</a> = typename BaseImpl::VersionType</td></tr>
<tr class="memdesc:a9b291aac584df09c118e75cc09b51dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version type. <br /></td></tr>
<tr class="separator:a9b291aac584df09c118e75cc09b51dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8736711d21743415c04a7de54f1cc887"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a8736711d21743415c04a7de54f1cc887">Variant</a> ()=default</td></tr>
<tr class="memdesc:a8736711d21743415c04a7de54f1cc887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classcomms_1_1field_1_1Variant.html#a8736711d21743415c04a7de54f1cc887">More...</a><br /></td></tr>
<tr class="separator:a8736711d21743415c04a7de54f1cc887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfb58b684a2261d3451f873443b7822"><td class="memItemLeft" align="right" valign="top"><a id="a7bfb58b684a2261d3451f873443b7822"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a7bfb58b684a2261d3451f873443b7822">Variant</a> (const <a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> &amp;val)</td></tr>
<tr class="memdesc:a7bfb58b684a2261d3451f873443b7822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a7bfb58b684a2261d3451f873443b7822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee4b95875a49abb7ff7cb43a3a5061"><td class="memItemLeft" align="right" valign="top"><a id="abaee4b95875a49abb7ff7cb43a3a5061"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#abaee4b95875a49abb7ff7cb43a3a5061">Variant</a> (<a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:abaee4b95875a49abb7ff7cb43a3a5061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:abaee4b95875a49abb7ff7cb43a3a5061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f2ddd1d5b3bfc3647e82912fe97f47"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx&gt; </td></tr>
<tr class="memitem:a41f2ddd1d5b3bfc3647e82912fe97f47"><td class="memTemplItemLeft" align="right" valign="top">std::tuple_element&lt; TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a41f2ddd1d5b3bfc3647e82912fe97f47">accessField</a> ()</td></tr>
<tr class="memdesc:a41f2ddd1d5b3bfc3647e82912fe97f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access already constructed field at specifed index (known at compile time).  <a href="classcomms_1_1field_1_1Variant.html#a41f2ddd1d5b3bfc3647e82912fe97f47">More...</a><br /></td></tr>
<tr class="separator:a41f2ddd1d5b3bfc3647e82912fe97f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e562d6b436f4a6fcacb54bb5516d65"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx&gt; </td></tr>
<tr class="memitem:a37e562d6b436f4a6fcacb54bb5516d65"><td class="memTemplItemLeft" align="right" valign="top">const std::tuple_element&lt; TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a37e562d6b436f4a6fcacb54bb5516d65">accessField</a> () const</td></tr>
<tr class="memdesc:a37e562d6b436f4a6fcacb54bb5516d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access already constructed field at specifed index (known at compile time).  <a href="classcomms_1_1field_1_1Variant.html#a37e562d6b436f4a6fcacb54bb5516d65">More...</a><br /></td></tr>
<tr class="separator:a37e562d6b436f4a6fcacb54bb5516d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2294dd0980b1dd3cad2713977561221f"><td class="memItemLeft" align="right" valign="top"><a id="a2294dd0980b1dd3cad2713977561221f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a2294dd0980b1dd3cad2713977561221f">canWrite</a> () const</td></tr>
<tr class="memdesc:a2294dd0980b1dd3cad2713977561221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of whether the field has a consistent value for writing. <br /></td></tr>
<tr class="separator:a2294dd0980b1dd3cad2713977561221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b3323d7a94321da9acadc097bc5f36"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36">currentField</a> () const</td></tr>
<tr class="memdesc:a20b3323d7a94321da9acadc097bc5f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of the current field (within the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple).  <a href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36">More...</a><br /></td></tr>
<tr class="separator:a20b3323d7a94321da9acadc097bc5f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdfe5b65c5b74b010eee7e1078c10f5"><td class="memTemplParams" colspan="2">template&lt;typename TFunc &gt; </td></tr>
<tr class="memitem:a6bdfe5b65c5b74b010eee7e1078c10f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a6bdfe5b65c5b74b010eee7e1078c10f5">currentFieldExec</a> (TFunc &amp;&amp;func)</td></tr>
<tr class="memdesc:a6bdfe5b65c5b74b010eee7e1078c10f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute provided function object with current field as parameter.  <a href="classcomms_1_1field_1_1Variant.html#a6bdfe5b65c5b74b010eee7e1078c10f5">More...</a><br /></td></tr>
<tr class="separator:a6bdfe5b65c5b74b010eee7e1078c10f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9078752e0f0082df87addb274eb858"><td class="memTemplParams" colspan="2">template&lt;typename TFunc &gt; </td></tr>
<tr class="memitem:a0f9078752e0f0082df87addb274eb858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a0f9078752e0f0082df87addb274eb858">currentFieldExec</a> (TFunc &amp;&amp;func) const</td></tr>
<tr class="memdesc:a0f9078752e0f0082df87addb274eb858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute provided function object with current field as parameter (const variant).  <a href="classcomms_1_1field_1_1Variant.html#a0f9078752e0f0082df87addb274eb858">More...</a><br /></td></tr>
<tr class="separator:a0f9078752e0f0082df87addb274eb858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3bc41a648140a8434c542b66cca041e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ae3bc41a648140a8434c542b66cca041e">currentFieldValid</a> () const</td></tr>
<tr class="memdesc:ae3bc41a648140a8434c542b66cca041e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the field contains a valid instance of other field.  <a href="classcomms_1_1field_1_1Variant.html#ae3bc41a648140a8434c542b66cca041e">More...</a><br /></td></tr>
<tr class="separator:ae3bc41a648140a8434c542b66cca041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfb9f32c78852a27e3a5afabd6f43ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1Variant.html#a9b291aac584df09c118e75cc09b51dce">VersionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#adcfb9f32c78852a27e3a5afabd6f43ac">getVersion</a> () const</td></tr>
<tr class="memdesc:adcfb9f32c78852a27e3a5afabd6f43ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version of the field.  <a href="classcomms_1_1field_1_1Variant.html#adcfb9f32c78852a27e3a5afabd6f43ac">More...</a><br /></td></tr>
<tr class="separator:adcfb9f32c78852a27e3a5afabd6f43ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4dd4d3fa0537593ba42374aaf542e0"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename... TArgs&gt; </td></tr>
<tr class="memitem:a6e4dd4d3fa0537593ba42374aaf542e0"><td class="memTemplItemLeft" align="right" valign="top">std::tuple_element&lt; TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">initField</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6e4dd4d3fa0537593ba42374aaf542e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and initialise specified contained field in the internal buffer.  <a href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">More...</a><br /></td></tr>
<tr class="separator:a6e4dd4d3fa0537593ba42374aaf542e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791dc2b5273d171ff2a4368e018f296e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a791dc2b5273d171ff2a4368e018f296e">length</a> () const</td></tr>
<tr class="memdesc:a791dc2b5273d171ff2a4368e018f296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length required to serialise contained fields.  <a href="classcomms_1_1field_1_1Variant.html#a791dc2b5273d171ff2a4368e018f296e">More...</a><br /></td></tr>
<tr class="separator:a791dc2b5273d171ff2a4368e018f296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3c9b5d48cc2e9368e378dd8da83b21"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:afb3c9b5d48cc2e9368e378dd8da83b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#afb3c9b5d48cc2e9368e378dd8da83b21">read</a> (TIter &amp;iter, std::size_t size)</td></tr>
<tr class="memdesc:afb3c9b5d48cc2e9368e378dd8da83b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read field value from input data sequence.  <a href="classcomms_1_1field_1_1Variant.html#afb3c9b5d48cc2e9368e378dd8da83b21">More...</a><br /></td></tr>
<tr class="separator:afb3c9b5d48cc2e9368e378dd8da83b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105fd65e814005135d77115c167c6879"><td class="memTemplParams" colspan="2"><a id="a105fd65e814005135d77115c167c6879"></a>
template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a105fd65e814005135d77115c167c6879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a105fd65e814005135d77115c167c6879">readNoStatus</a> (TIter &amp;iter)=delete</td></tr>
<tr class="memdesc:a105fd65e814005135d77115c167c6879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read operation without error check and status report is not supported. <br /></td></tr>
<tr class="separator:a105fd65e814005135d77115c167c6879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290673e57f4f4bf9a5ad81c9924aabe8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a290673e57f4f4bf9a5ad81c9924aabe8">refresh</a> ()</td></tr>
<tr class="memdesc:a290673e57f4f4bf9a5ad81c9924aabe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh the field's value.  <a href="classcomms_1_1field_1_1Variant.html#a290673e57f4f4bf9a5ad81c9924aabe8">More...</a><br /></td></tr>
<tr class="separator:a290673e57f4f4bf9a5ad81c9924aabe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f9e65404772702bc5eabb4f8a62dab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ab2f9e65404772702bc5eabb4f8a62dab">reset</a> ()</td></tr>
<tr class="memdesc:ab2f9e65404772702bc5eabb4f8a62dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate current state.  <a href="classcomms_1_1field_1_1Variant.html#ab2f9e65404772702bc5eabb4f8a62dab">More...</a><br /></td></tr>
<tr class="separator:ab2f9e65404772702bc5eabb4f8a62dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25067880fee6b6ebcc8171ff4e3a52ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a25067880fee6b6ebcc8171ff4e3a52ac">selectField</a> (std::size_t idx)</td></tr>
<tr class="memdesc:a25067880fee6b6ebcc8171ff4e3a52ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select type of the variant field.  <a href="classcomms_1_1field_1_1Variant.html#a25067880fee6b6ebcc8171ff4e3a52ac">More...</a><br /></td></tr>
<tr class="separator:a25067880fee6b6ebcc8171ff4e3a52ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf34eba40b0bb2cd0d0285b531c467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a0adf34eba40b0bb2cd0d0285b531c467">setVersion</a> (<a class="el" href="classcomms_1_1field_1_1Variant.html#a9b291aac584df09c118e75cc09b51dce">VersionType</a> <a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>)</td></tr>
<tr class="memdesc:a0adf34eba40b0bb2cd0d0285b531c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of version update.  <a href="classcomms_1_1field_1_1Variant.html#a0adf34eba40b0bb2cd0d0285b531c467">More...</a><br /></td></tr>
<tr class="separator:a0adf34eba40b0bb2cd0d0285b531c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384427b04f00d2817909c24f02013cc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a384427b04f00d2817909c24f02013cc3">valid</a> () const</td></tr>
<tr class="memdesc:a384427b04f00d2817909c24f02013cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check validity of all the contained field.  <a href="classcomms_1_1field_1_1Variant.html#a384427b04f00d2817909c24f02013cc3">More...</a><br /></td></tr>
<tr class="separator:a384427b04f00d2817909c24f02013cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadb93367e987db10b4add65990b3f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#afadb93367e987db10b4add65990b3f19">value</a> ()</td></tr>
<tr class="memdesc:afadb93367e987db10b4add65990b3f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the internal storage buffer.  <a href="classcomms_1_1field_1_1Variant.html#afadb93367e987db10b4add65990b3f19">More...</a><br /></td></tr>
<tr class="separator:afadb93367e987db10b4add65990b3f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02cf41f2b3ae03759de5510456658b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#af02cf41f2b3ae03759de5510456658b5">value</a> () const</td></tr>
<tr class="memdesc:af02cf41f2b3ae03759de5510456658b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the internal storage buffer.  <a href="classcomms_1_1field_1_1Variant.html#af02cf41f2b3ae03759de5510456658b5">More...</a><br /></td></tr>
<tr class="separator:af02cf41f2b3ae03759de5510456658b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277462fce87c52bb706423ebfc6e2725"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a277462fce87c52bb706423ebfc6e2725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a277462fce87c52bb706423ebfc6e2725">write</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a277462fce87c52bb706423ebfc6e2725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence.  <a href="classcomms_1_1field_1_1Variant.html#a277462fce87c52bb706423ebfc6e2725">More...</a><br /></td></tr>
<tr class="separator:a277462fce87c52bb706423ebfc6e2725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4488e6f62fa425459850ae4558bb34a"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:aa4488e6f62fa425459850ae4558bb34a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#aa4488e6f62fa425459850ae4558bb34a">writeNoStatus</a> (TIter &amp;iter) const</td></tr>
<tr class="memdesc:aa4488e6f62fa425459850ae4558bb34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write current field value to output data sequence without error check and status report.  <a href="classcomms_1_1field_1_1Variant.html#aa4488e6f62fa425459850ae4558bb34a">More...</a><br /></td></tr>
<tr class="separator:aa4488e6f62fa425459850ae4558bb34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07c7bd49761eeb71e159d49818cd09f0"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">canWrite</a> ()</td></tr>
<tr class="memdesc:a07c7bd49761eeb71e159d49818cd09f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default check of whether the field has a consistent value for writing.  <a href="classcomms_1_1Field.html#a07c7bd49761eeb71e159d49818cd09f0">More...</a><br /></td></tr>
<tr class="separator:a07c7bd49761eeb71e159d49818cd09f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d95f693eed6e03705b20823ace267f8"><td class="memItemLeft" align="right" valign="top"><a id="a0d95f693eed6e03705b20823ace267f8"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a0d95f693eed6e03705b20823ace267f8">hasNonDefaultRefresh</a> ()</td></tr>
<tr class="memdesc:a0d95f693eed6e03705b20823ace267f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class has non-default refresh functionality. <br /></td></tr>
<tr class="separator:a0d95f693eed6e03705b20823ace267f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a706abadb46bf17ef4cc16b7a6667"><td class="memItemLeft" align="right" valign="top"><a id="aa35a706abadb46bf17ef4cc16b7a6667"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#aa35a706abadb46bf17ef4cc16b7a6667">hasReadNoStatus</a> ()</td></tr>
<tr class="memdesc:aa35a706abadb46bf17ef4cc16b7a6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1Variant.html#a105fd65e814005135d77115c167c6879">readNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:aa35a706abadb46bf17ef4cc16b7a6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7c42b32975e068140018f350603a16"><td class="memItemLeft" align="right" valign="top"><a id="a3d7c42b32975e068140018f350603a16"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a3d7c42b32975e068140018f350603a16">hasWriteNoStatus</a> ()</td></tr>
<tr class="memdesc:a3d7c42b32975e068140018f350603a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the field has <b>proper</b> <a class="el" href="classcomms_1_1field_1_1Variant.html#aa4488e6f62fa425459850ae4558bb34a">writeNoStatus()</a> member function. <br /></td></tr>
<tr class="separator:a3d7c42b32975e068140018f350603a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be6f6afb5010f8aba4ebb522ded539"><td class="memItemLeft" align="right" valign="top"><a id="a46be6f6afb5010f8aba4ebb522ded539"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a46be6f6afb5010f8aba4ebb522ded539">isVersionDependent</a> ()</td></tr>
<tr class="memdesc:a46be6f6afb5010f8aba4ebb522ded539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check if this class is version dependent. <br /></td></tr>
<tr class="separator:a46be6f6afb5010f8aba4ebb522ded539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b281a9850ae7d0f4ec722ca5f233351"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a8b281a9850ae7d0f4ec722ca5f233351">maxLength</a> ()</td></tr>
<tr class="memdesc:a8b281a9850ae7d0f4ec722ca5f233351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal length that is required to serialise all possible contained fields.  <a href="classcomms_1_1field_1_1Variant.html#a8b281a9850ae7d0f4ec722ca5f233351">More...</a><br /></td></tr>
<tr class="separator:a8b281a9850ae7d0f4ec722ca5f233351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9adcd40964b255cf50fddc115823c4f"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ac9adcd40964b255cf50fddc115823c4f">minLength</a> ()</td></tr>
<tr class="memdesc:ac9adcd40964b255cf50fddc115823c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimal length that is required to serialise all possible contained fields.  <a href="classcomms_1_1field_1_1Variant.html#ac9adcd40964b255cf50fddc115823c4f">More...</a><br /></td></tr>
<tr class="separator:ac9adcd40964b255cf50fddc115823c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7d5f9c7a7167869590974d46edf5d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">valid</a> ()</td></tr>
<tr class="memdesc:abbc7d5f9c7a7167869590974d46edf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default validity check.  <a href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">More...</a><br /></td></tr>
<tr class="separator:abbc7d5f9c7a7167869590974d46edf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a625b2614fc28507e11476c4dfa168cf8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:a625b2614fc28507e11476c4dfa168cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from input buffer.  <a href="classcomms_1_1Field.html#a625b2614fc28507e11476c4dfa168cf8">More...</a><br /></td></tr>
<tr class="separator:a625b2614fc28507e11476c4dfa168cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t TSize, typename TIter &gt; </td></tr>
<tr class="memitem:aa2fc07d0015fc88421311ac8c1a55868"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">readData</a> (TIter &amp;iter)</td></tr>
<tr class="memdesc:aa2fc07d0015fc88421311ac8c1a55868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read partial data from input buffer.  <a href="classcomms_1_1Field.html#aa2fc07d0015fc88421311ac8c1a55868">More...</a><br /></td></tr>
<tr class="separator:aa2fc07d0015fc88421311ac8c1a55868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TIter &gt; </td></tr>
<tr class="memitem:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1Variant.html#afadb93367e987db10b4add65990b3f19">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the output buffer.  <a href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">More...</a><br /></td></tr>
<tr class="separator:a0bd63c4d88caa3e2c7ec36810f4ef480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplParams" colspan="2">template&lt;std::size_t TSize, typename T , typename TIter &gt; </td></tr>
<tr class="memitem:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">writeData</a> (T <a class="el" href="classcomms_1_1field_1_1Variant.html#afadb93367e987db10b4add65990b3f19">value</a>, TIter &amp;iter)</td></tr>
<tr class="memdesc:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write partial data into the output buffer.  <a href="classcomms_1_1Field.html#aa03f444fd95e5ab123f8cdadd5f0a24a">More...</a><br /></td></tr>
<tr class="separator:aa03f444fd95e5ab123f8cdadd5f0a24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a973a95f2928609a140296b28957b130b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS</a>(...)</td></tr>
<tr class="memdesc:a973a95f2928609a140296b28957b130b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add convenience access enum and functions to the members of <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field.  <a href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">More...</a><br /></td></tr>
<tr class="separator:a973a95f2928609a140296b28957b130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b15e387e5c2a162bb0fad3f8fb77606"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a7b15e387e5c2a162bb0fad3f8fb77606">COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE</a>(...)</td></tr>
<tr class="memdesc:a7b15e387e5c2a162bb0fad3f8fb77606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b" title="Add convenience access enum and functions to the members of comms::field::Variant field.">COMMS_VARIANT_MEMBERS_ACCESS()</a>, but dedicated for non-template classes.  <a href="classcomms_1_1field_1_1Variant.html#a7b15e387e5c2a162bb0fad3f8fb77606">More...</a><br /></td></tr>
<tr class="separator:a7b15e387e5c2a162bb0fad3f8fb77606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b12d7388ea81343e0c77a92264c8931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a7b12d7388ea81343e0c77a92264c8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names for member fields of <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field.  <a href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">More...</a><br /></td></tr>
<tr class="separator:a7b12d7388ea81343e0c77a92264c8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a4647830b8a6b3460381c84890e472"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1a4647830b8a6b3460381c84890e472"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ab1a4647830b8a6b3460381c84890e472">isVariant</a> ()</td></tr>
<tr class="memdesc:ab1a4647830b8a6b3460381c84890e472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">comms::field::Variant</a>.  <a href="classcomms_1_1field_1_1Variant.html#ab1a4647830b8a6b3460381c84890e472">More...</a><br /></td></tr>
<tr class="separator:ab1a4647830b8a6b3460381c84890e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac814aefb0d1f921ec7c7d870e465e299"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:ac814aefb0d1f921ec7c7d870e465e299"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#ac814aefb0d1f921ec7c7d870e465e299">operator!=</a> (const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2)</td></tr>
<tr class="memdesc:ac814aefb0d1f921ec7c7d870e465e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equality comparison operator.  <a href="classcomms_1_1field_1_1Variant.html#ac814aefb0d1f921ec7c7d870e465e299">More...</a><br /></td></tr>
<tr class="separator:ac814aefb0d1f921ec7c7d870e465e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dce5864dc387739389a5bcd0851977"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:aa3dce5864dc387739389a5bcd0851977"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#aa3dce5864dc387739389a5bcd0851977">operator&lt;</a> (const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2)</td></tr>
<tr class="memdesc:aa3dce5864dc387739389a5bcd0851977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equality comparison operator.  <a href="classcomms_1_1field_1_1Variant.html#aa3dce5864dc387739389a5bcd0851977">More...</a><br /></td></tr>
<tr class="separator:aa3dce5864dc387739389a5bcd0851977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1a8ab72962d39fd24995a5f5f91f41"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:acc1a8ab72962d39fd24995a5f5f91f41"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#acc1a8ab72962d39fd24995a5f5f91f41">operator==</a> (const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field1, const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field2)</td></tr>
<tr class="memdesc:acc1a8ab72962d39fd24995a5f5f91f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator.  <a href="classcomms_1_1field_1_1Variant.html#acc1a8ab72962d39fd24995a5f5f91f41">More...</a><br /></td></tr>
<tr class="separator:acc1a8ab72962d39fd24995a5f5f91f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a59bd35d085045b6dfba19b27ac253f"><td class="memTemplParams" colspan="2"><a id="a1a59bd35d085045b6dfba19b27ac253f"></a>
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:a1a59bd35d085045b6dfba19b27ac253f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#a1a59bd35d085045b6dfba19b27ac253f">toFieldBase</a> (const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:a1a59bd35d085045b6dfba19b27ac253f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">comms::field::Variant</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a1a59bd35d085045b6dfba19b27ac253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc321dd0f9a9550777415e331250c399"><td class="memTemplParams" colspan="2"><a id="afc321dd0f9a9550777415e331250c399"></a>
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </td></tr>
<tr class="memitem:afc321dd0f9a9550777415e331250c399"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1field_1_1Variant.html#afc321dd0f9a9550777415e331250c399">toFieldBase</a> (<a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field)</td></tr>
<tr class="memdesc:afc321dd0f9a9550777415e331250c399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the field definition to its parent <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">comms::field::Variant</a> type in order to have access to its internal types. <br /></td></tr>
<tr class="separator:afc321dd0f9a9550777415e331250c399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab2eb6294779f735e19e2202bb751a40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eb6294779f735e19e2202bb751a40b">&#9670;&nbsp;</a></span>Members</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> =  typename BaseImpl::Members</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All the supported types. </p>
<p>Same as <b>TMemebers</b> template argument, i.e. it is <b>std::tuple</b> of all the wrapped fields. </p>

</div>
</div>
<a id="adc09c38e7f2d71ac5d5e98d9780a58c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc09c38e7f2d71ac5d5e98d9780a58c7">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> =  typename BaseImpl::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type. </p>
<p>Type of the internal buffer used to store contained field, should not be used in normal operation. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8736711d21743415c04a7de54f1cc887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8736711d21743415c04a7de54f1cc887">&#9670;&nbsp;</a></span>Variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::<a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Invokes default constructor of every wrapped field </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41f2ddd1d5b3bfc3647e82912fe97f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f2ddd1d5b3bfc3647e82912fe97f47">&#9670;&nbsp;</a></span>accessField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple_element&lt;TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a>&gt;::type&amp; <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::accessField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access already constructed field at specifed index (known at compile time). </p>
<p>Use this function to get a reference to the contained field type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field type witin the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the contained field. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36">currentField</a>() == TIdx </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a37e562d6b436f4a6fcacb54bb5516d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e562d6b436f4a6fcacb54bb5516d65">&#9670;&nbsp;</a></span>accessField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::tuple_element&lt;TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a>&gt;::type&amp; <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::accessField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access already constructed field at specifed index (known at compile time). </p>
<p>Use this function to get a const reference to the contained field type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field type witin the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the contained field. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><div class="fragment"><div class="line"><a class="code" href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36">currentField</a>() == TIdx </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07c7bd49761eeb71e159d49818cd09f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c7bd49761eeb71e159d49818cd09f0">&#9670;&nbsp;</a></span>canWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::canWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default check of whether the field has a consistent value for writing. </p>
<dl class="section return"><dt>Returns</dt><dd>Always <b>true</b>. </dd></dl>

</div>
</div>
<a id="a20b3323d7a94321da9acadc097bc5f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b3323d7a94321da9acadc097bc5f36">&#9670;&nbsp;</a></span>currentField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::currentField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of the current field (within the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple). </p>
<p>If the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field doesn't contain any valid field, the returned index is equivalent to size of the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </p>

</div>
</div>
<a id="a6bdfe5b65c5b74b010eee7e1078c10f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdfe5b65c5b74b010eee7e1078c10f5">&#9670;&nbsp;</a></span>currentFieldExec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::currentFieldExec </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute provided function object with current field as parameter. </p>
<p>The provided function object must define all the public <b>operator()</b> member functions to handle all possible types. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyFunc</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Type1&amp; field) {...}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Type2&amp; field) {...}</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b>, that every <b>operator()</b> is expecting to receive an index of the type within the holding tuple as a template parameter. If the index information is not needed it may be either ignored or static_assert-ed upon.</p>
<p>The <b>operator()</b> may also receive a member field type as a template parameter. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyFunc</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx, <span class="keyword">typename</span> TField&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(TField&amp; field)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// do somethign with the field</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The TField will be the actual type of the contained field. If the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field doesn't contain any valid field, the functor will <b>NOT</b> be called. </p>

</div>
</div>
<a id="a0f9078752e0f0082df87addb274eb858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9078752e0f0082df87addb274eb858">&#9670;&nbsp;</a></span>currentFieldExec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::currentFieldExec </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute provided function object with current field as parameter (const variant). </p>
<p>Similar to other <a class="el" href="classcomms_1_1field_1_1Variant.html#a6bdfe5b65c5b74b010eee7e1078c10f5" title="Execute provided function object with current field as parameter.">currentFieldExec()</a> variant, but with <b>const</b>. Note, the constness of the parameter. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyFunc</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx, <span class="keyword">typename</span> TField&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> TField&amp; field)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// do somethign with the field</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The TField will be the actual type of the contained field. If the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field doesn't contain any valid field, the functor will <b>NOT</b> be called. </p>

</div>
</div>
<a id="ae3bc41a648140a8434c542b66cca041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3bc41a648140a8434c542b66cca041e">&#9670;&nbsp;</a></span>currentFieldValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::currentFieldValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the field contains a valid instance of other field. </p>
<p>Returns <b>true</b> if and only if <a class="el" href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36" title="Get index of the current field (within the Members tuple).">currentField()</a> returns a valid index inside the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </p>

</div>
</div>
<a id="adcfb9f32c78852a27e3a5afabd6f43ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfb9f32c78852a27e3a5afabd6f43ac">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1Variant.html#a9b291aac584df09c118e75cc09b51dce">VersionType</a> <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version of the field. </p>
<p>Exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionStorage.html">comms::option::def::VersionStorage</a> option has been provided and/or any of the member fields is version dependent. </p>

</div>
</div>
<a id="a6e4dd4d3fa0537593ba42374aaf542e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4dd4d3fa0537593ba42374aaf542e0">&#9670;&nbsp;</a></span>initField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple_element&lt;TIdx, <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a>&gt;::type&amp; <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::initField </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and initialise specified contained field in the internal buffer. </p>
<p>If the field already contains a valid field of any other field type, the latter will be destructed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field type witin the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </td></tr>
    <tr><td class="paramname">TArgs</td><td>Types of the agurments for the field's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments for the constructed field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the constructed field. </dd></dl>

</div>
</div>
<a id="a791dc2b5273d171ff2a4368e018f296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791dc2b5273d171ff2a4368e018f296e">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get length required to serialise contained fields. </p>
<p>If the field doesn't contain a valid instance of other field, the reported length is 0, otherwise the length of the contained field is reported. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes it will take to serialise the field value. </dd></dl>

</div>
</div>
<a id="a8b281a9850ae7d0f4ec722ca5f233351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b281a9850ae7d0f4ec722ca5f233351">&#9670;&nbsp;</a></span>maxLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::maxLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximal length that is required to serialise all possible contained fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximal number of bytes required serialise the field value. </dd></dl>

</div>
</div>
<a id="ac9adcd40964b255cf50fddc115823c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adcd40964b255cf50fddc115823c4f">&#9670;&nbsp;</a></span>minLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::minLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get minimal length that is required to serialise all possible contained fields. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns 0. </dd></dl>

</div>
</div>
<a id="afb3c9b5d48cc2e9368e378dd8da83b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3c9b5d48cc2e9368e378dd8da83b21">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read field value from input data sequence. </p>
<p>Invokes <a class="el" href="classcomms_1_1field_1_1Variant.html#afb3c9b5d48cc2e9368e378dd8da83b21" title="Read field value from input data sequence.">read()</a> member function over every possible field in order of definition until <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to read the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of read operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a625b2614fc28507e11476c4dfa168cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625b2614fc28507e11476c4dfa168cf8">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa2fc07d0015fc88421311ac8c1a55868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fc07d0015fc88421311ac8c1a55868">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t TSize, typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::readData </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read partial data from input buffer. </p>
<p>Use this function to read data from the intput buffer maintained by the caller. The endianness of the data will be as specified in options of the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Return type </td></tr>
    <tr><td class="paramname">TSize</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of input iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral type value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The internal pointer of the stream buffer is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct stream buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="a290673e57f4f4bf9a5ad81c9924aabe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290673e57f4f4bf9a5ad81c9924aabe8">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::refresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh the field's value. </p>
<p>Invokes <a class="el" href="classcomms_1_1field_1_1Variant.html#a290673e57f4f4bf9a5ad81c9924aabe8" title="Refresh the field&#39;s value.">refresh()</a> member function of the current field if such exists, otherwise returns false. </p><dl class="section return"><dt>Returns</dt><dd><b>true</b> if the value has been updated, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="ab2f9e65404772702bc5eabb4f8a62dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f9e65404772702bc5eabb4f8a62dab">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate current state. </p>
<p>Destructs currently contained field if such exists. </p>

</div>
</div>
<a id="a25067880fee6b6ebcc8171ff4e3a52ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25067880fee6b6ebcc8171ff4e3a52ac">&#9670;&nbsp;</a></span>selectField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::selectField </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select type of the variant field. </p>
<p>If the same index has been selected before, the function does nothing, otherwise the currently selected member field is destructed, and the new one is default constructed.<br  />
 If provided index is equal or exceeds the size of the <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple, no new field is constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the type within <a class="el" href="classcomms_1_1field_1_1Variant.html#ab2eb6294779f735e19e2202bb751a40b">Members</a> tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0adf34eba40b0bb2cd0d0285b531c467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adf34eba40b0bb2cd0d0285b531c467">&#9670;&nbsp;</a></span>setVersion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::setVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1field_1_1Variant.html#a9b291aac584df09c118e75cc09b51dce">VersionType</a>&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of version update. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the field contents have changed, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a id="abbc7d5f9c7a7167869590974d46edf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc7d5f9c7a7167869590974d46edf5d">&#9670;&nbsp;</a></span>valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default validity check. </p>
<p>Always returns true, can be overriden by the derived class </p><dl class="section return"><dt>Returns</dt><dd>Always <b>true</b> </dd></dl>

</div>
</div>
<a id="a384427b04f00d2817909c24f02013cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384427b04f00d2817909c24f02013cc3">&#9670;&nbsp;</a></span>valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check validity of all the contained field. </p>
<p>Returns <b>false</b> if doesn't contain any field. </p>

</div>
</div>
<a id="afadb93367e987db10b4add65990b3f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadb93367e987db10b4add65990b3f19">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a>&amp; <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the internal storage buffer. </p>
<p>Should not be used in normal operation. </p>

</div>
</div>
<a id="af02cf41f2b3ae03759de5510456658b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02cf41f2b3ae03759de5510456658b5">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a>&amp; <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the internal storage buffer. </p>
<p>Should not be used in normal operation. </p>

</div>
</div>
<a id="a277462fce87c52bb706423ebfc6e2725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277462fce87c52bb706423ebfc6e2725">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence. </p>
<p>Invokes <a class="el" href="classcomms_1_1field_1_1Variant.html#a277462fce87c52bb706423ebfc6e2725" title="Write current field value to output data sequence.">write()</a> member function of the contained field if such exists. If the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">Variant</a> field doesn't contain any valid field, the function doesn't advance the iterator, but returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximal number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write operation. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<a id="a0bd63c4d88caa3e2c7ec36810f4ef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd63c4d88caa3e2c7ec36810f4ef480">&#9670;&nbsp;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data into the output buffer. </p>
<p>Use this function to write data to the the buffer maintained by the caller. The endianness of the data will be as specified in the options provided to the class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">Type</td><td>of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The iterator must be valid and can be successfully dereferenced and incremented at least sizeof(T) times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa03f444fd95e5ab123f8cdadd5f0a24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03f444fd95e5ab123f8cdadd5f0a24a">&#9670;&nbsp;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TSize, typename T , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1Field.html">comms::Field</a>&lt; TOptions &gt;::writeData </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write partial data into the output buffer. </p>
<p>Use this function to write partial data to the buffer maintained by the caller. The endianness of the data will be as specified the class options. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>Length of the value in bytes known in compile time. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the value to write. Must be integral. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Integral type value to be written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>TSize &lt;= sizeof(T) </dd>
<dd>
The iterator must be valid and can be successfully dereferenced and incremented at least TSize times. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator is advanced. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct buffers, unsafe otherwise. </dd></dl>

</div>
</div>
<a id="aa4488e6f62fa425459850ae4558bb34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4488e6f62fa425459850ae4558bb34a">&#9670;&nbsp;</a></span>writeNoStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt; TFieldBase, TMembers, TOptions &gt;::writeNoStatus </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write current field value to output data sequence without error check and status report. </p>
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Variant.html#a277462fce87c52bb706423ebfc6e2725">write()</a>, but doesn't perform any correctness checks and doesn't report any failures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator to write the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Iterator is advanced. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a973a95f2928609a140296b28957b130b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973a95f2928609a140296b28957b130b">&#9670;&nbsp;</a></span>COMMS_VARIANT_MEMBERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_VARIANT_MEMBERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(COMMS_DEFINE_FIELD_ENUM(__VA_ARGS__)) \</div>
<div class="line">    COMMS_AS_VARIANT_FUNC { \</div>
<div class="line">        auto&amp; var = <a class="code" href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a>(*<span class="keyword">this</span>); \</div>
<div class="line">        using Var = <span class="keyword">typename</span> std::decay&lt;decltype(var)&gt;::type; \</div>
<div class="line">        static_assert(std::tuple_size&lt;typename Var::Members&gt;::value == FieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for variant field&quot;</span>); \</div>
<div class="line">        return var; \</div>
<div class="line">    }\</div>
<div class="line">    COMMS_AS_VARIANT_CONST_FUNC { \</div>
<div class="line">        auto&amp; var = <a class="code" href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a>(*<span class="keyword">this</span>); \</div>
<div class="line">        using Var = <span class="keyword">typename</span> std::decay&lt;decltype(var)&gt;::type; \</div>
<div class="line">        static_assert(std::tuple_size&lt;typename Var::Members&gt;::value == FieldIdx_numOfValues, \</div>
<div class="line">            <span class="stringliteral">&quot;Invalid number of names for variant field&quot;</span>); \</div>
<div class="line">        return var; \</div>
<div class="line">    } \</div>
<div class="line">    COMMS_DO_VARIANT_MEM_ACC_FUNC(asVariant(), __VA_ARGS__)</div>
</div><!-- fragment -->
<p>Add convenience access enum and functions to the members of <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field. </p>
<p>Very similar to <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a>, but does <b>NOT</b> require definition of <b>Base</b> inner member type (for some compilers) and does <b>NOT</b> define inner <b>Field_*</b> types for used member fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some compilers, such as <b>clang</b> or early versions of <b>g++</b> may have problems compiling code generated by this macro even though it uses valid C++11 constructs in attempt to automatically identify the type of the base class. If the compilation fails, and this macro resides inside a <b>NON-template</b> class, please use <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b15e387e5c2a162bb0fad3f8fb77606" title="Similar to COMMS_VARIANT_MEMBERS_ACCESS(), but dedicated for non-template classes.">COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE()</a> macro instead. In case this macro needs to reside inside a <b>template</b> class, then there is a need to define inner <b>Base</b> type, which specifies exact type of the <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> class. For example: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div>
<div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;Field1, Field2, Field3&gt;,</div>
<div class="line">        TExtraOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Duplicate the base class definition</span></div>
<div class="line">    <span class="keyword">using</span> Base =</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            std::tuple&lt;Field1, Field2, Field3&gt;,</div>
<div class="line">            TExtraOptions...</div>
<div class="line">        &gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS</a>(member1, member2, member3);</div>
<div class="line">};</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7b15e387e5c2a162bb0fad3f8fb77606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b15e387e5c2a162bb0fad3f8fb77606">&#9670;&nbsp;</a></span>COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(COMMS_DEFINE_FIELD_ENUM(__VA_ARGS__)) \</div>
<div class="line">    COMMS_DO_VARIANT_MEM_ACC_FUNC_NOTEMPLATE(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Similar to <a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b" title="Add convenience access enum and functions to the members of comms::field::Variant field.">COMMS_VARIANT_MEMBERS_ACCESS()</a>, but dedicated for non-template classes. </p>
<p>The <a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b" title="Add convenience access enum and functions to the members of comms::field::Variant field.">COMMS_VARIANT_MEMBERS_ACCESS()</a> macro is a generic one, which can be used in any class (template, or non-template). However, some compilers (such as <b>g++-4.9</b> and below, <b>clang-4.0</b> and below) may fail to compile it even though it uses valid C++11 constructs. If the compilation fails and the class it is being used in is <b>NOT</b> a template one, please use <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b15e387e5c2a162bb0fad3f8fb77606">COMMS_VARIANT_MEMBERS_ACCESS_NOTEMPLATE()</a> instead. </p>

</div>
</div>
<a id="a7b12d7388ea81343e0c77a92264c8931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b12d7388ea81343e0c77a92264c8931">&#9670;&nbsp;</a></span>COMMS_VARIANT_MEMBERS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_VARIANT_MEMBERS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_EXPAND(<a class="code" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS</a>(__VA_ARGS__)) \</div>
<div class="line">    COMMS_EXPAND(COMMS_DO_FIELD_TYPEDEF(<span class="keyword">typename</span> Base::Members, Field_, FieldIdx_, __VA_ARGS__))</div>
</div><!-- fragment -->
<p>Provide names for member fields of <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field. </p>
<p>All the possible field types the <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field can contain are bundled in <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and provided as a template parameter to the definition of the <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> Field1 = ...;</div>
<div class="line"><span class="keyword">using</span> Field2 = ...;</div>
<div class="line"><span class="keyword">using</span> Field3 = ...;</div>
<div class="line"><span class="keyword">using</span> MyField =</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;Field1, Field2, Field3&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">MyField field;</div>
<div class="line"><span class="keyword">auto</span>&amp; field1 = field.<a class="code" href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">initField</a>&lt;0&gt;(); <span class="comment">// Initialise the field to contain Field1 value</span></div>
<div class="line">field1.value() = ...;</div>
</div><!-- fragment --><p> However, it would be convenient to provide names and easier access to all the poisble variants. The <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> macro does exactly that when used inside the field class definition. Just inherit from the <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> class and use the macro inside with the names for the member fields: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div>
<div class="line">    <span class="comment">// the required of COMMS_VARIANT_MEMBERS_NAMES() macro.</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(member1, member2, member3);</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b> that there is a required to have <b>Base</b> member type that specifies base class used.</p>
<p>Usage of <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> macro is equivalent to having the following types and functions definitions: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Access indices for member fields</span></div>
<div class="line">    <span class="keyword">enum</span> FieldIdx {</div>
<div class="line">        FieldIdx_member1,</div>
<div class="line">        FieldIdx_member2,</div>
<div class="line">        FieldIdx_member3,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialise as first member (Field1)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    Field1&amp; initField_member1(TArgs&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        rerturn initField&lt;FieldIdx_member1&gt;(std::forward&lt;TArgs&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to the stored field as first member (Field1)</span></div>
<div class="line">    Field1&amp; accessField_member1()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member1&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const variant of the accessor to the stored field as first member (Field1)</span></div>
<div class="line">    <span class="keyword">const</span> Field1&amp; accessField_member1()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member1&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialise as second member (Field2)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    Field2&amp; initField_member2(TArgs&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        rerturn initField&lt;FieldIdx_member2&gt;(std::forward&lt;TArgs&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to the stored field as second member (Field2)</span></div>
<div class="line">    Field2&amp; accessField_member2()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member2&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const variant of the accessor to the stored field as second member (Field2)</span></div>
<div class="line">    <span class="keyword">const</span> Field2&amp; accessField_member2()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member2&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialise as third member (Field3)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    Field3&amp; initField_member3(TArgs&amp;&amp;... args)</div>
<div class="line">    {</div>
<div class="line">        rerturn initField&lt;FieldIdx_member3&gt;(std::forward&lt;TArgs&gt;(args)...);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to the stored field as third member (Field3)</span></div>
<div class="line">    Field3&amp; accessField_member3()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member3&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const variant of the accessor to the stored field as third member (Field3)</span></div>
<div class="line">    <span class="keyword">const</span> Field3&amp; accessField_member3()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_member3&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Redefinition of the field types:</span></div>
<div class="line">    <span class="keyword">using</span> Field_member1 = Field1;</div>
<div class="line">    <span class="keyword">using</span> Field_member2 = Field2;</div>
<div class="line">    <span class="keyword">using</span> Field_member3 = Field3;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>member1</b>, <b>member2</b>, and <b>member3</b>, have found their way to the following definitions: </p><ul>
<li><b>FieldIdx</b> enum. The names are prefixed with <b>FieldIdx_</b>. The <b>FieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Initialisation functions prefixed with <b>initField_</b> </li>
<li>Accessor functions prefixed with <b>accessField_</b> </li>
<li>Types of fields prefixed with <b>Field_*</b> </li>
</ul>
<p>See <a class="el" href="page_field_tutorial.html#sec_field_tutorial_variant">Variant Fields</a> for more examples and details </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>List of member fields' names.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/field/Variant.h" </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS()</a> </dd>
<dd>
<a class="el" href="page_field_tutorial.html#sec_field_tutorial_variant">Variant Fields</a> </dd></dl>

</div>
</div>
<a id="ab1a4647830b8a6b3460381c84890e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a4647830b8a6b3460381c84890e472">&#9670;&nbsp;</a></span>isVariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool isVariant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check function of whether a provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">comms::field::Variant</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case provided type is any variant of <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a> </dd></dl>

</div>
</div>
<a id="ac814aefb0d1f921ec7c7d870e465e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac814aefb0d1f921ec7c7d870e465e299">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are NOT equal, false otherwise. </dd></dl>

</div>
</div>
<a id="aa3dce5864dc387739389a5bcd0851977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dce5864dc387739389a5bcd0851977">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are NOT equal, false otherwise. </dd></dl>

</div>
</div>
<a id="acc1a8ab72962d39fd24995a5f5f91f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1a8ab72962d39fd24995a5f5f91f41">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TMembers , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1field_1_1Variant.html">Variant</a>&lt; TFieldBase, TMembers, TOptions... &gt; &amp;&#160;</td>
          <td class="paramname"><em>field2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field1</td><td>First field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field2</td><td>Second field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case fields are equal, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/field/<a class="el" href="Variant_8h_source.html">Variant.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aField_8h_html_af74198f06b52d3f58c92e795b2ff7129"><div class="ttname"><a href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a></div><div class="ttdeci">#define COMMS_FIELD_MEMBERS_NAMES(...)</div><div class="ttdoc">Provide names for member fields of composite fields, such as comms::field::Bundle or comms::field::Bi...</div><div class="ttdef"><b>Definition:</b> Field.h:372</div></div>
<div class="ttc" id="anamespacecomms_1_1field_html_a9127363faf239beb7a9d44afc5c5665f"><div class="ttname"><a href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase</a></div><div class="ttdeci">Bundle&lt; TFieldBase, TMembers, TOptions... &gt; &amp; toFieldBase(Bundle&lt; TFieldBase, TMembers, TOptions... &gt; &amp;field)</div><div class="ttdoc">Upcast type of the field definition to its parent comms::field::Bundle type in order to have access t...</div><div class="ttdef"><b>Definition:</b> Bundle.h:761</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a></div><div class="ttdoc">Defines a &quot;variant&quot; field, that can contain any of the provided ones.</div><div class="ttdef"><b>Definition:</b> Variant.h:83</div></div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition:</b> Field.h:32</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html_a6e4dd4d3fa0537593ba42374aaf542e0"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">comms::field::Variant::initField</a></div><div class="ttdeci">std::tuple_element&lt; TIdx, Members &gt;::type &amp; initField(TArgs &amp;&amp;... args)</div><div class="ttdoc">Construct and initialise specified contained field in the internal buffer.</div><div class="ttdef"><b>Definition:</b> Variant.h:346</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html_a20b3323d7a94321da9acadc097bc5f36"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36">comms::field::Variant::currentField</a></div><div class="ttdeci">std::size_t currentField() const</div><div class="ttdoc">Get index of the current field (within the Members tuple).</div><div class="ttdef"><b>Definition:</b> Variant.h:256</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html_a973a95f2928609a140296b28957b130b"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">comms::field::Variant::COMMS_VARIANT_MEMBERS_ACCESS</a></div><div class="ttdeci">#define COMMS_VARIANT_MEMBERS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to the members of comms::field::Variant field.</div><div class="ttdef"><b>Definition:</b> Variant.h:670</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
