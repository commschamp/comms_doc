<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1frame.html">frame</a></li><li class="navelem"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">FrameLayerBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classcomms_1_1frame_1_1FrameLayerBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="FrameLayerBase_8h_source.html">comms/frame/FrameLayerBase.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TField, typename TNextLayer, typename TDerived, typename... TOptions&gt;<br />
class comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;</div><p>Base class for all the middle (non <a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">MsgDataLayer</a>) protocol transport layers. </p>
<p>Provides all the default and/or common functionality for the middle transport layer. The inheriting actual layer class may use and/or override the provided functionality by redefining member function with the same signature. The <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> is stored as a private data meber. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td>Every middle layer will have a field containing extra information for this layer. This template parameter is a type of such field. </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next layer this one wraps and forwards the calls to. </td></tr>
    <tr><td class="paramname">TDerived</td><td>Actual protocol layer class that extends this one. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Extra options. Supported ones are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FrameLayerForceReadUntilDataSplit.html">comms::option::def::FrameLayerForceReadUntilDataSplit</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FrameLayerDisallowReadUntilDataSplit.html">comms::option::def::FrameLayerDisallowReadUntilDataSplit</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1frame_1_1FrameLayerBase.png" usemap="#comms::frame::FrameLayerBase_3C_20TField_2C_20TNextLayer_2C_20TDerived_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::frame::FrameLayerBase_3C_20TField_2C_20TNextLayer_2C_20TDerived_2C_20TOptions_20_3E_map" name="comms::frame::FrameLayerBase_3C_20TField_2C_20TNextLayer_2C_20TDerived_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1frame_1_1ChecksumLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter..." alt="comms::frame::ChecksumLayer&lt; TField, TCalc, TNextLayer, TOptions &gt;" shape="rect" coords="0,56,508,80"/>
<area href="classcomms_1_1frame_1_1ChecksumPrefixLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter..." alt="comms::frame::ChecksumPrefixLayer&lt; TField, TCalc, TNextLayer, TOptions &gt;" shape="rect" coords="518,56,1026,80"/>
<area href="classcomms_1_1frame_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe..." alt="comms::frame::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;" shape="rect" coords="1036,56,1544,80"/>
<area href="classcomms_1_1frame_1_1MsgSizeLayer.html" title="Protocol layer that uses size field as a prefix to all the subsequent data written by other (next) la..." alt="comms::frame::MsgSizeLayer&lt; TField, TNextLayer, TOptions &gt;" shape="rect" coords="1554,56,2062,80"/>
<area href="classcomms_1_1frame_1_1SyncPrefixLayer.html" title="Protocol layer that uses &quot;sync&quot; field as a prefix to all the subsequent data written by other (next) ..." alt="comms::frame::SyncPrefixLayer&lt; TField, TNextLayer, TOptions &gt;" shape="rect" coords="2072,56,2580,80"/>
<area href="classcomms_1_1frame_1_1TransportValueLayer.html" title="Protocol layer that reads a value from transport wrapping and reassigns it to appropriate &quot;extra tran..." alt="comms::frame::TransportValueLayer&lt; TField, TIdx, TNextLayer, TOptions &gt;" shape="rect" coords="2590,56,3098,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ad1f0f0aa396ce943b4ec390b3ed7f2" id="r_a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> = typename std::decay&lt; decltype(std::tuple_cat(std::declval&lt; std::tuple&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &gt; &gt;(), std::declval&lt; typename TNextLayer::AllFields &gt;())) &gt;::type</td></tr>
<tr class="memdesc:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of all the fields of all the transport layers wrapped in std::tuple.  <br /></td></tr>
<tr class="separator:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc80991ee4ec52da289df5b9f14ebedd" id="r_acc80991ee4ec52da289df5b9f14ebedd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acc80991ee4ec52da289df5b9f14ebedd">AllMessages</a> = typename NextLayer::AllMessages</td></tr>
<tr class="memdesc:acc80991ee4ec52da289df5b9f14ebedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported messages.  <br /></td></tr>
<tr class="separator:acc80991ee4ec52da289df5b9f14ebedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981a7fd16d6acde6193c85320e9ef33c" id="r_a981a7fd16d6acde6193c85320e9ef33c"><td class="memItemLeft" align="right" valign="top"><a id="a981a7fd16d6acde6193c85320e9ef33c" name="a981a7fd16d6acde6193c85320e9ef33c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> = TField</td></tr>
<tr class="memdesc:a981a7fd16d6acde6193c85320e9ef33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field used for this layer. <br /></td></tr>
<tr class="separator:a981a7fd16d6acde6193c85320e9ef33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a1acafcee59b824a28a4f9552b5e6" id="r_a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2c2a1acafcee59b824a28a4f9552b5e6">MsgFactory</a> = typename NextLayer::MsgFactory</td></tr>
<tr class="memdesc:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message factory.  <br /></td></tr>
<tr class="separator:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac463b9d9c21a2fac144bbc1c5ca8c" id="r_a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> = typename details::FrameLayerMsgPtr&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &gt;::Type</td></tr>
<tr class="memdesc:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to the message.  <br /></td></tr>
<tr class="separator:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7cf7de9dc3d68ab6680376b5984fd" id="r_ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memItemLeft" align="right" valign="top"><a id="ae5e7cf7de9dc3d68ab6680376b5984fd" name="ae5e7cf7de9dc3d68ab6680376b5984fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NextLayer</b> = TNextLayer</td></tr>
<tr class="memdesc:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the next transport layer. <br /></td></tr>
<tr class="separator:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc6c5d8fc6a9d3971a2c43e8d541bfe" id="r_a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memItemLeft" align="right" valign="top"><a id="a3fc6c5d8fc6a9d3971a2c43e8d541bfe" name="a3fc6c5d8fc6a9d3971a2c43e8d541bfe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParsedOptions</b> = details::FrameLayerBaseOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options structure. <br /></td></tr>
<tr class="separator:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac36d4f6d86cc17bfba914b57f2b4989" id="r_aac36d4f6d86cc17bfba914b57f2b4989"><td class="memItemLeft" align="right" valign="top"><a id="aac36d4f6d86cc17bfba914b57f2b4989" name="aac36d4f6d86cc17bfba914b57f2b4989"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThisLayer</b> = TDerived</td></tr>
<tr class="memdesc:aac36d4f6d86cc17bfba914b57f2b4989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual derived class. <br /></td></tr>
<tr class="separator:aac36d4f6d86cc17bfba914b57f2b4989"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e53be1ef5c11213f30a591d0036a02a" id="r_a0e53be1ef5c11213f30a591d0036a02a"><td class="memItemLeft" align="right" valign="top"><a id="a0e53be1ef5c11213f30a591d0036a02a" name="a0e53be1ef5c11213f30a591d0036a02a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FrameLayerBase</b> (const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">FrameLayerBase</a> &amp;)=default</td></tr>
<tr class="memdesc:a0e53be1ef5c11213f30a591d0036a02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a0e53be1ef5c11213f30a591d0036a02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ee3f9d05ec3755e5c55fdcce1caf61" id="r_a81ee3f9d05ec3755e5c55fdcce1caf61"><td class="memItemLeft" align="right" valign="top"><a id="a81ee3f9d05ec3755e5c55fdcce1caf61" name="a81ee3f9d05ec3755e5c55fdcce1caf61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FrameLayerBase</b> (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">FrameLayerBase</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a81ee3f9d05ec3755e5c55fdcce1caf61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a81ee3f9d05ec3755e5c55fdcce1caf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b173f5862b580f85e837bdc104d8da" id="r_ad2b173f5862b580f85e837bdc104d8da"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:ad2b173f5862b580f85e837bdc104d8da"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad2b173f5862b580f85e837bdc104d8da">FrameLayerBase</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad2b173f5862b580f85e837bdc104d8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ad2b173f5862b580f85e837bdc104d8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22513edc415fb776429e57026d575133" id="r_a22513edc415fb776429e57026d575133"><td class="memItemLeft" align="right" valign="top"><a id="a22513edc415fb776429e57026d575133" name="a22513edc415fb776429e57026d575133"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~FrameLayerBase</b> () noexcept=default</td></tr>
<tr class="memdesc:a22513edc415fb776429e57026d575133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desctructor. <br /></td></tr>
<tr class="separator:a22513edc415fb776429e57026d575133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274" id="r_a142273e7f2f01e97ed167a76842fe274"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a142273e7f2f01e97ed167a76842fe274">createMsg</a> (TId &amp;&amp;id, unsigned idx=0)</td></tr>
<tr class="memdesc:a142273e7f2f01e97ed167a76842fe274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <br /></td></tr>
<tr class="separator:a142273e7f2f01e97ed167a76842fe274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a" id="r_a89678a480d27764451edf08a88cd5a8a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a89678a480d27764451edf08a88cd5a8a">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a89678a480d27764451edf08a88cd5a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:a89678a480d27764451edf08a88cd5a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04" id="r_aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate</a> (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:aa0948d39fa0c0ec936597a0115b5ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16df1e557ebd25b1d2cc650c6fc4de9" id="r_aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9">length</a> () const</td></tr>
<tr class="memdesc:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information.  <br /></td></tr>
<tr class="separator:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c" id="r_a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3a6baa01adbb498450fb6d0043747d2c">length</a> (const TMsg &amp;msg) const</td></tr>
<tr class="memdesc:a3a6baa01adbb498450fb6d0043747d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information + length of the provided message.  <br /></td></tr>
<tr class="separator:a3a6baa01adbb498450fb6d0043747d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520a1d3b2f062fe9674df67001631c5b" id="r_a520a1d3b2f062fe9674df67001631c5b"><td class="memItemLeft" align="right" valign="top"><a id="a520a1d3b2f062fe9674df67001631c5b" name="a520a1d3b2f062fe9674df67001631c5b"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> ()</td></tr>
<tr class="memdesc:a520a1d3b2f062fe9674df67001631c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the next layer object. <br /></td></tr>
<tr class="separator:a520a1d3b2f062fe9674df67001631c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023b519fa5cdb99224a3e784da3809bf" id="r_a023b519fa5cdb99224a3e784da3809bf"><td class="memItemLeft" align="right" valign="top"><a id="a023b519fa5cdb99224a3e784da3809bf" name="a023b519fa5cdb99224a3e784da3809bf"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> () const</td></tr>
<tr class="memdesc:a023b519fa5cdb99224a3e784da3809bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to the next layer object. <br /></td></tr>
<tr class="separator:a023b519fa5cdb99224a3e784da3809bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e97d2d0e677c89c0256d19bf8ef423e" id="r_a4e97d2d0e677c89c0256d19bf8ef423e"><td class="memItemLeft" align="right" valign="top"><a id="a4e97d2d0e677c89c0256d19bf8ef423e" name="a4e97d2d0e677c89c0256d19bf8ef423e"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">FrameLayerBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">FrameLayerBase</a> &amp;)=default</td></tr>
<tr class="memdesc:a4e97d2d0e677c89c0256d19bf8ef423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:a4e97d2d0e677c89c0256d19bf8ef423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d" id="r_acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:acba89d4affe6bec7637ee8c0b82b358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence.  <br /></td></tr>
<tr class="separator:acba89d4affe6bec7637ee8c0b82b358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b" id="r_ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440" id="r_a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a2ae49cfdaedce94ea30ee99268cfe440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload.  <br /></td></tr>
<tr class="separator:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61" id="r_ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad336a6921d7e19c3c1434ad3e4b1ef61">readFromDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2" id="r_a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload).  <br /></td></tr>
<tr class="separator:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d" id="r_a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload) while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309537df4097929b25a0a51810aa5037" id="r_a309537df4097929b25a0a51810aa5037"><td class="memItemLeft" align="right" valign="top"><a id="a309537df4097929b25a0a51810aa5037" name="a309537df4097929b25a0a51810aa5037"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> ()</td></tr>
<tr class="memdesc:a309537df4097929b25a0a51810aa5037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this layer object. <br /></td></tr>
<tr class="separator:a309537df4097929b25a0a51810aa5037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca789b13ce3357178af9845a6e8bac" id="r_af7ca789b13ce3357178af9845a6e8bac"><td class="memItemLeft" align="right" valign="top"><a id="af7ca789b13ce3357178af9845a6e8bac" name="af7ca789b13ce3357178af9845a6e8bac"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> () const</td></tr>
<tr class="memdesc:af7ca789b13ce3357178af9845a6e8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to this layer object. <br /></td></tr>
<tr class="separator:af7ca789b13ce3357178af9845a6e8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff" id="r_afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afa0a267db85e3b4dd80084f08ad916ff">update</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:afa0a267db85e3b4dd80084f08ad916ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:afa0a267db85e3b4dd80084f08ad916ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59" id="r_a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0" id="r_a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4d9adf6f4309420255cd34b92d69f0d0">updateFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a4d9adf6f4309420255cd34b92d69f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42" id="r_a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TIter &gt; </td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached</a> (TAllFields &amp;allFields, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a3ef60b383ca7c874cb16f69c70814c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a3ef60b383ca7c874cb16f69c70814c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2" id="r_a13f74156f9545929fb01967ff9e10da2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a13f74156f9545929fb01967ff9e10da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence.  <br /></td></tr>
<tr class="separator:a13f74156f9545929fb01967ff9e10da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd" id="r_a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd">writeFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence while caching the written transport information fields.  <br /></td></tr>
<tr class="separator:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27" id="r_a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields &gt; </td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a88bfb24459f8ff76e4e6639eb89abc27">accessCachedField</a> (TAllFields &amp;allFields) -&gt; decltype(std::get&lt; std::tuple_size&lt; typename std::decay&lt; TAllFields &gt;::type &gt;::value - std::tuple_size&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> &gt;::value &gt;(allFields))</td></tr>
<tr class="memdesc:a88bfb24459f8ff76e4e6639eb89abc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access appropriate field from "cached" bundle of all the frame fields.  <br /></td></tr>
<tr class="separator:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfe2826c179e40898af86e199502c66" id="r_a3dfe2826c179e40898af86e199502c66"><td class="memItemLeft" align="right" valign="top"><a id="a3dfe2826c179e40898af86e199502c66" name="a3dfe2826c179e40898af86e199502c66"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSplitRead</b> ()</td></tr>
<tr class="memdesc:a3dfe2826c179e40898af86e199502c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether split read "until" and "from" data layer is allowed. <br /></td></tr>
<tr class="separator:a3dfe2826c179e40898af86e199502c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fcccc4a966bdfb70110ba0007c6b15" id="r_a20fcccc4a966bdfb70110ba0007c6b15"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength</a> ()</td></tr>
<tr class="memdesc:a20fcccc4a966bdfb70110ba0007c6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval.  <br /></td></tr>
<tr class="separator:a20fcccc4a966bdfb70110ba0007c6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389cc74c40f60c95850a0090bb8a6dc" id="r_a6389cc74c40f60c95850a0090bb8a6dc"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a6389cc74c40f60c95850a0090bb8a6dc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a6389cc74c40f60c95850a0090bb8a6dc">doFieldLength</a> (const TMsg &amp;)</td></tr>
<tr class="memdesc:a6389cc74c40f60c95850a0090bb8a6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval when message is known.  <br /></td></tr>
<tr class="separator:a6389cc74c40f60c95850a0090bb8a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aca13af584dacadfe6aec31d35ec10938" id="r_aca13af584dacadfe6aec31d35ec10938"><td class="memItemLeft" align="right" valign="top"><a id="aca13af584dacadfe6aec31d35ec10938" name="aca13af584dacadfe6aec31d35ec10938"></a>
static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>NumOfLayers</b> = 1 + NextLayer::NumOfLayers</td></tr>
<tr class="memdesc:aca13af584dacadfe6aec31d35ec10938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constant indicating amount of transport layers used. <br /></td></tr>
<tr class="separator:aca13af584dacadfe6aec31d35ec10938"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5" id="r_a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6" id="r_aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplParams" colspan="2">template&lt;typename TId , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId</a> (TId val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:aed22a9e088da6512c2c62abc05f0bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message ID information if such is requested.  <br /></td></tr>
<tr class="separator:aed22a9e088da6512c2c62abc05f0bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc" id="r_a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4972642e1ab5e830baa21369c9266cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message index information if such is requested.  <br /></td></tr>
<tr class="separator:a4972642e1ab5e830baa21369c9266cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304" id="r_a4c2a5c54263f8843c4549460e3984304"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4c2a5c54263f8843c4549460e3984304">updateMissingSize</a> (const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;field, std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4c2a5c54263f8843c4549460e3984304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4c2a5c54263f8843c4549460e3984304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e" id="r_a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize</a> (std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a" id="r_ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ac4c4e7ddfbadca13b1fb358dfce0c25a">doReadField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the layer field.  <br /></td></tr>
<tr class="separator:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c" id="r_a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7022da54d93eb0dcaca71c525e899a3c">doWriteField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7022da54d93eb0dcaca71c525e899a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the layer field.  <br /></td></tr>
<tr class="separator:a7022da54d93eb0dcaca71c525e899a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b" id="r_a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TAllFields &gt; </td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a43ca1633d44496cd4f6be376b93e741b">getField</a> (TAllFields &amp;allFields)</td></tr>
<tr class="memdesc:a43ca1633d44496cd4f6be376b93e741b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve reference to a layer specific field out of all fields.  <br /></td></tr>
<tr class="separator:a43ca1633d44496cd4f6be376b93e741b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145" id="r_afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef</a> ()</td></tr>
<tr class="memdesc:afb7a4edd007cd796ce28399afd7fb145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether type is actual message object.  <br /></td></tr>
<tr class="separator:afb7a4edd007cd796ce28399afd7fb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5" id="r_adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#adca278d06b818f3723eaf96b09e2e2b5">resetMsg</a> (TMsg &amp;msg)</td></tr>
<tr class="memdesc:adca278d06b818f3723eaf96b09e2e2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>).  <br /></td></tr>
<tr class="separator:adca278d06b818f3723eaf96b09e2e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875" id="r_ad2251c4f9daad4588053c02993939875"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad2251c4f9daad4588053c02993939875">toMsgPtr</a> (TMsg &amp;msg) -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;()))</td></tr>
<tr class="memdesc:ad2251c4f9daad4588053c02993939875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the message object.  <br /></td></tr>
<tr class="separator:ad2251c4f9daad4588053c02993939875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a45909af8482a03654e5dcc4ec0ffdf4c" id="r_a45909af8482a03654e5dcc4ec0ffdf4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(...)&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td></tr>
<tr class="memdesc:a45909af8482a03654e5dcc4ec0ffdf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a45909af8482a03654e5dcc4ec0ffdf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319023e7ba5755efed4c67fd9f9bb3d3" id="r_a319023e7ba5755efed4c67fd9f9bb3d3"><td class="memItemLeft" align="right" valign="top"><a id="a319023e7ba5755efed4c67fd9f9bb3d3" name="a319023e7ba5755efed4c67fd9f9bb3d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_FRAME_LAYERS_ACCESS_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:a319023e7ba5755efed4c67fd9f9bb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a> <br /></td></tr>
<tr class="separator:a319023e7ba5755efed4c67fd9f9bb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80111e86836c752b860f6ed1aa112d25" id="r_a80111e86836c752b860f6ed1aa112d25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a80111e86836c752b860f6ed1aa112d25">COMMS_FRAME_LAYERS_ACCESS_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a80111e86836c752b860f6ed1aa112d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a80111e86836c752b860f6ed1aa112d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c913a2a9a079b15e3fbfeada67d30d7" id="r_a0c913a2a9a079b15e3fbfeada67d30d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a0c913a2a9a079b15e3fbfeada67d30d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a0c913a2a9a079b15e3fbfeada67d30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ac8e9e751f98efa089c980644710f3" id="r_a43ac8e9e751f98efa089c980644710f3"><td class="memItemLeft" align="right" valign="top"><a id="a43ac8e9e751f98efa089c980644710f3" name="a43ac8e9e751f98efa089c980644710f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_FRAME_LAYERS_NAMES_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:a43ac8e9e751f98efa089c980644710f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7" title="Provide names and convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_NAMES()</a> <br /></td></tr>
<tr class="separator:a43ac8e9e751f98efa089c980644710f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8a9056542039e69d95b8af99d3bbaf" id="r_a0e8a9056542039e69d95b8af99d3bbaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0e8a9056542039e69d95b8af99d3bbaf">COMMS_FRAME_LAYERS_NAMES_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a0e8a9056542039e69d95b8af99d3bbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a0e8a9056542039e69d95b8af99d3bbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ad1f0f0aa396ce943b4ec390b3ed7f2" name="a8ad1f0f0aa396ce943b4ec390b3ed7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad1f0f0aa396ce943b4ec390b3ed7f2">&#9670;&#160;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllFields =  typename std::decay&lt; decltype( std::tuple_cat( std::declval&lt;std::tuple&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a>&gt; &gt;(), std::declval&lt;typename TNextLayer::AllFields&gt;()) ) &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of all the fields of all the transport layers wrapped in std::tuple. </p>
<p>The <a class="el" href="classcomms_1_1Field.html">Field</a> type is prepended to the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> and reported as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> of this one. </p>

</div>
</div>
<a id="acc80991ee4ec52da289df5b9f14ebedd" name="acc80991ee4ec52da289df5b9f14ebedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc80991ee4ec52da289df5b9f14ebedd">&#9670;&#160;</a></span>AllMessages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllMessages =  typename NextLayer::AllMessages</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All supported messages. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a2c2a1acafcee59b824a28a4f9552b5e6" name="a2c2a1acafcee59b824a28a4f9552b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a1acafcee59b824a28a4f9552b5e6">&#9670;&#160;</a></span>MsgFactory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgFactory =  typename NextLayer::MsgFactory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of message factory. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a68ac463b9d9c21a2fac144bbc1c5ca8c" name="a68ac463b9d9c21a2fac144bbc1c5ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ac463b9d9c21a2fac144bbc1c5ca8c">&#9670;&#160;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgPtr =  typename details::FrameLayerMsgPtr&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of pointer to the message. </p>
<p>Same as NextLayer::MsgPtr or void if such doesn't exist. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2b173f5862b580f85e837bdc104d8da" name="ad2b173f5862b580f85e837bdc104d8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b173f5862b580f85e837bdc104d8da">&#9670;&#160;</a></span>FrameLayerBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::FrameLayerBase </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Forwards all the parameters to the constructor of the embedded <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be passed to the constructor of the next layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88bfb24459f8ff76e4e6639eb89abc27" name="a88bfb24459f8ff76e4e6639eb89abc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bfb24459f8ff76e4e6639eb89abc27">&#9670;&#160;</a></span>accessCachedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::accessCachedField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;std::tuple_size&lt;typename std::decay&lt;TAllFields&gt;::type&gt;::value - std::tuple_size&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a>&gt;::value&gt;(allFields))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access appropriate field from "cached" bundle of all the frame fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFields</td><td>All fields of the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to requested field. </dd></dl>

</div>
</div>
<a id="a142273e7f2f01e97ed167a76842fe274" name="a142273e7f2f01e97ed167a76842fe274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142273e7f2f01e97ed167a76842fe274">&#9670;&#160;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>The default implementation is to forwards this call to the next layer. One of the layers (usually <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::frame::MsgIdLayer</a>) hides and overrides this implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to allocated message object </dd></dl>

</div>
</div>
<a id="a20fcccc4a966bdfb70110ba0007c6b15" name="a20fcccc4a966bdfb70110ba0007c6b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fcccc4a966bdfb70110ba0007c6b15">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. </dd></dl>

</div>
</div>
<a id="a6389cc74c40f60c95850a0090bb8a6dc" name="a6389cc74c40f60c95850a0090bb8a6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389cc74c40f60c95850a0090bb8a6dc">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval when message is known. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. <br  />
 </dd></dl>

</div>
</div>
<a id="ac4c4e7ddfbadca13b1fb358dfce0c25a" name="ac4c4e7ddfbadca13b1fb358dfce0c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c4e7ddfbadca13b1fb358dfce0c25a">&#9670;&#160;</a></span>doReadField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doReadField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a89678a480d27764451edf08a88cd5a8a" name="a89678a480d27764451edf08a88cd5a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89678a480d27764451edf08a88cd5a8a">&#9670;&#160;</a></span>doUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate()</a> but also receiving recently written message object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0948d39fa0c0ec936597a0115b5ec04" name="aa0948d39fa0c0ec936597a0115b5ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0948d39fa0c0ec936597a0115b5ec04">&#9670;&#160;</a></span>doUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>It will be invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, unless the derived class provides its own <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate()</a> member function to override the default behavior.<br  />
 This function in this layer does nothing, just advances the iterator by the length of the <a class="el" href="classcomms_1_1Field.html">Field</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7022da54d93eb0dcaca71c525e899a3c" name="a7022da54d93eb0dcaca71c525e899a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022da54d93eb0dcaca71c525e899a3c">&#9670;&#160;</a></span>doWriteField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doWriteField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="a43ca1633d44496cd4f6be376b93e741b" name="a43ca1633d44496cd4f6be376b93e741b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ca1633d44496cd4f6be376b93e741b">&#9670;&#160;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::getField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve reference to a layer specific field out of all fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field in tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb7a4edd007cd796ce28399afd7fb145" name="afb7a4edd007cd796ce28399afd7fb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7a4edd007cd796ce28399afd7fb145">&#9670;&#160;</a></span>isMessageObjRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::isMessageObjRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether type is actual message object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>T</b> type is extending <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>, <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a id="aa16df1e557ebd25b1d2cc650c6fc4de9" name="aa16df1e557ebd25b1d2cc650c6fc4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16df1e557ebd25b1d2cc650c6fc4de9">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information. </p>
<p>The message data always get wrapped with transport information to be successfully delivered to and unpacked on the other side. This function return remaining length of the transport information. It performs a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength()</a> member function to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a3a6baa01adbb498450fb6d0043747d2c" name="a3a6baa01adbb498450fb6d0043747d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6baa01adbb498450fb6d0043747d2c">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information + length of the provided message. </p>
<p>This function usually gets called when there is a need to identify the size of the buffer required to write provided message wrapped in the transport information. This function is very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9" title="Get remaining length of wrapping transport information.">length()</a>, but adds also length of the message. It performs a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength()</a> member function with message parameter to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="acba89d4affe6bec7637ee8c0b82b358d" name="acba89d4affe6bec7637ee8c0b82b358d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba89d4affe6bec7637ee8c0b82b358d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence. </p>
<p>The function will invoke <b>doRead()</b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader, <span class="keyword">typename</span>... TExtraValues&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a>&amp; field, <span class="comment">// field object used to read required data</span></div>
<div class="line">    TMsg&amp; msg, <span class="comment">// Ref to smart pointer to message object, or message object itself</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for reading</span></div>
<div class="line">    std::size_t size, <span class="comment">// size of the remaining data</span></div>
<div class="line">    TNextLayerReader&amp;&amp; nextLayerReader, <span class="comment">// next layer reader object</span></div>
<div class="line">    TExtraValues... extraValues)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer read, such as reading the field value</span></div>
<div class="line">    <span class="keyword">auto</span> es = field.read(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform read operation</span></div>
<div class="line">    es = nextLayerReader.read(msg, iter, size - field.length(), extraValues...);</div>
<div class="line">    ... <span class="comment">// internal logic after next layer read if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1FrameLayerBase_html_a981a7fd16d6acde6193c85320e9ef33c"><div class="ttname"><a href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">comms::frame::FrameLayerBase::Field</a></div><div class="ttdeci">TField Field</div><div class="ttdoc">Type of the field used for this layer.</div><div class="ttdef"><b>Definition</b> FrameLayerBase.h:63</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition</b> ErrorStatus.h:17</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerReader.read()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> member function. The implemented <b>doRead()</b> member function also may use the following inherited protected member to set values of variadic parameters in case they are provided. </p><ul>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize()</a> - to calculate update missing size if such is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize()</a> - to set specific value as missing size if suce information is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId()</a> - to set the value of message id </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex()</a> - to set the value of message index. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions: <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>, <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>, <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>, <a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae9fdcbc3382f10452a6d8d0edfd5a41b" name="ae9fdcbc3382f10452a6d8d0edfd5a41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fdcbc3382f10452a6d8d0edfd5a41b">&#9670;&#160;</a></span>readFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b>doRead()</b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a2ae49cfdaedce94ea30ee99268cfe440" name="a2ae49cfdaedce94ea30ee99268cfe440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae49cfdaedce94ea30ee99268cfe440">&#9670;&#160;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="ad336a6921d7e19c3c1434ad3e4b1ef61" name="ad336a6921d7e19c3c1434ad3e4b1ef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad336a6921d7e19c3c1434ad3e4b1ef61">&#9670;&#160;</a></span>readFromDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload while caching the read transport information fields. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a66e572e2e9ade86b1152dc8523d4d5a2" name="a66e572e2e9ade86b1152dc8523d4d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e572e2e9ade86b1152dc8523d4d5a2">&#9670;&#160;</a></span>readUntilData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload). </p>
<p>Same as <b>read</b> by stops read operation when data layer is reached. Expected to be followed by a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
missingSize output value is updated if and only if function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </dd></dl>

</div>
</div>
<a id="a77f6e959f54ce0b2129a62bd3559fc3d" name="a77f6e959f54ce0b2129a62bd3559fc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6e959f54ce0b2129a62bd3559fc3d">&#9670;&#160;</a></span>readUntilDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload) while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b>doRead()</b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="adca278d06b818f3723eaf96b09e2e2b5" name="adca278d06b818f3723eaf96b09e2e2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca278d06b818f3723eaf96b09e2e2b5">&#9670;&#160;</a></span>resetMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::resetMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>). </p>
<p>Does nothing if passed parameter is actual message object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a4b3dc4d11099ca235fa82fc099d5eae5" name="a4b3dc4d11099ca235fa82fc099d5eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dc4d11099ca235fa82fc099d5eae5">&#9670;&#160;</a></span>setMissingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the missing size information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed22a9e088da6512c2c62abc05f0bda6" name="aed22a9e088da6512c2c62abc05f0bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed22a9e088da6512c2c62abc05f0bda6">&#9670;&#160;</a></span>setMsgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgId </td>
          <td>(</td>
          <td class="paramtype">TId&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message ID information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4972642e1ab5e830baa21369c9266cbc" name="a4972642e1ab5e830baa21369c9266cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4972642e1ab5e830baa21369c9266cbc">&#9670;&#160;</a></span>setMsgIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message index information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2251c4f9daad4588053c02993939875" name="ad2251c4f9daad4588053c02993939875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2251c4f9daad4588053c02993939875">&#9670;&#160;</a></span>toMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::toMsgPtr </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the message object. </p>
<p>The function works seamlessly for both smart pointer and reference to the real object </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="afa0a267db85e3b4dd80084f08ad916ff" name="afa0a267db85e3b4dd80084f08ad916ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a267db85e3b4dd80084f08ad916ff">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> but also receiving recently written message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a18fb6a05acc5d1091b7c8e419d06cb59" name="a18fb6a05acc5d1091b7c8e419d06cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fb6a05acc5d1091b7c8e419d06cb59">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Sometimes, when NON random access iterator is used for writing (for example std::back_insert_iterator), some transport data cannot be properly written. In this case, <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. When such status is returned it is necessary to call <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator on the written buffer to update written dummy information with proper values.<br  />
 The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided (or inherited) by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a>&amp; field, <span class="comment">// field object to update and re-write if necessary</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for updateing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Number of remaning bytes in the output buffer.</span></div>
<div class="line">    TNextLayerUpdater&amp;&amp; nextLayerUpdater <span class="comment">// next layer updater object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer update, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and re-writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform update operation</span></div>
<div class="line">    es = nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1FrameLayerBase_html_aa0948d39fa0c0ec936597a0115b5ec04"><div class="ttname"><a href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">comms::frame::FrameLayerBase::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Default implementation of the &quot;update&quot; functaionality.</div><div class="ttdef"><b>Definition</b> FrameLayerBase.h:706</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a></b> member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4d9adf6f4309420255cd34b92d69f0d0" name="a4d9adf6f4309420255cd34b92d69f0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9adf6f4309420255cd34b92d69f0d0">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, but adds "msg" parameter to access message object if needed.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a3ef60b383ca7c874cb16f69c70814c42" name="a3ef60b383ca7c874cb16f69c70814c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef60b383ca7c874cb16f69c70814c42">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> member function, but adds "allFields" parameter to store raw data of the message.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4c2a5c54263f8843c4549460e3984304" name="a4c2a5c54263f8843c4549460e3984304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2a5c54263f8843c4549460e3984304">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> read operation of which has failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2375d4960ee9b59f0b059ccb43a31e" name="a8e2375d4960ee9b59f0b059ccb43a31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2375d4960ee9b59f0b059ccb43a31e">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13f74156f9545929fb01967ff9e10da2" name="a13f74156f9545929fb01967ff9e10da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f74156f9545929fb01967ff9e10da2">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialise message into output data sequence. </p>
<p>The function will invoke <b>doWrite()</b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doWrite(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a>&amp; field, <span class="comment">// field object used to update and write required data</span></div>
<div class="line">    <span class="keyword">const</span> TMsg&amp; msg, <span class="comment">// reference to ready to be sent message object</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for writing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Max number of bytes that can be written.</span></div>
<div class="line">    TNextLayerWriter&amp;&amp; nextLayerWriter <span class="comment">// next layer writer object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer write, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform write operation</span></div>
<div class="line">    es = nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The signature of the <b>nextLayerWriter.write()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> member function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a2b4866367d16932a2a0a6632c7e2c3fd" name="a2b4866367d16932a2a0a6632c7e2c3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4866367d16932a2a0a6632c7e2c3fd">&#9670;&#160;</a></span>writeFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::writeFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialise message into output data sequence while caching the written transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> member function, but adds "allFields" parameter to store raw data of the message. The function will also invoke the same <b>doWrite()</b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to the message object that is being written, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a45909af8482a03654e5dcc4ec0ffdf4c" name="a45909af8482a03654e5dcc4ec0ffdf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45909af8482a03654e5dcc4ec0ffdf4c">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>The first argument is a name for innermost layer (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>), while the last one is the name for the outermost one. </p>

</div>
</div>
<a id="a80111e86836c752b860f6ed1aa112d25" name="a80111e86836c752b860f6ed1aa112d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80111e86836c752b860f6ed1aa112d25">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_ACCESS_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_ACCESS_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a>, but the arguments are expected to be in reverse order, i.e. the first argument is the name of the outermost layer, while the last one is the name for the innermost one (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>) </p>

</div>
</div>
<a id="a0c913a2a9a079b15e3fbfeada67d30d7" name="a0c913a2a9a079b15e3fbfeada67d30d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c913a2a9a079b15e3fbfeada67d30d7">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_DO_LAYER_TYPE_ALIAS(Base, __VA_ARGS__) \</div>
<div class="line">    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<a id="a0e8a9056542039e69d95b8af99d3bbaf" name="a0e8a9056542039e69d95b8af99d3bbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8a9056542039e69d95b8af99d3bbaf">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_NAMES_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_NAMES_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a80111e86836c752b860f6ed1aa112d25" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS_OUTER()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/frame/<a class="el" href="FrameLayerBase_8h_source.html">FrameLayerBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
