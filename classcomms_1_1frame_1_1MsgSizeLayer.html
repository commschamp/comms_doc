<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::frame::MsgSizeLayer&lt; TField, TNextLayer, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1frame.html">frame</a></li><li class="navelem"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classcomms_1_1frame_1_1MsgSizeLayer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comms::frame::MsgSizeLayer&lt; TField, TNextLayer, TOptions &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="frame_2MsgSizeLayer_8h_source.html">comms/frame/MsgSizeLayer.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TField, typename TNextLayer, typename... TOptions&gt;<br />
class comms::frame::MsgSizeLayer&lt; TField, TNextLayer, TOptions &gt;</div><p>Protocol layer that uses size field as a prefix to all the subsequent data written by other (next) layers. </p>
<p>The main purpose of this layer is to provide information about the remaining size of the serialised message. This layer is a mid level layer, expects other mid level layer or <a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html" title="Message data layer.">MsgDataLayer</a> to be its next one. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td>Type of the field that describes the "size" field. </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next transport layer in frame. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Default functionality extension options. Supported options are: <ul>
<li><a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> - Use this option to provide a class name of the extending class, which can be used to extend existing functionality. See also <a class="el" href="page_custom_size_layer.html">Defining Custom Message Size Frame Layer</a> tutorial page. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::frame::MsgSizeLayer&lt; TField, TNextLayer, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1frame_1_1MsgSizeLayer.png" usemap="#comms::frame::MsgSizeLayer_3C_20TField_2C_20TNextLayer_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::frame::MsgSizeLayer_3C_20TField_2C_20TNextLayer_2C_20TOptions_20_3E_map" name="comms::frame::MsgSizeLayer_3C_20TField_2C_20TNextLayer_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1frame_1_1FrameLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers." alt="comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;" shape="rect" coords="0,0,444,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ad1f0f0aa396ce943b4ec390b3ed7f2" id="r_a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> = typename std::decay&lt; decltype(std::tuple_cat(std::declval&lt; std::tuple&lt; <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &gt; &gt;(), std::declval&lt; typename TNextLayer::AllFields &gt;())) &gt;::type</td></tr>
<tr class="memdesc:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of all the fields of all the transport layers wrapped in std::tuple.  <br /></td></tr>
<tr class="separator:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc80991ee4ec52da289df5b9f14ebedd" id="r_acc80991ee4ec52da289df5b9f14ebedd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acc80991ee4ec52da289df5b9f14ebedd">AllMessages</a> = typename NextLayer::AllMessages</td></tr>
<tr class="memdesc:acc80991ee4ec52da289df5b9f14ebedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported messages.  <br /></td></tr>
<tr class="separator:acc80991ee4ec52da289df5b9f14ebedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3bcfd230cd05ff7fe1e862ecb576cd" id="r_a8a3bcfd230cd05ff7fe1e862ecb576cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a8a3bcfd230cd05ff7fe1e862ecb576cd">ExtendingClass</a> = typename ParsedOptionsInternal::ExtendingClass</td></tr>
<tr class="memdesc:a8a3bcfd230cd05ff7fe1e862ecb576cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of real extending class.  <br /></td></tr>
<tr class="separator:a8a3bcfd230cd05ff7fe1e862ecb576cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac249984fc1139e98baacb245842d38ac" id="r_ac249984fc1139e98baacb245842d38ac"><td class="memItemLeft" align="right" valign="top"><a id="ac249984fc1139e98baacb245842d38ac" name="ac249984fc1139e98baacb245842d38ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> = typename BaseImpl::Field</td></tr>
<tr class="memdesc:ac249984fc1139e98baacb245842d38ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field object used to read/write remaining size value. <br /></td></tr>
<tr class="separator:ac249984fc1139e98baacb245842d38ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a1acafcee59b824a28a4f9552b5e6" id="r_a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2c2a1acafcee59b824a28a4f9552b5e6">MsgFactory</a> = typename NextLayer::MsgFactory</td></tr>
<tr class="memdesc:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message factory.  <br /></td></tr>
<tr class="separator:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac463b9d9c21a2fac144bbc1c5ca8c" id="r_a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> = typename details::FrameLayerMsgPtr&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &gt;::Type</td></tr>
<tr class="memdesc:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to the message.  <br /></td></tr>
<tr class="separator:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7cf7de9dc3d68ab6680376b5984fd" id="r_ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memItemLeft" align="right" valign="top"><a id="ae5e7cf7de9dc3d68ab6680376b5984fd" name="ae5e7cf7de9dc3d68ab6680376b5984fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NextLayer</b> = TNextLayer</td></tr>
<tr class="memdesc:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the next transport layer. <br /></td></tr>
<tr class="separator:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc6c5d8fc6a9d3971a2c43e8d541bfe" id="r_a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memItemLeft" align="right" valign="top"><a id="a3fc6c5d8fc6a9d3971a2c43e8d541bfe" name="a3fc6c5d8fc6a9d3971a2c43e8d541bfe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParsedOptions</b> = details::FrameLayerBaseOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options structure. <br /></td></tr>
<tr class="separator:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac36d4f6d86cc17bfba914b57f2b4989" id="r_aac36d4f6d86cc17bfba914b57f2b4989"><td class="memItemLeft" align="right" valign="top"><a id="aac36d4f6d86cc17bfba914b57f2b4989" name="aac36d4f6d86cc17bfba914b57f2b4989"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThisLayer</b> = TDerived</td></tr>
<tr class="memdesc:aac36d4f6d86cc17bfba914b57f2b4989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual derived class. <br /></td></tr>
<tr class="separator:aac36d4f6d86cc17bfba914b57f2b4989"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac894251d699e627f13b413b11ec3fef5" id="r_ac894251d699e627f13b413b11ec3fef5"><td class="memItemLeft" align="right" valign="top"><a id="ac894251d699e627f13b413b11ec3fef5" name="ac894251d699e627f13b413b11ec3fef5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgSizeLayer</b> ()=default</td></tr>
<tr class="memdesc:ac894251d699e627f13b413b11ec3fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac894251d699e627f13b413b11ec3fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4050b5bb6e56289651a3391513ae8a" id="r_a9c4050b5bb6e56289651a3391513ae8a"><td class="memItemLeft" align="right" valign="top"><a id="a9c4050b5bb6e56289651a3391513ae8a" name="a9c4050b5bb6e56289651a3391513ae8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgSizeLayer</b> (const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:a9c4050b5bb6e56289651a3391513ae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a9c4050b5bb6e56289651a3391513ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf39085bddad1f5104d844b808df4fc" id="r_a5bf39085bddad1f5104d844b808df4fc"><td class="memItemLeft" align="right" valign="top"><a id="a5bf39085bddad1f5104d844b808df4fc" name="a5bf39085bddad1f5104d844b808df4fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgSizeLayer</b> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a5bf39085bddad1f5104d844b808df4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a5bf39085bddad1f5104d844b808df4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edb91f112e8264232e2c8c97d2de52f" id="r_a2edb91f112e8264232e2c8c97d2de52f"><td class="memItemLeft" align="right" valign="top"><a id="a2edb91f112e8264232e2c8c97d2de52f" name="a2edb91f112e8264232e2c8c97d2de52f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~MsgSizeLayer</b> () noexcept=default</td></tr>
<tr class="memdesc:a2edb91f112e8264232e2c8c97d2de52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2edb91f112e8264232e2c8c97d2de52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274" id="r_a142273e7f2f01e97ed167a76842fe274"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a142273e7f2f01e97ed167a76842fe274">createMsg</a> (TId &amp;&amp;id, unsigned idx=0)</td></tr>
<tr class="memdesc:a142273e7f2f01e97ed167a76842fe274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <br /></td></tr>
<tr class="separator:a142273e7f2f01e97ed167a76842fe274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac818ea0518f040726224a972df341c72" id="r_ac818ea0518f040726224a972df341c72"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ac818ea0518f040726224a972df341c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72">doRead</a> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ac818ea0518f040726224a972df341c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized read functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>.  <br /></td></tr>
<tr class="separator:ac818ea0518f040726224a972df341c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a" id="r_a89678a480d27764451edf08a88cd5a8a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a89678a480d27764451edf08a88cd5a8a">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a89678a480d27764451edf08a88cd5a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:a89678a480d27764451edf08a88cd5a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd7346e5a70e9a88d13e841c8f99758" id="r_a6dd7346e5a70e9a88d13e841c8f99758"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a6dd7346e5a70e9a88d13e841c8f99758"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a6dd7346e5a70e9a88d13e841c8f99758">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a6dd7346e5a70e9a88d13e841c8f99758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized update functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a>.  <br /></td></tr>
<tr class="separator:a6dd7346e5a70e9a88d13e841c8f99758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04" id="r_aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate</a> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:aa0948d39fa0c0ec936597a0115b5ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e3001dde9b81853d059a112efe960e" id="r_af9e3001dde9b81853d059a112efe960e"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:af9e3001dde9b81853d059a112efe960e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">doUpdate</a> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:af9e3001dde9b81853d059a112efe960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized update functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a>.  <br /></td></tr>
<tr class="separator:af9e3001dde9b81853d059a112efe960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4303cffa4e2e0a56a5d28c6996571742" id="r_a4303cffa4e2e0a56a5d28c6996571742"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </td></tr>
<tr class="memitem:a4303cffa4e2e0a56a5d28c6996571742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742">doWrite</a> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</td></tr>
<tr class="memdesc:a4303cffa4e2e0a56a5d28c6996571742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized write functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>.  <br /></td></tr>
<tr class="separator:a4303cffa4e2e0a56a5d28c6996571742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16df1e557ebd25b1d2cc650c6fc4de9" id="r_aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9">length</a> () const</td></tr>
<tr class="memdesc:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information.  <br /></td></tr>
<tr class="separator:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c" id="r_a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3a6baa01adbb498450fb6d0043747d2c">length</a> (const TMsg &amp;msg) const</td></tr>
<tr class="memdesc:a3a6baa01adbb498450fb6d0043747d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information + length of the provided message.  <br /></td></tr>
<tr class="separator:a3a6baa01adbb498450fb6d0043747d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520a1d3b2f062fe9674df67001631c5b" id="r_a520a1d3b2f062fe9674df67001631c5b"><td class="memItemLeft" align="right" valign="top"><a id="a520a1d3b2f062fe9674df67001631c5b" name="a520a1d3b2f062fe9674df67001631c5b"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> ()</td></tr>
<tr class="memdesc:a520a1d3b2f062fe9674df67001631c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the next layer object. <br /></td></tr>
<tr class="separator:a520a1d3b2f062fe9674df67001631c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023b519fa5cdb99224a3e784da3809bf" id="r_a023b519fa5cdb99224a3e784da3809bf"><td class="memItemLeft" align="right" valign="top"><a id="a023b519fa5cdb99224a3e784da3809bf" name="a023b519fa5cdb99224a3e784da3809bf"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> () const</td></tr>
<tr class="memdesc:a023b519fa5cdb99224a3e784da3809bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to the next layer object. <br /></td></tr>
<tr class="separator:a023b519fa5cdb99224a3e784da3809bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae599fcaea0873a7d698e478d3d9762fc" id="r_ae599fcaea0873a7d698e478d3d9762fc"><td class="memItemLeft" align="right" valign="top"><a id="ae599fcaea0873a7d698e478d3d9762fc" name="ae599fcaea0873a7d698e478d3d9762fc"></a>
<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:ae599fcaea0873a7d698e478d3d9762fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:ae599fcaea0873a7d698e478d3d9762fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d52a44fe4566705c10ce0ca9743fd4c" id="r_a0d52a44fe4566705c10ce0ca9743fd4c"><td class="memItemLeft" align="right" valign="top"><a id="a0d52a44fe4566705c10ce0ca9743fd4c" name="a0d52a44fe4566705c10ce0ca9743fd4c"></a>
<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a0d52a44fe4566705c10ce0ca9743fd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a0d52a44fe4566705c10ce0ca9743fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d" id="r_acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:acba89d4affe6bec7637ee8c0b82b358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence.  <br /></td></tr>
<tr class="separator:acba89d4affe6bec7637ee8c0b82b358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b" id="r_ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440" id="r_a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a2ae49cfdaedce94ea30ee99268cfe440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload.  <br /></td></tr>
<tr class="separator:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61" id="r_ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad336a6921d7e19c3c1434ad3e4b1ef61">readFromDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2" id="r_a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload).  <br /></td></tr>
<tr class="separator:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d" id="r_a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload) while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309537df4097929b25a0a51810aa5037" id="r_a309537df4097929b25a0a51810aa5037"><td class="memItemLeft" align="right" valign="top"><a id="a309537df4097929b25a0a51810aa5037" name="a309537df4097929b25a0a51810aa5037"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> ()</td></tr>
<tr class="memdesc:a309537df4097929b25a0a51810aa5037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this layer object. <br /></td></tr>
<tr class="separator:a309537df4097929b25a0a51810aa5037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca789b13ce3357178af9845a6e8bac" id="r_af7ca789b13ce3357178af9845a6e8bac"><td class="memItemLeft" align="right" valign="top"><a id="af7ca789b13ce3357178af9845a6e8bac" name="af7ca789b13ce3357178af9845a6e8bac"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> () const</td></tr>
<tr class="memdesc:af7ca789b13ce3357178af9845a6e8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to this layer object. <br /></td></tr>
<tr class="separator:af7ca789b13ce3357178af9845a6e8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff" id="r_afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afa0a267db85e3b4dd80084f08ad916ff">update</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:afa0a267db85e3b4dd80084f08ad916ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:afa0a267db85e3b4dd80084f08ad916ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59" id="r_a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0" id="r_a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4d9adf6f4309420255cd34b92d69f0d0">updateFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a4d9adf6f4309420255cd34b92d69f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42" id="r_a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TIter &gt; </td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached</a> (TAllFields &amp;allFields, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a3ef60b383ca7c874cb16f69c70814c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a3ef60b383ca7c874cb16f69c70814c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2" id="r_a13f74156f9545929fb01967ff9e10da2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a13f74156f9545929fb01967ff9e10da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence.  <br /></td></tr>
<tr class="separator:a13f74156f9545929fb01967ff9e10da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd" id="r_a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd">writeFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence while caching the written transport information fields.  <br /></td></tr>
<tr class="separator:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27" id="r_a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields &gt; </td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a88bfb24459f8ff76e4e6639eb89abc27">accessCachedField</a> (TAllFields &amp;allFields) -&gt; decltype(std::get&lt; std::tuple_size&lt; typename std::decay&lt; TAllFields &gt;::type &gt;::value - std::tuple_size&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> &gt;::value &gt;(allFields))</td></tr>
<tr class="memdesc:a88bfb24459f8ff76e4e6639eb89abc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access appropriate field from "cached" bundle of all the frame fields.  <br /></td></tr>
<tr class="separator:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfe2826c179e40898af86e199502c66" id="r_a3dfe2826c179e40898af86e199502c66"><td class="memItemLeft" align="right" valign="top"><a id="a3dfe2826c179e40898af86e199502c66" name="a3dfe2826c179e40898af86e199502c66"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSplitRead</b> ()</td></tr>
<tr class="memdesc:a3dfe2826c179e40898af86e199502c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether split read "until" and "from" data layer is allowed. <br /></td></tr>
<tr class="separator:a3dfe2826c179e40898af86e199502c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fcccc4a966bdfb70110ba0007c6b15" id="r_a20fcccc4a966bdfb70110ba0007c6b15"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength</a> ()</td></tr>
<tr class="memdesc:a20fcccc4a966bdfb70110ba0007c6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval.  <br /></td></tr>
<tr class="separator:a20fcccc4a966bdfb70110ba0007c6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389cc74c40f60c95850a0090bb8a6dc" id="r_a6389cc74c40f60c95850a0090bb8a6dc"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a6389cc74c40f60c95850a0090bb8a6dc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a6389cc74c40f60c95850a0090bb8a6dc">doFieldLength</a> (const TMsg &amp;)</td></tr>
<tr class="memdesc:a6389cc74c40f60c95850a0090bb8a6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval when message is known.  <br /></td></tr>
<tr class="separator:a6389cc74c40f60c95850a0090bb8a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c81f3cb04dec5bbffe11cff82db12d" id="r_af2c81f3cb04dec5bbffe11cff82db12d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af2c81f3cb04dec5bbffe11cff82db12d">hasExtendingClass</a> ()</td></tr>
<tr class="memdesc:af2c81f3cb04dec5bbffe11cff82db12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option.  <br /></td></tr>
<tr class="separator:af2c81f3cb04dec5bbffe11cff82db12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aca13af584dacadfe6aec31d35ec10938" id="r_aca13af584dacadfe6aec31d35ec10938"><td class="memItemLeft" align="right" valign="top"><a id="aca13af584dacadfe6aec31d35ec10938" name="aca13af584dacadfe6aec31d35ec10938"></a>
static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>NumOfLayers</b> = 1 + NextLayer::NumOfLayers</td></tr>
<tr class="memdesc:aca13af584dacadfe6aec31d35ec10938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constant indicating amount of transport layers used. <br /></td></tr>
<tr class="separator:aca13af584dacadfe6aec31d35ec10938"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5" id="r_a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6" id="r_aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplParams" colspan="2">template&lt;typename TId , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId</a> (TId val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:aed22a9e088da6512c2c62abc05f0bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message ID information if such is requested.  <br /></td></tr>
<tr class="separator:aed22a9e088da6512c2c62abc05f0bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc" id="r_a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4972642e1ab5e830baa21369c9266cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message index information if such is requested.  <br /></td></tr>
<tr class="separator:a4972642e1ab5e830baa21369c9266cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304" id="r_a4c2a5c54263f8843c4549460e3984304"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4c2a5c54263f8843c4549460e3984304">updateMissingSize</a> (const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4c2a5c54263f8843c4549460e3984304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4c2a5c54263f8843c4549460e3984304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e" id="r_a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize</a> (std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad455e9e78d398b58b636d24852b51d6c" id="r_ad455e9e78d398b58b636d24852b51d6c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ad455e9e78d398b58b636d24852b51d6c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ad455e9e78d398b58b636d24852b51d6c">beforeRead</a> (const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TMsg *msg)</td></tr>
<tr class="memdesc:ad455e9e78d398b58b636d24852b51d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra operation before read is forwarded to the next layer.  <br /></td></tr>
<tr class="separator:ad455e9e78d398b58b636d24852b51d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a" id="r_ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ac4c4e7ddfbadca13b1fb358dfce0c25a">doReadField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the layer field.  <br /></td></tr>
<tr class="separator:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c" id="r_a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7022da54d93eb0dcaca71c525e899a3c">doWriteField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7022da54d93eb0dcaca71c525e899a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the layer field.  <br /></td></tr>
<tr class="separator:a7022da54d93eb0dcaca71c525e899a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b" id="r_a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TAllFields &gt; </td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a43ca1633d44496cd4f6be376b93e741b">getField</a> (TAllFields &amp;allFields)</td></tr>
<tr class="memdesc:a43ca1633d44496cd4f6be376b93e741b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve reference to a layer specific field out of all fields.  <br /></td></tr>
<tr class="separator:a43ca1633d44496cd4f6be376b93e741b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec937945ac91c9e2617161eb6decc903" id="r_aec937945ac91c9e2617161eb6decc903"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#aec937945ac91c9e2617161eb6decc903">getRemainingSizeFromField</a> (const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field)</td></tr>
<tr class="memdesc:aec937945ac91c9e2617161eb6decc903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve remaining size (length) from the field.  <br /></td></tr>
<tr class="separator:aec937945ac91c9e2617161eb6decc903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145" id="r_afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef</a> ()</td></tr>
<tr class="memdesc:afb7a4edd007cd796ce28399afd7fb145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether type is actual message object.  <br /></td></tr>
<tr class="separator:afb7a4edd007cd796ce28399afd7fb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f75e6b64720b4a945fc8e213e4298" id="r_ade4f75e6b64720b4a945fc8e213e4298"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ade4f75e6b64720b4a945fc8e213e4298"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ade4f75e6b64720b4a945fc8e213e4298">prepareFieldForWrite</a> (std::size_t size, const TMsg *msg, <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;field)</td></tr>
<tr class="memdesc:ade4f75e6b64720b4a945fc8e213e4298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare field for writing.  <br /></td></tr>
<tr class="separator:ade4f75e6b64720b4a945fc8e213e4298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5" id="r_adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#adca278d06b818f3723eaf96b09e2e2b5">resetMsg</a> (TMsg &amp;msg)</td></tr>
<tr class="memdesc:adca278d06b818f3723eaf96b09e2e2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>).  <br /></td></tr>
<tr class="separator:adca278d06b818f3723eaf96b09e2e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875" id="r_ad2251c4f9daad4588053c02993939875"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad2251c4f9daad4588053c02993939875">toMsgPtr</a> (TMsg &amp;msg) -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;()))</td></tr>
<tr class="memdesc:ad2251c4f9daad4588053c02993939875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the message object.  <br /></td></tr>
<tr class="separator:ad2251c4f9daad4588053c02993939875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a7fb36c91416d5bbfd3434c164cc01692" id="r_a7fb36c91416d5bbfd3434c164cc01692"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(...)&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td></tr>
<tr class="memdesc:a7fb36c91416d5bbfd3434c164cc01692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a7fb36c91416d5bbfd3434c164cc01692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd385995c888a08f3c5c8647a3230f" id="r_ad8fd385995c888a08f3c5c8647a3230f"><td class="memItemLeft" align="right" valign="top"><a id="ad8fd385995c888a08f3c5c8647a3230f" name="ad8fd385995c888a08f3c5c8647a3230f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_PROTOCOL_LAYERS_ACCESS_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:ad8fd385995c888a08f3c5c8647a3230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a> <br /></td></tr>
<tr class="separator:ad8fd385995c888a08f3c5c8647a3230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d12f1394bc4c207a4734d75605c87" id="r_a394d12f1394bc4c207a4734d75605c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a394d12f1394bc4c207a4734d75605c87">COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a394d12f1394bc4c207a4734d75605c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a394d12f1394bc4c207a4734d75605c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7d81e8c974a2e774db1c5c126c7fa" id="r_a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf636c5d3c3b9ff161413c5d043cec99" id="r_abf636c5d3c3b9ff161413c5d043cec99"><td class="memItemLeft" align="right" valign="top"><a id="abf636c5d3c3b9ff161413c5d043cec99" name="abf636c5d3c3b9ff161413c5d043cec99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_PROTOCOL_LAYERS_NAMES_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:abf636c5d3c3b9ff161413c5d043cec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa" title="Provide names and convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_NAMES()</a> <br /></td></tr>
<tr class="separator:abf636c5d3c3b9ff161413c5d043cec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4451775274adbd829227dd0f459f70" id="r_a7d4451775274adbd829227dd0f459f70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7d4451775274adbd829227dd0f459f70">COMMS_PROTOCOL_LAYERS_NAMES_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a7d4451775274adbd829227dd0f459f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a7d4451775274adbd829227dd0f459f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bbb7759131423b7e9a3ba4961c0cc6" id="r_a38bbb7759131423b7e9a3ba4961c0cc6"><td class="memTemplParams" colspan="2"><a id="a38bbb7759131423b7e9a3ba4961c0cc6" name="a38bbb7759131423b7e9a3ba4961c0cc6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38bbb7759131423b7e9a3ba4961c0cc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isMsgSizeLayer</b> ()</td></tr>
<tr class="memdesc:a38bbb7759131423b7e9a3ba4961c0cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the provided type is a variant of <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">MsgSizeLayer</a>. <br /></td></tr>
<tr class="separator:a38bbb7759131423b7e9a3ba4961c0cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ad1f0f0aa396ce943b4ec390b3ed7f2" name="a8ad1f0f0aa396ce943b4ec390b3ed7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad1f0f0aa396ce943b4ec390b3ed7f2">&#9670;&#160;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllFields =  typename std::decay&lt; decltype( std::tuple_cat( std::declval&lt;std::tuple&lt;<a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a>&gt; &gt;(), std::declval&lt;typename TNextLayer::AllFields&gt;()) ) &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of all the fields of all the transport layers wrapped in std::tuple. </p>
<p>The <a class="el" href="classcomms_1_1Field.html">Field</a> type is prepended to the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> and reported as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> of this one. </p>

</div>
</div>
<a id="acc80991ee4ec52da289df5b9f14ebedd" name="acc80991ee4ec52da289df5b9f14ebedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc80991ee4ec52da289df5b9f14ebedd">&#9670;&#160;</a></span>AllMessages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllMessages =  typename NextLayer::AllMessages</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All supported messages. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a8a3bcfd230cd05ff7fe1e862ecb576cd" name="a8a3bcfd230cd05ff7fe1e862ecb576cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3bcfd230cd05ff7fe1e862ecb576cd">&#9670;&#160;</a></span>ExtendingClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::ExtendingClass =  typename ParsedOptionsInternal::ExtendingClass</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of real extending class. </p>
<p>Updated when <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> extension option us used, aliasing <b>void</b> if the options is not used. </p>

</div>
</div>
<a id="a2c2a1acafcee59b824a28a4f9552b5e6" name="a2c2a1acafcee59b824a28a4f9552b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a1acafcee59b824a28a4f9552b5e6">&#9670;&#160;</a></span>MsgFactory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgFactory =  typename NextLayer::MsgFactory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of message factory. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a68ac463b9d9c21a2fac144bbc1c5ca8c" name="a68ac463b9d9c21a2fac144bbc1c5ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ac463b9d9c21a2fac144bbc1c5ca8c">&#9670;&#160;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgPtr =  typename details::FrameLayerMsgPtr&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a>&gt;::Type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of pointer to the message. </p>
<p>Same as NextLayer::MsgPtr or void if such doesn't exist. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88bfb24459f8ff76e4e6639eb89abc27" name="a88bfb24459f8ff76e4e6639eb89abc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bfb24459f8ff76e4e6639eb89abc27">&#9670;&#160;</a></span>accessCachedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::accessCachedField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;std::tuple_size&lt;typename std::decay&lt;TAllFields&gt;::type&gt;::value - std::tuple_size&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a>&gt;::value&gt;(allFields))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access appropriate field from "cached" bundle of all the frame fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFields</td><td>All fields of the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to requested field. </dd></dl>

</div>
</div>
<a id="ad455e9e78d398b58b636d24852b51d6c" name="ad455e9e78d398b58b636d24852b51d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad455e9e78d398b58b636d24852b51d6c">&#9670;&#160;</a></span>beforeRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::beforeRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra operation before read is forwarded to the next layer. </p>
<p>Default implementation does nothing, may be overriden in the derived class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> of the layer that was successfully read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Pointer to message object, either interface class or message object itself (depending on how <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72" title="Customized read functionality, invoked by read().">doRead()</a> was invoked). Can be <b>nullptr</b> in case message object hasn't been created yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a142273e7f2f01e97ed167a76842fe274" name="a142273e7f2f01e97ed167a76842fe274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142273e7f2f01e97ed167a76842fe274">&#9670;&#160;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>The default implementation is to forwards this call to the next layer. One of the layers (usually <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::frame::MsgIdLayer</a>) hides and overrides this implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to allocated message object </dd></dl>

</div>
</div>
<a id="a20fcccc4a966bdfb70110ba0007c6b15" name="a20fcccc4a966bdfb70110ba0007c6b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fcccc4a966bdfb70110ba0007c6b15">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. </dd></dl>

</div>
</div>
<a id="a6389cc74c40f60c95850a0090bb8a6dc" name="a6389cc74c40f60c95850a0090bb8a6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389cc74c40f60c95850a0090bb8a6dc">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval when message is known. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. <br  />
 </dd></dl>

</div>
</div>
<a id="ac818ea0518f040726224a972df341c72" name="ac818ea0518f040726224a972df341c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac818ea0518f040726224a972df341c72">&#9670;&#160;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerReader &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized read functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p>
<p>Reads size of the subsequent data from the input data sequence and calls <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a> member function of the next layer with the size specified in the size field. The function will also compare the provided size of the data with value read from the buffer. If the latter is greater than former, <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a> will be returned. However, if buffer contains enough data, but the next layer reports it's not enough (returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>), <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aca3da8f495e4e628912a7798655da6c2">comms::ErrorStatus::ProtocolError</a> will be returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
    <tr><td class="paramname">TNextLayerReader</td><td>next layer reader object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerReader</td><td>Reader object, needs to be invoked to forward read operation to the next layer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic extra output parameters passed to the "read" operatation of the frame (see <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> and <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a>). Need to passed on as variadic arguments to the <b>nextLayerReader</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="ac4c4e7ddfbadca13b1fb358dfce0c25a" name="ac4c4e7ddfbadca13b1fb358dfce0c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c4e7ddfbadca13b1fb358dfce0c25a">&#9670;&#160;</a></span>doReadField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doReadField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a89678a480d27764451edf08a88cd5a8a" name="a89678a480d27764451edf08a88cd5a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89678a480d27764451edf08a88cd5a8a">&#9670;&#160;</a></span>doUpdate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate()</a> but also receiving recently written message object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd7346e5a70e9a88d13e841c8f99758" name="a6dd7346e5a70e9a88d13e841c8f99758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd7346e5a70e9a88d13e841c8f99758">&#9670;&#160;</a></span>doUpdate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized update functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a>. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">doUpdate()</a>, but receiving reference to valid message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to valid message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="aa0948d39fa0c0ec936597a0115b5ec04" name="aa0948d39fa0c0ec936597a0115b5ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0948d39fa0c0ec936597a0115b5ec04">&#9670;&#160;</a></span>doUpdate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>It will be invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, unless the derived class provides its own <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">doUpdate()</a> member function to override the default behavior.<br  />
 This function in this layer does nothing, just advances the iterator by the length of the <a class="el" href="classcomms_1_1Field.html">Field</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9e3001dde9b81853d059a112efe960e" name="af9e3001dde9b81853d059a112efe960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e3001dde9b81853d059a112efe960e">&#9670;&#160;</a></span>doUpdate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized update functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a>. </p>
<p>Should be called when <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742">doWrite()</a> returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4303cffa4e2e0a56a5d28c6996571742" name="a4303cffa4e2e0a56a5d28c6996571742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4303cffa4e2e0a56a5d28c6996571742">&#9670;&#160;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized write functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p>
<p>The function will write number of bytes required to serialise the message, then invoke the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a> member function of the next layer. The calculation of the required length is performed by invoking "length(msg)". </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer writer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update and write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerWriter</td><td>Next layer writer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a7022da54d93eb0dcaca71c525e899a3c" name="a7022da54d93eb0dcaca71c525e899a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022da54d93eb0dcaca71c525e899a3c">&#9670;&#160;</a></span>doWriteField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doWriteField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="a43ca1633d44496cd4f6be376b93e741b" name="a43ca1633d44496cd4f6be376b93e741b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ca1633d44496cd4f6be376b93e741b">&#9670;&#160;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::getField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve reference to a layer specific field out of all fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field in tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec937945ac91c9e2617161eb6decc903" name="aec937945ac91c9e2617161eb6decc903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec937945ac91c9e2617161eb6decc903">&#9670;&#160;</a></span>getRemainingSizeFromField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::getRemainingSizeFromField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve remaining size (length) from the field. </p>
<p>May be overridden by the extending class </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> for this layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2c81f3cb04dec5bbffe11cff82db12d" name="af2c81f3cb04dec5bbffe11cff82db12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c81f3cb04dec5bbffe11cff82db12d">&#9670;&#160;</a></span>hasExtendingClass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::hasExtendingClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option. </p>
<p>If <b>true</b> is returned, the <a class="el" href="classcomms_1_1frame_1_1SyncPrefixLayer.html#a2f0927559d9a49c5c4fd98d662b91b0c">ExtendingClass</a> type aliasing the real layer type. </p>

</div>
</div>
<a id="afb7a4edd007cd796ce28399afd7fb145" name="afb7a4edd007cd796ce28399afd7fb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7a4edd007cd796ce28399afd7fb145">&#9670;&#160;</a></span>isMessageObjRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::isMessageObjRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether type is actual message object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>T</b> type is extending <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>, <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a id="aa16df1e557ebd25b1d2cc650c6fc4de9" name="aa16df1e557ebd25b1d2cc650c6fc4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16df1e557ebd25b1d2cc650c6fc4de9">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information. </p>
<p>The message data always get wrapped with transport information to be successfully delivered to and unpacked on the other side. This function return remaining length of the transport information. It performs a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength()</a> member function to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a3a6baa01adbb498450fb6d0043747d2c" name="a3a6baa01adbb498450fb6d0043747d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6baa01adbb498450fb6d0043747d2c">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information + length of the provided message. </p>
<p>This function usually gets called when there is a need to identify the size of the buffer required to write provided message wrapped in the transport information. This function is very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9" title="Get remaining length of wrapping transport information.">length()</a>, but adds also length of the message. It performs a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a20fcccc4a966bdfb70110ba0007c6b15">doFieldLength()</a> member function with message parameter to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="ade4f75e6b64720b4a945fc8e213e4298" name="ade4f75e6b64720b4a945fc8e213e4298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f75e6b64720b4a945fc8e213e4298">&#9670;&#160;</a></span>prepareFieldForWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html">comms::frame::MsgSizeLayer</a>&lt; TField, TNextLayer, TOptions &gt;::prepareFieldForWrite </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare field for writing. </p>
<p>Must assign provided size (length) value. May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size value to assign </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to message object being written, may be nullptr (in case invoked from <a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">doUpdate()</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a>, value of which needs to be populated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="acba89d4affe6bec7637ee8c0b82b358d" name="acba89d4affe6bec7637ee8c0b82b358d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba89d4affe6bec7637ee8c0b82b358d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader, <span class="keyword">typename</span>... TExtraValues&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72">doRead</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a>&amp; field, <span class="comment">// field object used to read required data</span></div>
<div class="line">    TMsg&amp; msg, <span class="comment">// Ref to smart pointer to message object, or message object itself</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for reading</span></div>
<div class="line">    std::size_t size, <span class="comment">// size of the remaining data</span></div>
<div class="line">    TNextLayerReader&amp;&amp; nextLayerReader, <span class="comment">// next layer reader object</span></div>
<div class="line">    TExtraValues... extraValues)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer read, such as reading the field value</span></div>
<div class="line">    <span class="keyword">auto</span> es = field.read(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform read operation</span></div>
<div class="line">    es = nextLayerReader.read(msg, iter, size - field.length(), extraValues...);</div>
<div class="line">    ... <span class="comment">// internal logic after next layer read if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1MsgSizeLayer_html_ac249984fc1139e98baacb245842d38ac"><div class="ttname"><a href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">comms::frame::MsgSizeLayer::Field</a></div><div class="ttdeci">typename BaseImpl::Field Field</div><div class="ttdoc">Type of the field object used to read/write remaining size value.</div><div class="ttdef"><b>Definition</b> MsgSizeLayer.h:55</div></div>
<div class="ttc" id="aclasscomms_1_1frame_1_1MsgSizeLayer_html_ac818ea0518f040726224a972df341c72"><div class="ttname"><a href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72">comms::frame::MsgSizeLayer::doRead</a></div><div class="ttdeci">comms::ErrorStatus doRead(Field &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</div><div class="ttdoc">Customized read functionality, invoked by read().</div><div class="ttdef"><b>Definition</b> MsgSizeLayer.h:135</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition</b> ErrorStatus.h:17</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerReader.read()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> member function. The implemented <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72" title="Customized read functionality, invoked by read().">doRead()</a></b> member function also may use the following inherited protected member to set values of variadic parameters in case they are provided. </p><ul>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize()</a> - to calculate update missing size if such is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize()</a> - to set specific value as missing size if suce information is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId()</a> - to set the value of message id </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex()</a> - to set the value of message index. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions: <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>, <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>, <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>, <a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae9fdcbc3382f10452a6d8d0edfd5a41b" name="ae9fdcbc3382f10452a6d8d0edfd5a41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fdcbc3382f10452a6d8d0edfd5a41b">&#9670;&#160;</a></span>readFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a2ae49cfdaedce94ea30ee99268cfe440" name="a2ae49cfdaedce94ea30ee99268cfe440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae49cfdaedce94ea30ee99268cfe440">&#9670;&#160;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="ad336a6921d7e19c3c1434ad3e4b1ef61" name="ad336a6921d7e19c3c1434ad3e4b1ef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad336a6921d7e19c3c1434ad3e4b1ef61">&#9670;&#160;</a></span>readFromDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload while caching the read transport information fields. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a66e572e2e9ade86b1152dc8523d4d5a2" name="a66e572e2e9ade86b1152dc8523d4d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e572e2e9ade86b1152dc8523d4d5a2">&#9670;&#160;</a></span>readUntilData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload). </p>
<p>Same as <b>read</b> by stops read operation when data layer is reached. Expected to be followed by a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
missingSize output value is updated if and only if function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </dd></dl>

</div>
</div>
<a id="a77f6e959f54ce0b2129a62bd3559fc3d" name="a77f6e959f54ce0b2129a62bd3559fc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6e959f54ce0b2129a62bd3559fc3d">&#9670;&#160;</a></span>readUntilDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload) while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac818ea0518f040726224a972df341c72" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="adca278d06b818f3723eaf96b09e2e2b5" name="adca278d06b818f3723eaf96b09e2e2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca278d06b818f3723eaf96b09e2e2b5">&#9670;&#160;</a></span>resetMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::resetMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>). </p>
<p>Does nothing if passed parameter is actual message object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a4b3dc4d11099ca235fa82fc099d5eae5" name="a4b3dc4d11099ca235fa82fc099d5eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dc4d11099ca235fa82fc099d5eae5">&#9670;&#160;</a></span>setMissingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the missing size information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed22a9e088da6512c2c62abc05f0bda6" name="aed22a9e088da6512c2c62abc05f0bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed22a9e088da6512c2c62abc05f0bda6">&#9670;&#160;</a></span>setMsgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgId </td>
          <td>(</td>
          <td class="paramtype">TId&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message ID information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4972642e1ab5e830baa21369c9266cbc" name="a4972642e1ab5e830baa21369c9266cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4972642e1ab5e830baa21369c9266cbc">&#9670;&#160;</a></span>setMsgIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message index information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2251c4f9daad4588053c02993939875" name="ad2251c4f9daad4588053c02993939875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2251c4f9daad4588053c02993939875">&#9670;&#160;</a></span>toMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::toMsgPtr </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the message object. </p>
<p>The function works seamlessly for both smart pointer and reference to the real object </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="afa0a267db85e3b4dd80084f08ad916ff" name="afa0a267db85e3b4dd80084f08ad916ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a267db85e3b4dd80084f08ad916ff">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> but also receiving recently written message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a18fb6a05acc5d1091b7c8e419d06cb59" name="a18fb6a05acc5d1091b7c8e419d06cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fb6a05acc5d1091b7c8e419d06cb59">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Sometimes, when NON random access iterator is used for writing (for example std::back_insert_iterator), some transport data cannot be properly written. In this case, <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. When such status is returned it is necessary to call <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator on the written buffer to update written dummy information with proper values.<br  />
 The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided (or inherited) by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">doUpdate</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a>&amp; field, <span class="comment">// field object to update and re-write if necessary</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for updateing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Number of remaning bytes in the output buffer.</span></div>
<div class="line">    TNextLayerUpdater&amp;&amp; nextLayerUpdater <span class="comment">// next layer updater object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer update, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and re-writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform update operation</span></div>
<div class="line">    es = nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1MsgSizeLayer_html_af9e3001dde9b81853d059a112efe960e"><div class="ttname"><a href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e">comms::frame::MsgSizeLayer::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Customized update functionality, invoked by update().</div><div class="ttdef"><b>Definition</b> MsgSizeLayer.h:234</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a></b> member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4d9adf6f4309420255cd34b92d69f0d0" name="a4d9adf6f4309420255cd34b92d69f0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9adf6f4309420255cd34b92d69f0d0">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, but adds "msg" parameter to access message object if needed.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a3ef60b383ca7c874cb16f69c70814c42" name="a3ef60b383ca7c874cb16f69c70814c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef60b383ca7c874cb16f69c70814c42">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> member function, but adds "allFields" parameter to store raw data of the message.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#af9e3001dde9b81853d059a112efe960e" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4c2a5c54263f8843c4549460e3984304" name="a4c2a5c54263f8843c4549460e3984304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2a5c54263f8843c4549460e3984304">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> read operation of which has failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2375d4960ee9b59f0b059ccb43a31e" name="a8e2375d4960ee9b59f0b059ccb43a31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2375d4960ee9b59f0b059ccb43a31e">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13f74156f9545929fb01967ff9e10da2" name="a13f74156f9545929fb01967ff9e10da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f74156f9545929fb01967ff9e10da2">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742">doWrite</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1MsgSizeLayer.html#ac249984fc1139e98baacb245842d38ac">Field</a>&amp; field, <span class="comment">// field object used to update and write required data</span></div>
<div class="line">    <span class="keyword">const</span> TMsg&amp; msg, <span class="comment">// reference to ready to be sent message object</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for writing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Max number of bytes that can be written.</span></div>
<div class="line">    TNextLayerWriter&amp;&amp; nextLayerWriter <span class="comment">// next layer writer object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer write, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform write operation</span></div>
<div class="line">    es = nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1MsgSizeLayer_html_a4303cffa4e2e0a56a5d28c6996571742"><div class="ttname"><a href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742">comms::frame::MsgSizeLayer::doWrite</a></div><div class="ttdeci">ErrorStatus doWrite(Field &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</div><div class="ttdoc">Customized write functionality, invoked by write().</div><div class="ttdef"><b>Definition</b> MsgSizeLayer.h:213</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerWriter.write()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> member function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a2b4866367d16932a2a0a6632c7e2c3fd" name="a2b4866367d16932a2a0a6632c7e2c3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4866367d16932a2a0a6632c7e2c3fd">&#9670;&#160;</a></span>writeFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::writeFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence while caching the written transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> member function, but adds "allFields" parameter to store raw data of the message. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1MsgSizeLayer.html#a4303cffa4e2e0a56a5d28c6996571742" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to the message object that is being written, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a7fb36c91416d5bbfd3434c164cc01692" name="a7fb36c91416d5bbfd3434c164cc01692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb36c91416d5bbfd3434c164cc01692">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>The first argument is a name for innermost layer (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>), while the last one is the name for the outermost one. </p>

</div>
</div>
<a id="a394d12f1394bc4c207a4734d75605c87" name="a394d12f1394bc4c207a4734d75605c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d12f1394bc4c207a4734d75605c87">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a>, but the arguments are expected to be in reverse order, i.e. the first argument is the name of the outermost layer, while the last one is the name for the innermost one (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>) </p>

</div>
</div>
<a id="a1ad7d81e8c974a2e774db1c5c126c7fa" name="a1ad7d81e8c974a2e774db1c5c126c7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad7d81e8c974a2e774db1c5c126c7fa">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_DO_LAYER_TYPE_ALIAS(Base, __VA_ARGS__) \</div>
<div class="line">    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<a id="a7d4451775274adbd829227dd0f459f70" name="a7d4451775274adbd829227dd0f459f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4451775274adbd829227dd0f459f70">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_NAMES_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_NAMES_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a394d12f1394bc4c207a4734d75605c87" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS_OUTER()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/comms/frame/details/<a class="el" href="MsgSizeLayerBase_8h_source.html">MsgSizeLayerBase.h</a></li>
<li>include/comms/frame/<a class="el" href="frame_2MsgSizeLayer_8h_source.html">MsgSizeLayer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
