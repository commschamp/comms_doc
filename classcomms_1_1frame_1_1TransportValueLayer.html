<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::frame::TransportValueLayer&lt; TField, TIdx, TNextLayer, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1frame.html">frame</a></li><li class="navelem"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">TransportValueLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classcomms_1_1frame_1_1TransportValueLayer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comms::frame::TransportValueLayer&lt; TField, TIdx, TNextLayer, TOptions &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="frame_2TransportValueLayer_8h_source.html">comms/frame/TransportValueLayer.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TField, std::size_t TIdx, typename TNextLayer, typename... TOptions&gt;<br />
class comms::frame::TransportValueLayer&lt; TField, TIdx, TNextLayer, TOptions &gt;</div><p>Protocol layer that reads a value from transport wrapping and reassigns it to appropriate "extra transport" data member of the created message object. </p>
<p>Some protocols may put some values, which influence the way of how message contents are read and/or how the message is handled. For example protocol version information. This layer will read the field's value and will re-assign it to specified message object's "extra transport" data member field. This layer requires extra support from the defined message interface object - there is a need to pass <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option to the interface definition <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class. This layer is a mid level layer, expects other mid level layer or <a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html" title="Message data layer.">MsgDataLayer</a> to be its next one. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td>Type of the field that is used read / write extra transport value. </td></tr>
    <tr><td class="paramname">TIdx</td><td>Index of "extra transport" field that message object contains (accessed via <a class="el" href="classcomms_1_1Message.html#a983703c5c390f872ad0ca84c570903f4">comms::Message::transportFields()</a>). </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next transport layer in frame. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Extending functionality options. Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> - Mark the handled value to be "pseudo" one, i.e. the field is not getting serialised. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ExtendingClass.html">comms::option::def::ExtendingClass</a> - Use this option to provide a class name of the extending class, which can be used to extend existing functionality. See also <a class="el" href="page_custom_transport_value_layer.html">Defining Custom Transport Value Frame Layer</a> tutorial page. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FrameLayerSuppressReadUntilDataSplitForcing.html">comms::option::def::FrameLayerSuppressReadUntilDataSplitForcing</a> - Use this option when there is a need to disable passing <a class="el" href="structcomms_1_1option_1_1def_1_1FrameLayerForceReadUntilDataSplit.html">comms::option::def::FrameLayerForceReadUntilDataSplit</a> option to the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a> base class. The passing of <a class="el" href="structcomms_1_1option_1_1def_1_1FrameLayerForceReadUntilDataSplit.html">comms::option::def::FrameLayerForceReadUntilDataSplit</a> option happens when the <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a> preceeds (wraps) <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> and is unable to re-assign the read field value to the message object, because the latter hasn't been created yet. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::frame::TransportValueLayer&lt; TField, TIdx, TNextLayer, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1frame_1_1TransportValueLayer.png" usemap="#comms::frame::TransportValueLayer_3C_20TField_2C_20TIdx_2C_20TNextLayer_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::frame::TransportValueLayer_3C_20TField_2C_20TIdx_2C_20TNextLayer_2C_20TOptions_20_3E_map" name="comms::frame::TransportValueLayer_3C_20TField_2C_20TIdx_2C_20TNextLayer_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1frame_1_1FrameLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers." alt="comms::frame::FrameLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;" shape="rect" coords="0,0,444,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ad1f0f0aa396ce943b4ec390b3ed7f2" id="r_a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> = typename std::decay&lt; decltype(std::tuple_cat(std::declval&lt; std::tuple&lt; <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &gt; &gt;(), std::declval&lt; typename TNextLayer::AllFields &gt;())) &gt;::type</td></tr>
<tr class="memdesc:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of all the fields of all the transport layers wrapped in std::tuple.  <br /></td></tr>
<tr class="separator:a8ad1f0f0aa396ce943b4ec390b3ed7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc80991ee4ec52da289df5b9f14ebedd" id="r_acc80991ee4ec52da289df5b9f14ebedd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acc80991ee4ec52da289df5b9f14ebedd">AllMessages</a> = typename NextLayer::AllMessages</td></tr>
<tr class="memdesc:acc80991ee4ec52da289df5b9f14ebedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported messages.  <br /></td></tr>
<tr class="separator:acc80991ee4ec52da289df5b9f14ebedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535daaa7a971817f72a1c596d657d2ec" id="r_a535daaa7a971817f72a1c596d657d2ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a535daaa7a971817f72a1c596d657d2ec">ExtendingClass</a> = typename ParsedOptionsInternal::ExtendingClass</td></tr>
<tr class="memdesc:a535daaa7a971817f72a1c596d657d2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of real extending class.  <br /></td></tr>
<tr class="separator:a535daaa7a971817f72a1c596d657d2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cf65ac2357c98908abf8614b392488" id="r_a27cf65ac2357c98908abf8614b392488"><td class="memItemLeft" align="right" valign="top"><a id="a27cf65ac2357c98908abf8614b392488" name="a27cf65ac2357c98908abf8614b392488"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> = typename BaseImpl::Field</td></tr>
<tr class="memdesc:a27cf65ac2357c98908abf8614b392488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field object used to read/write "sync" value. <br /></td></tr>
<tr class="separator:a27cf65ac2357c98908abf8614b392488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a1acafcee59b824a28a4f9552b5e6" id="r_a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2c2a1acafcee59b824a28a4f9552b5e6">MsgFactory</a> = typename NextLayer::MsgFactory</td></tr>
<tr class="memdesc:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message factory.  <br /></td></tr>
<tr class="separator:a2c2a1acafcee59b824a28a4f9552b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ac463b9d9c21a2fac144bbc1c5ca8c" id="r_a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> = typename details::FrameLayerMsgPtr&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &gt;::Type</td></tr>
<tr class="memdesc:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to the message.  <br /></td></tr>
<tr class="separator:a68ac463b9d9c21a2fac144bbc1c5ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7cf7de9dc3d68ab6680376b5984fd" id="r_ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memItemLeft" align="right" valign="top"><a id="ae5e7cf7de9dc3d68ab6680376b5984fd" name="ae5e7cf7de9dc3d68ab6680376b5984fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NextLayer</b> = TNextLayer</td></tr>
<tr class="memdesc:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the next transport layer. <br /></td></tr>
<tr class="separator:ae5e7cf7de9dc3d68ab6680376b5984fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc6c5d8fc6a9d3971a2c43e8d541bfe" id="r_a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memItemLeft" align="right" valign="top"><a id="a3fc6c5d8fc6a9d3971a2c43e8d541bfe" name="a3fc6c5d8fc6a9d3971a2c43e8d541bfe"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParsedOptions</b> = details::FrameLayerBaseOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options structure. <br /></td></tr>
<tr class="separator:a3fc6c5d8fc6a9d3971a2c43e8d541bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac36d4f6d86cc17bfba914b57f2b4989" id="r_aac36d4f6d86cc17bfba914b57f2b4989"><td class="memItemLeft" align="right" valign="top"><a id="aac36d4f6d86cc17bfba914b57f2b4989" name="aac36d4f6d86cc17bfba914b57f2b4989"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThisLayer</b> = TDerived</td></tr>
<tr class="memdesc:aac36d4f6d86cc17bfba914b57f2b4989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual derived class. <br /></td></tr>
<tr class="separator:aac36d4f6d86cc17bfba914b57f2b4989"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a98233fe68f731c2c2855aabe73f5299e" id="r_a98233fe68f731c2c2855aabe73f5299e"><td class="memItemLeft" align="right" valign="top"><a id="a98233fe68f731c2c2855aabe73f5299e" name="a98233fe68f731c2c2855aabe73f5299e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TransportValueLayer</b> ()=default</td></tr>
<tr class="memdesc:a98233fe68f731c2c2855aabe73f5299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a98233fe68f731c2c2855aabe73f5299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b07d1b6c1fbba95db86b0fd0172b60a" id="r_a6b07d1b6c1fbba95db86b0fd0172b60a"><td class="memItemLeft" align="right" valign="top"><a id="a6b07d1b6c1fbba95db86b0fd0172b60a" name="a6b07d1b6c1fbba95db86b0fd0172b60a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TransportValueLayer</b> (const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">TransportValueLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:a6b07d1b6c1fbba95db86b0fd0172b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a6b07d1b6c1fbba95db86b0fd0172b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0e7b01576d66a61df393f37e409335" id="r_a3c0e7b01576d66a61df393f37e409335"><td class="memItemLeft" align="right" valign="top"><a id="a3c0e7b01576d66a61df393f37e409335" name="a3c0e7b01576d66a61df393f37e409335"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TransportValueLayer</b> (<a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">TransportValueLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a3c0e7b01576d66a61df393f37e409335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3c0e7b01576d66a61df393f37e409335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd69db447ec1d5df27f52ae4e996f44" id="r_a3dd69db447ec1d5df27f52ae4e996f44"><td class="memItemLeft" align="right" valign="top"><a id="a3dd69db447ec1d5df27f52ae4e996f44" name="a3dd69db447ec1d5df27f52ae4e996f44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~TransportValueLayer</b> () noexcept=default</td></tr>
<tr class="memdesc:a3dd69db447ec1d5df27f52ae4e996f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a3dd69db447ec1d5df27f52ae4e996f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274" id="r_a142273e7f2f01e97ed167a76842fe274"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a142273e7f2f01e97ed167a76842fe274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a142273e7f2f01e97ed167a76842fe274">createMsg</a> (TId &amp;&amp;id, unsigned idx=0)</td></tr>
<tr class="memdesc:a142273e7f2f01e97ed167a76842fe274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <br /></td></tr>
<tr class="separator:a142273e7f2f01e97ed167a76842fe274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f23bd244b45bf4f3ee7121ee424cb2" id="r_a05f23bd244b45bf4f3ee7121ee424cb2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a05f23bd244b45bf4f3ee7121ee424cb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2">doRead</a> (<a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a05f23bd244b45bf4f3ee7121ee424cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized read functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>.  <br /></td></tr>
<tr class="separator:a05f23bd244b45bf4f3ee7121ee424cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a" id="r_a89678a480d27764451edf08a88cd5a8a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a89678a480d27764451edf08a88cd5a8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a89678a480d27764451edf08a88cd5a8a">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a89678a480d27764451edf08a88cd5a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:a89678a480d27764451edf08a88cd5a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04" id="r_aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate</a> (<a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:aa0948d39fa0c0ec936597a0115b5ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:aa0948d39fa0c0ec936597a0115b5ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfba3f74b8fc6cef2cd321c851e093d6" id="r_adfba3f74b8fc6cef2cd321c851e093d6"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </td></tr>
<tr class="memitem:adfba3f74b8fc6cef2cd321c851e093d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#adfba3f74b8fc6cef2cd321c851e093d6">doWrite</a> (<a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</td></tr>
<tr class="memdesc:adfba3f74b8fc6cef2cd321c851e093d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized write functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>.  <br /></td></tr>
<tr class="separator:adfba3f74b8fc6cef2cd321c851e093d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16df1e557ebd25b1d2cc650c6fc4de9" id="r_aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9">length</a> () const</td></tr>
<tr class="memdesc:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information.  <br /></td></tr>
<tr class="separator:aa16df1e557ebd25b1d2cc650c6fc4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c" id="r_a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a3a6baa01adbb498450fb6d0043747d2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3a6baa01adbb498450fb6d0043747d2c">length</a> (const TMsg &amp;msg) const</td></tr>
<tr class="memdesc:a3a6baa01adbb498450fb6d0043747d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information + length of the provided message.  <br /></td></tr>
<tr class="separator:a3a6baa01adbb498450fb6d0043747d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520a1d3b2f062fe9674df67001631c5b" id="r_a520a1d3b2f062fe9674df67001631c5b"><td class="memItemLeft" align="right" valign="top"><a id="a520a1d3b2f062fe9674df67001631c5b" name="a520a1d3b2f062fe9674df67001631c5b"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> ()</td></tr>
<tr class="memdesc:a520a1d3b2f062fe9674df67001631c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the next layer object. <br /></td></tr>
<tr class="separator:a520a1d3b2f062fe9674df67001631c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023b519fa5cdb99224a3e784da3809bf" id="r_a023b519fa5cdb99224a3e784da3809bf"><td class="memItemLeft" align="right" valign="top"><a id="a023b519fa5cdb99224a3e784da3809bf" name="a023b519fa5cdb99224a3e784da3809bf"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> () const</td></tr>
<tr class="memdesc:a023b519fa5cdb99224a3e784da3809bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to the next layer object. <br /></td></tr>
<tr class="separator:a023b519fa5cdb99224a3e784da3809bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9993f216b57ba3a657e3a732678e7b70" id="r_a9993f216b57ba3a657e3a732678e7b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a9993f216b57ba3a657e3a732678e7b70">pseudoField</a> ()</td></tr>
<tr class="memdesc:a9993f216b57ba3a657e3a732678e7b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to pseudo field stored internally.  <br /></td></tr>
<tr class="separator:a9993f216b57ba3a657e3a732678e7b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c8e8f9e38ff5d8adbfb4e65ca4962c" id="r_a72c8e8f9e38ff5d8adbfb4e65ca4962c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a72c8e8f9e38ff5d8adbfb4e65ca4962c">pseudoField</a> () const</td></tr>
<tr class="memdesc:a72c8e8f9e38ff5d8adbfb4e65ca4962c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to pseudo field stored internally.  <br /></td></tr>
<tr class="separator:a72c8e8f9e38ff5d8adbfb4e65ca4962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d" id="r_acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:acba89d4affe6bec7637ee8c0b82b358d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:acba89d4affe6bec7637ee8c0b82b358d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence.  <br /></td></tr>
<tr class="separator:acba89d4affe6bec7637ee8c0b82b358d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b" id="r_ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ae9fdcbc3382f10452a6d8d0edfd5a41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440" id="r_a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a2ae49cfdaedce94ea30ee99268cfe440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload.  <br /></td></tr>
<tr class="separator:a2ae49cfdaedce94ea30ee99268cfe440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61" id="r_ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad336a6921d7e19c3c1434ad3e4b1ef61">readFromDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ad336a6921d7e19c3c1434ad3e4b1ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2" id="r_a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload).  <br /></td></tr>
<tr class="separator:a66e572e2e9ade86b1152dc8523d4d5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d" id="r_a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload) while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:a77f6e959f54ce0b2129a62bd3559fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309537df4097929b25a0a51810aa5037" id="r_a309537df4097929b25a0a51810aa5037"><td class="memItemLeft" align="right" valign="top"><a id="a309537df4097929b25a0a51810aa5037" name="a309537df4097929b25a0a51810aa5037"></a>
<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> ()</td></tr>
<tr class="memdesc:a309537df4097929b25a0a51810aa5037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this layer object. <br /></td></tr>
<tr class="separator:a309537df4097929b25a0a51810aa5037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca789b13ce3357178af9845a6e8bac" id="r_af7ca789b13ce3357178af9845a6e8bac"><td class="memItemLeft" align="right" valign="top"><a id="af7ca789b13ce3357178af9845a6e8bac" name="af7ca789b13ce3357178af9845a6e8bac"></a>
const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aac36d4f6d86cc17bfba914b57f2b4989">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> () const</td></tr>
<tr class="memdesc:af7ca789b13ce3357178af9845a6e8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to this layer object. <br /></td></tr>
<tr class="separator:af7ca789b13ce3357178af9845a6e8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff" id="r_afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:afa0a267db85e3b4dd80084f08ad916ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afa0a267db85e3b4dd80084f08ad916ff">update</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:afa0a267db85e3b4dd80084f08ad916ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:afa0a267db85e3b4dd80084f08ad916ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59" id="r_a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:a18fb6a05acc5d1091b7c8e419d06cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0" id="r_a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4d9adf6f4309420255cd34b92d69f0d0">updateFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a4d9adf6f4309420255cd34b92d69f0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a4d9adf6f4309420255cd34b92d69f0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42" id="r_a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TIter &gt; </td></tr>
<tr class="memitem:a3ef60b383ca7c874cb16f69c70814c42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached</a> (TAllFields &amp;allFields, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a3ef60b383ca7c874cb16f69c70814c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a3ef60b383ca7c874cb16f69c70814c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2" id="r_a13f74156f9545929fb01967ff9e10da2"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a13f74156f9545929fb01967ff9e10da2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a13f74156f9545929fb01967ff9e10da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence.  <br /></td></tr>
<tr class="separator:a13f74156f9545929fb01967ff9e10da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd" id="r_a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd">writeFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence while caching the written transport information fields.  <br /></td></tr>
<tr class="separator:a2b4866367d16932a2a0a6632c7e2c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27" id="r_a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields &gt; </td></tr>
<tr class="memitem:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a88bfb24459f8ff76e4e6639eb89abc27">accessCachedField</a> (TAllFields &amp;allFields) -&gt; decltype(std::get&lt; std::tuple_size&lt; typename std::decay&lt; TAllFields &gt;::type &gt;::value - std::tuple_size&lt; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> &gt;::value &gt;(allFields))</td></tr>
<tr class="memdesc:a88bfb24459f8ff76e4e6639eb89abc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access appropriate field from "cached" bundle of all the frame fields.  <br /></td></tr>
<tr class="separator:a88bfb24459f8ff76e4e6639eb89abc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfe2826c179e40898af86e199502c66" id="r_a3dfe2826c179e40898af86e199502c66"><td class="memItemLeft" align="right" valign="top"><a id="a3dfe2826c179e40898af86e199502c66" name="a3dfe2826c179e40898af86e199502c66"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSplitRead</b> ()</td></tr>
<tr class="memdesc:a3dfe2826c179e40898af86e199502c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether split read "until" and "from" data layer is allowed. <br /></td></tr>
<tr class="separator:a3dfe2826c179e40898af86e199502c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e015834866e0b49644b89500c76581b" id="r_a4e015834866e0b49644b89500c76581b"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a4e015834866e0b49644b89500c76581b">doFieldLength</a> ()</td></tr>
<tr class="memdesc:a4e015834866e0b49644b89500c76581b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customising field length calculation.  <br /></td></tr>
<tr class="separator:a4e015834866e0b49644b89500c76581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ea4b43b6382198446d1054027565da" id="r_aa2ea4b43b6382198446d1054027565da"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:aa2ea4b43b6382198446d1054027565da"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#aa2ea4b43b6382198446d1054027565da">doFieldLength</a> (const TMsg &amp;)</td></tr>
<tr class="memdesc:aa2ea4b43b6382198446d1054027565da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customising field length calculation.  <br /></td></tr>
<tr class="separator:aa2ea4b43b6382198446d1054027565da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137b049de53963486a629b7798462de6" id="r_a137b049de53963486a629b7798462de6"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a137b049de53963486a629b7798462de6">hasExtendingClass</a> ()</td></tr>
<tr class="memdesc:a137b049de53963486a629b7798462de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option.  <br /></td></tr>
<tr class="separator:a137b049de53963486a629b7798462de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c0e5e92a263488ae7f0deae4cf675" id="r_a1a6c0e5e92a263488ae7f0deae4cf675"><td class="memItemLeft" align="right" valign="top"><a id="a1a6c0e5e92a263488ae7f0deae4cf675" name="a1a6c0e5e92a263488ae7f0deae4cf675"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasPseudoValue</b> ()</td></tr>
<tr class="memdesc:a1a6c0e5e92a263488ae7f0deae4cf675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether the <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> option has been used. <br /></td></tr>
<tr class="separator:a1a6c0e5e92a263488ae7f0deae4cf675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aca13af584dacadfe6aec31d35ec10938" id="r_aca13af584dacadfe6aec31d35ec10938"><td class="memItemLeft" align="right" valign="top"><a id="aca13af584dacadfe6aec31d35ec10938" name="aca13af584dacadfe6aec31d35ec10938"></a>
static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>NumOfLayers</b> = 1 + NextLayer::NumOfLayers</td></tr>
<tr class="memdesc:aca13af584dacadfe6aec31d35ec10938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constant indicating amount of transport layers used. <br /></td></tr>
<tr class="separator:aca13af584dacadfe6aec31d35ec10938"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab4cafa9ea4cddd024b6b6f777cbf614c" id="r_ab4cafa9ea4cddd024b6b6f777cbf614c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ab4cafa9ea4cddd024b6b6f777cbf614c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#ab4cafa9ea4cddd024b6b6f777cbf614c">reassignFieldValueToMsg</a> (const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TMsg *msgPtr)</td></tr>
<tr class="memdesc:ab4cafa9ea4cddd024b6b6f777cbf614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-assign the value from the input field to appropriate transport field in the message object.  <br /></td></tr>
<tr class="separator:ab4cafa9ea4cddd024b6b6f777cbf614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5" id="r_a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4b3dc4d11099ca235fa82fc099d5eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6" id="r_aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplParams" colspan="2">template&lt;typename TId , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:aed22a9e088da6512c2c62abc05f0bda6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId</a> (TId val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:aed22a9e088da6512c2c62abc05f0bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message ID information if such is requested.  <br /></td></tr>
<tr class="separator:aed22a9e088da6512c2c62abc05f0bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc" id="r_a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4972642e1ab5e830baa21369c9266cbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4972642e1ab5e830baa21369c9266cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message index information if such is requested.  <br /></td></tr>
<tr class="separator:a4972642e1ab5e830baa21369c9266cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304" id="r_a4c2a5c54263f8843c4549460e3984304"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4c2a5c54263f8843c4549460e3984304"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4c2a5c54263f8843c4549460e3984304">updateMissingSize</a> (const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a4c2a5c54263f8843c4549460e3984304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a4c2a5c54263f8843c4549460e3984304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e" id="r_a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize</a> (std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a8e2375d4960ee9b59f0b059ccb43a31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a" id="r_ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ac4c4e7ddfbadca13b1fb358dfce0c25a">doReadField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the layer field.  <br /></td></tr>
<tr class="separator:ac4c4e7ddfbadca13b1fb358dfce0c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c" id="r_a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7022da54d93eb0dcaca71c525e899a3c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a7022da54d93eb0dcaca71c525e899a3c">doWriteField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7022da54d93eb0dcaca71c525e899a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the layer field.  <br /></td></tr>
<tr class="separator:a7022da54d93eb0dcaca71c525e899a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b" id="r_a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TAllFields &gt; </td></tr>
<tr class="memitem:a43ca1633d44496cd4f6be376b93e741b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a43ca1633d44496cd4f6be376b93e741b">getField</a> (TAllFields &amp;allFields)</td></tr>
<tr class="memdesc:a43ca1633d44496cd4f6be376b93e741b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve reference to a layer specific field out of all fields.  <br /></td></tr>
<tr class="separator:a43ca1633d44496cd4f6be376b93e741b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145" id="r_afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7a4edd007cd796ce28399afd7fb145"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef</a> ()</td></tr>
<tr class="memdesc:afb7a4edd007cd796ce28399afd7fb145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether type is actual message object.  <br /></td></tr>
<tr class="separator:afb7a4edd007cd796ce28399afd7fb145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9630f2772ed40df4e17a5b2f8dc83ad1" id="r_a9630f2772ed40df4e17a5b2f8dc83ad1"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a9630f2772ed40df4e17a5b2f8dc83ad1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a9630f2772ed40df4e17a5b2f8dc83ad1">prepareFieldForWrite</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a9630f2772ed40df4e17a5b2f8dc83ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare field for writing.  <br /></td></tr>
<tr class="separator:a9630f2772ed40df4e17a5b2f8dc83ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e35332a9756e6db716f0829ad16e6" id="r_a4e8e35332a9756e6db716f0829ad16e6"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a4e8e35332a9756e6db716f0829ad16e6"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a4e8e35332a9756e6db716f0829ad16e6">reassignFieldValue</a> (TMsg &amp;msg, const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a4e8e35332a9756e6db716f0829ad16e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-assign the value from the input field to appropriate transport field in the message object.  <br /></td></tr>
<tr class="separator:a4e8e35332a9756e6db716f0829ad16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5" id="r_adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:adca278d06b818f3723eaf96b09e2e2b5"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#adca278d06b818f3723eaf96b09e2e2b5">resetMsg</a> (TMsg &amp;msg)</td></tr>
<tr class="memdesc:adca278d06b818f3723eaf96b09e2e2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>).  <br /></td></tr>
<tr class="separator:adca278d06b818f3723eaf96b09e2e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875" id="r_ad2251c4f9daad4588053c02993939875"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ad2251c4f9daad4588053c02993939875"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ad2251c4f9daad4588053c02993939875">toMsgPtr</a> (TMsg &amp;msg) -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;()))</td></tr>
<tr class="memdesc:ad2251c4f9daad4588053c02993939875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the message object.  <br /></td></tr>
<tr class="separator:ad2251c4f9daad4588053c02993939875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a45909af8482a03654e5dcc4ec0ffdf4c" id="r_a45909af8482a03654e5dcc4ec0ffdf4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(...)&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td></tr>
<tr class="memdesc:a45909af8482a03654e5dcc4ec0ffdf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a45909af8482a03654e5dcc4ec0ffdf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319023e7ba5755efed4c67fd9f9bb3d3" id="r_a319023e7ba5755efed4c67fd9f9bb3d3"><td class="memItemLeft" align="right" valign="top"><a id="a319023e7ba5755efed4c67fd9f9bb3d3" name="a319023e7ba5755efed4c67fd9f9bb3d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_FRAME_LAYERS_ACCESS_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:a319023e7ba5755efed4c67fd9f9bb3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a> <br /></td></tr>
<tr class="separator:a319023e7ba5755efed4c67fd9f9bb3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80111e86836c752b860f6ed1aa112d25" id="r_a80111e86836c752b860f6ed1aa112d25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a80111e86836c752b860f6ed1aa112d25">COMMS_FRAME_LAYERS_ACCESS_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a80111e86836c752b860f6ed1aa112d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a80111e86836c752b860f6ed1aa112d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c913a2a9a079b15e3fbfeada67d30d7" id="r_a0c913a2a9a079b15e3fbfeada67d30d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a0c913a2a9a079b15e3fbfeada67d30d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a0c913a2a9a079b15e3fbfeada67d30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ac8e9e751f98efa089c980644710f3" id="r_a43ac8e9e751f98efa089c980644710f3"><td class="memItemLeft" align="right" valign="top"><a id="a43ac8e9e751f98efa089c980644710f3" name="a43ac8e9e751f98efa089c980644710f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_FRAME_LAYERS_NAMES_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:a43ac8e9e751f98efa089c980644710f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7" title="Provide names and convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_NAMES()</a> <br /></td></tr>
<tr class="separator:a43ac8e9e751f98efa089c980644710f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8a9056542039e69d95b8af99d3bbaf" id="r_a0e8a9056542039e69d95b8af99d3bbaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0e8a9056542039e69d95b8af99d3bbaf">COMMS_FRAME_LAYERS_NAMES_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a0e8a9056542039e69d95b8af99d3bbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a0e8a9056542039e69d95b8af99d3bbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9728a667e5272003d027abac684564" id="r_aae9728a667e5272003d027abac684564"><td class="memTemplParams" colspan="2"><a id="aae9728a667e5272003d027abac684564" name="aae9728a667e5272003d027abac684564"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae9728a667e5272003d027abac684564"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isTransportValueLayer</b> ()</td></tr>
<tr class="memdesc:aae9728a667e5272003d027abac684564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the provided type is a variant of <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">TransportValueLayer</a>. <br /></td></tr>
<tr class="separator:aae9728a667e5272003d027abac684564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ad1f0f0aa396ce943b4ec390b3ed7f2" name="a8ad1f0f0aa396ce943b4ec390b3ed7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad1f0f0aa396ce943b4ec390b3ed7f2">&#9670;&#160;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllFields =  typename std::decay&lt; decltype( std::tuple_cat( std::declval&lt;std::tuple&lt;<a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a>&gt; &gt;(), std::declval&lt;typename TNextLayer::AllFields&gt;()) ) &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of all the fields of all the transport layers wrapped in std::tuple. </p>
<p>The <a class="el" href="classcomms_1_1Field.html">Field</a> type is prepended to the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a> and reported as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> of this one. </p>

</div>
</div>
<a id="acc80991ee4ec52da289df5b9f14ebedd" name="acc80991ee4ec52da289df5b9f14ebedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc80991ee4ec52da289df5b9f14ebedd">&#9670;&#160;</a></span>AllMessages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllMessages =  typename NextLayer::AllMessages</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All supported messages. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a535daaa7a971817f72a1c596d657d2ec" name="a535daaa7a971817f72a1c596d657d2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535daaa7a971817f72a1c596d657d2ec">&#9670;&#160;</a></span>ExtendingClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::ExtendingClass =  typename ParsedOptionsInternal::ExtendingClass</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of real extending class. </p>
<p>Updated when <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> extension option us used, aliasing <b>void</b> if the options is not used. </p>

</div>
</div>
<a id="a2c2a1acafcee59b824a28a4f9552b5e6" name="a2c2a1acafcee59b824a28a4f9552b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a1acafcee59b824a28a4f9552b5e6">&#9670;&#160;</a></span>MsgFactory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgFactory =  typename NextLayer::MsgFactory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of message factory. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. Expected to be overrided by <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html">comms::frame::MsgIdLayer</a> </p>

</div>
</div>
<a id="a68ac463b9d9c21a2fac144bbc1c5ca8c" name="a68ac463b9d9c21a2fac144bbc1c5ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ac463b9d9c21a2fac144bbc1c5ca8c">&#9670;&#160;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::MsgPtr =  typename details::FrameLayerMsgPtr&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae5e7cf7de9dc3d68ab6680376b5984fd">NextLayer</a>&gt;::Type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of pointer to the message. </p>
<p>Same as NextLayer::MsgPtr or void if such doesn't exist. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88bfb24459f8ff76e4e6639eb89abc27" name="a88bfb24459f8ff76e4e6639eb89abc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bfb24459f8ff76e4e6639eb89abc27">&#9670;&#160;</a></span>accessCachedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::accessCachedField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;std::tuple_size&lt;typename std::decay&lt;TAllFields&gt;::type&gt;::value - std::tuple_size&lt;<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a>&gt;::value&gt;(allFields))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access appropriate field from "cached" bundle of all the frame fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFields</td><td>All fields of the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to requested field. </dd></dl>

</div>
</div>
<a id="a142273e7f2f01e97ed167a76842fe274" name="a142273e7f2f01e97ed167a76842fe274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142273e7f2f01e97ed167a76842fe274">&#9670;&#160;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>The default implementation is to forwards this call to the next layer. One of the layers (usually <a class="el" href="classcomms_1_1frame_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::frame::MsgIdLayer</a>) hides and overrides this implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to allocated message object </dd></dl>

</div>
</div>
<a id="a4e015834866e0b49644b89500c76581b" name="a4e015834866e0b49644b89500c76581b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e015834866e0b49644b89500c76581b">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Customising field length calculation. </p>
<p>If the layer is marked as "pseudo" (using <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a>) option, then the report length is 0. </p>

</div>
</div>
<a id="aa2ea4b43b6382198446d1054027565da" name="aa2ea4b43b6382198446d1054027565da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ea4b43b6382198446d1054027565da">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Customising field length calculation. </p>
<p>If the layer is marked as "pseudo" (using <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a>) option, then the report length is 0. </p>

</div>
</div>
<a id="a05f23bd244b45bf4f3ee7121ee424cb2" name="a05f23bd244b45bf4f3ee7121ee424cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f23bd244b45bf4f3ee7121ee424cb2">&#9670;&#160;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerReader &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized read functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p>
<p>Reads the value from the input data and assigns it to appropriate extra transport field inside the message object (accessed via <a class="el" href="classcomms_1_1Message.html#a983703c5c390f872ad0ca84c570903f4" title="Get access to extra transport fields.">comms::Message::transportFields()</a>). <br  />
 Note, that this operation works fine even if message object is created after reading the transport value. There is "inner magic" that causes read operation to proceed until <b>DATA</b> layer (implemented by <a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>), assigns the read value to message object, then proceeds to reading the message contents, i.e. when <a class="el" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">comms::Message::read()</a> function is invoked the message object already has the value of the transport field updated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
    <tr><td class="paramname">TNextLayerReader</td><td>next layer reader object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerReader</td><td>Reader object, needs to be invoked to forward read operation to the next layer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic extra output parameters passed to the "read" operatation of the frame (see <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> and <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a>). Need to passed on as variadic arguments to the <b>nextLayerReader</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="ac4c4e7ddfbadca13b1fb358dfce0c25a" name="ac4c4e7ddfbadca13b1fb358dfce0c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c4e7ddfbadca13b1fb358dfce0c25a">&#9670;&#160;</a></span>doReadField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doReadField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a89678a480d27764451edf08a88cd5a8a" name="a89678a480d27764451edf08a88cd5a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89678a480d27764451edf08a88cd5a8a">&#9670;&#160;</a></span>doUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate()</a> but also receiving recently written message object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0948d39fa0c0ec936597a0115b5ec04" name="aa0948d39fa0c0ec936597a0115b5ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0948d39fa0c0ec936597a0115b5ec04">&#9670;&#160;</a></span>doUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>It will be invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, unless the derived class provides its own <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate()</a> member function to override the default behavior.<br  />
 This function in this layer does nothing, just advances the iterator by the length of the <a class="el" href="classcomms_1_1Field.html">Field</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfba3f74b8fc6cef2cd321c851e093d6" name="adfba3f74b8fc6cef2cd321c851e093d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfba3f74b8fc6cef2cd321c851e093d6">&#9670;&#160;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized write functionality, invoked by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p>
<p>The function will write the appriprate extra transport value held by the message object being written. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer writer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update and write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerWriter</td><td>Next layer writer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a7022da54d93eb0dcaca71c525e899a3c" name="a7022da54d93eb0dcaca71c525e899a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7022da54d93eb0dcaca71c525e899a3c">&#9670;&#160;</a></span>doWriteField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doWriteField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="a43ca1633d44496cd4f6be376b93e741b" name="a43ca1633d44496cd4f6be376b93e741b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ca1633d44496cd4f6be376b93e741b">&#9670;&#160;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp; <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::getField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve reference to a layer specific field out of all fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field in tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a137b049de53963486a629b7798462de6" name="a137b049de53963486a629b7798462de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137b049de53963486a629b7798462de6">&#9670;&#160;</a></span>hasExtendingClass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::hasExtendingClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option. </p>
<p>If <b>true</b> is returned, the <a class="el" href="classcomms_1_1frame_1_1SyncPrefixLayer.html#a2f0927559d9a49c5c4fd98d662b91b0c">ExtendingClass</a> type aliasing the real layer type. </p>

</div>
</div>
<a id="afb7a4edd007cd796ce28399afd7fb145" name="afb7a4edd007cd796ce28399afd7fb145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7a4edd007cd796ce28399afd7fb145">&#9670;&#160;</a></span>isMessageObjRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::isMessageObjRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether type is actual message object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>T</b> type is extending <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>, <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a id="aa16df1e557ebd25b1d2cc650c6fc4de9" name="aa16df1e557ebd25b1d2cc650c6fc4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16df1e557ebd25b1d2cc650c6fc4de9">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information. </p>
<p>The message data always get wrapped with transport information to be successfully delivered to and unpacked on the other side. This function return remaining length of the transport information. It performs a call to <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a4e015834866e0b49644b89500c76581b">doFieldLength()</a> member function to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a3a6baa01adbb498450fb6d0043747d2c" name="a3a6baa01adbb498450fb6d0043747d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6baa01adbb498450fb6d0043747d2c">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information + length of the provided message. </p>
<p>This function usually gets called when there is a need to identify the size of the buffer required to write provided message wrapped in the transport information. This function is very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa16df1e557ebd25b1d2cc650c6fc4de9" title="Get remaining length of wrapping transport information.">length()</a>, but adds also length of the message. It performs a call to <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a4e015834866e0b49644b89500c76581b">doFieldLength()</a> member function with message parameter to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a9630f2772ed40df4e17a5b2f8dc83ad1" name="a9630f2772ed40df4e17a5b2f8dc83ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9630f2772ed40df4e17a5b2f8dc83ad1">&#9670;&#160;</a></span>prepareFieldForWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::prepareFieldForWrite </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare field for writing. </p>
<p>Copies the field value from the appropriate transport field of the message object and assigns it to the provided output field. <br  />
 May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object being written </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a>, value of which needs to be populated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a9993f216b57ba3a657e3a732678e7b70" name="a9993f216b57ba3a657e3a732678e7b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9993f216b57ba3a657e3a732678e7b70">&#9670;&#160;</a></span>pseudoField() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp; <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::pseudoField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to pseudo field stored internally. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> option has been used. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a1a6c0e5e92a263488ae7f0deae4cf675" title="Compile time inquiry of whether the comms::option::def::PseudoValue option has been used.">hasPseudoValue()</a> </dd></dl>

</div>
</div>
<a id="a72c8e8f9e38ff5d8adbfb4e65ca4962c" name="a72c8e8f9e38ff5d8adbfb4e65ca4962c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c8e8f9e38ff5d8adbfb4e65ca4962c">&#9670;&#160;</a></span>pseudoField() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp; <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::pseudoField </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const access to pseudo field stored internally. </p>
<p>The function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> option has been used. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a1a6c0e5e92a263488ae7f0deae4cf675" title="Compile time inquiry of whether the comms::option::def::PseudoValue option has been used.">hasPseudoValue()</a> </dd></dl>

</div>
</div>
<a id="acba89d4affe6bec7637ee8c0b82b358d" name="acba89d4affe6bec7637ee8c0b82b358d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba89d4affe6bec7637ee8c0b82b358d">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader, <span class="keyword">typename</span>... TExtraValues&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2">doRead</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a>&amp; field, <span class="comment">// field object used to read required data</span></div>
<div class="line">    TMsg&amp; msg, <span class="comment">// Ref to smart pointer to message object, or message object itself</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for reading</span></div>
<div class="line">    std::size_t size, <span class="comment">// size of the remaining data</span></div>
<div class="line">    TNextLayerReader&amp;&amp; nextLayerReader, <span class="comment">// next layer reader object</span></div>
<div class="line">    TExtraValues... extraValues)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer read, such as reading the field value</span></div>
<div class="line">    <span class="keyword">auto</span> es = field.read(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform read operation</span></div>
<div class="line">    es = nextLayerReader.read(msg, iter, size - field.length(), extraValues...);</div>
<div class="line">    ... <span class="comment">// internal logic after next layer read if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1TransportValueLayer_html_a05f23bd244b45bf4f3ee7121ee424cb2"><div class="ttname"><a href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2">comms::frame::TransportValueLayer::doRead</a></div><div class="ttdeci">comms::ErrorStatus doRead(Field &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</div><div class="ttdoc">Customized read functionality, invoked by read().</div><div class="ttdef"><b>Definition</b> TransportValueLayer.h:139</div></div>
<div class="ttc" id="aclasscomms_1_1frame_1_1TransportValueLayer_html_a27cf65ac2357c98908abf8614b392488"><div class="ttname"><a href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">comms::frame::TransportValueLayer::Field</a></div><div class="ttdeci">typename BaseImpl::Field Field</div><div class="ttdoc">Type of the field object used to read/write &quot;sync&quot; value.</div><div class="ttdef"><b>Definition</b> TransportValueLayer.h:70</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition</b> ErrorStatus.h:17</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerReader.read()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d" title="Deserialise message from the input data sequence.">read()</a></b> member function. The implemented <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2" title="Customized read functionality, invoked by read().">doRead()</a></b> member function also may use the following inherited protected member to set values of variadic parameters in case they are provided. </p><ul>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8e2375d4960ee9b59f0b059ccb43a31e">updateMissingSize()</a> - to calculate update missing size if such is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4b3dc4d11099ca235fa82fc099d5eae5">setMissingSize()</a> - to set specific value as missing size if suce information is requested. </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aed22a9e088da6512c2c62abc05f0bda6">setMsgId()</a> - to set the value of message id </li>
<li><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a4972642e1ab5e830baa21369c9266cbc">setMsgIndex()</a> - to set the value of message index. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions: <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>, <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>, <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>, <a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae9fdcbc3382f10452a6d8d0edfd5a41b" name="ae9fdcbc3382f10452a6d8d0edfd5a41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fdcbc3382f10452a6d8d0edfd5a41b">&#9670;&#160;</a></span>readFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a2ae49cfdaedce94ea30ee99268cfe440" name="a2ae49cfdaedce94ea30ee99268cfe440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae49cfdaedce94ea30ee99268cfe440">&#9670;&#160;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="ad336a6921d7e19c3c1434ad3e4b1ef61" name="ad336a6921d7e19c3c1434ad3e4b1ef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad336a6921d7e19c3c1434ad3e4b1ef61">&#9670;&#160;</a></span>readFromDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload while caching the read transport information fields. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a77f6e959f54ce0b2129a62bd3559fc3d">readUntilDataFieldsCached()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a66e572e2e9ade86b1152dc8523d4d5a2" name="a66e572e2e9ade86b1152dc8523d4d5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e572e2e9ade86b1152dc8523d4d5a2">&#9670;&#160;</a></span>readUntilData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload). </p>
<p>Same as <b>read</b> by stops read operation when data layer is reached. Expected to be followed by a call to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2ae49cfdaedce94ea30ee99268cfe440">readFromData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
missingSize output value is updated if and only if function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </dd></dl>

</div>
</div>
<a id="a77f6e959f54ce0b2129a62bd3559fc3d" name="a77f6e959f54ce0b2129a62bd3559fc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6e959f54ce0b2129a62bd3559fc3d">&#9670;&#160;</a></span>readUntilDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload) while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a66e572e2e9ade86b1152dc8523d4d5a2">readUntilData()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1frame.html#a3a240f101b35f8499d7b28cc9ee9f297">comms::frame::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a4e8e35332a9756e6db716f0829ad16e6" name="a4e8e35332a9756e6db716f0829ad16e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8e35332a9756e6db716f0829ad16e6">&#9670;&#160;</a></span>reassignFieldValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::reassignFieldValue </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-assign the value from the input field to appropriate transport field in the message object. </p>
<p>Default implementation just assigns to the field accessed using <b>TIdx</b> index passed as the template argument to the class definition.<br  />
 May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Reference to the created message object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a>, value of which needs to be re-assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#ab4cafa9ea4cddd024b6b6f777cbf614c">reassignFieldValueToMsg()</a> instead. </dd></dl>

</div>
</div>
<a id="ab4cafa9ea4cddd024b6b6f777cbf614c" name="ab4cafa9ea4cddd024b6b6f777cbf614c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cafa9ea4cddd024b6b6f777cbf614c">&#9670;&#160;</a></span>reassignFieldValueToMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , std::size_t TIdx, typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html">comms::frame::TransportValueLayer</a>&lt; TField, TIdx, TNextLayer, TOptions &gt;::reassignFieldValueToMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-assign the value from the input field to appropriate transport field in the message object. </p>
<p>Default implementation just assigns to the field accessed using <b>TIdx</b> index passed as the template argument to the class definition.<br  />
 May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a>, value of which needs to be re-assigned </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgPtr</td><td>Pointer to the created message object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case of successful operation, <b>false</b> othewise <br  />
 In case <b>false</b> is returned, the <a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#a05f23bd244b45bf4f3ee7121ee424cb2">doRead()</a> member function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aca3da8f495e4e628912a7798655da6c2">comms::ErrorStatus::ProtocolError</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="adca278d06b818f3723eaf96b09e2e2b5" name="adca278d06b818f3723eaf96b09e2e2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca278d06b818f3723eaf96b09e2e2b5">&#9670;&#160;</a></span>resetMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::resetMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a68ac463b9d9c21a2fac144bbc1c5ca8c">MsgPtr</a>). </p>
<p>Does nothing if passed parameter is actual message object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a4b3dc4d11099ca235fa82fc099d5eae5" name="a4b3dc4d11099ca235fa82fc099d5eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dc4d11099ca235fa82fc099d5eae5">&#9670;&#160;</a></span>setMissingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the missing size information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed22a9e088da6512c2c62abc05f0bda6" name="aed22a9e088da6512c2c62abc05f0bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed22a9e088da6512c2c62abc05f0bda6">&#9670;&#160;</a></span>setMsgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgId </td>
          <td>(</td>
          <td class="paramtype">TId&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message ID information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#ad680afe33e9358d91a8d849b7d47ea40">comms::frame::msgId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4972642e1ab5e830baa21369c9266cbc" name="a4972642e1ab5e830baa21369c9266cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4972642e1ab5e830baa21369c9266cbc">&#9670;&#160;</a></span>setMsgIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message index information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a9294d6c9288266eec8f3c3fe51e43269">comms::frame::msgIndex()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2251c4f9daad4588053c02993939875" name="ad2251c4f9daad4588053c02993939875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2251c4f9daad4588053c02993939875">&#9670;&#160;</a></span>toMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::toMsgPtr </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the message object. </p>
<p>The function works seamlessly for both smart pointer and reference to the real object </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#afb7a4edd007cd796ce28399afd7fb145">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="afa0a267db85e3b4dd80084f08ad916ff" name="afa0a267db85e3b4dd80084f08ad916ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a267db85e3b4dd80084f08ad916ff">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> but also receiving recently written message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a18fb6a05acc5d1091b7c8e419d06cb59" name="a18fb6a05acc5d1091b7c8e419d06cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fb6a05acc5d1091b7c8e419d06cb59">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Sometimes, when NON random access iterator is used for writing (for example std::back_insert_iterator), some transport data cannot be properly written. In this case, <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. When such status is returned it is necessary to call <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator on the written buffer to update written dummy information with proper values.<br  />
 The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided (or inherited) by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">doUpdate</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a>&amp; field, <span class="comment">// field object to update and re-write if necessary</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for updateing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Number of remaning bytes in the output buffer.</span></div>
<div class="line">    TNextLayerUpdater&amp;&amp; nextLayerUpdater <span class="comment">// next layer updater object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer update, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and re-writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform update operation</span></div>
<div class="line">    es = nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1FrameLayerBase_html_aa0948d39fa0c0ec936597a0115b5ec04"><div class="ttname"><a href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04">comms::frame::FrameLayerBase::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Default implementation of the &quot;update&quot; functaionality.</div><div class="ttdef"><b>Definition</b> FrameLayerBase.h:707</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59" title="Update recently written (using write()) message contents data.">update()</a></b> member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4d9adf6f4309420255cd34b92d69f0d0" name="a4d9adf6f4309420255cd34b92d69f0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9adf6f4309420255cd34b92d69f0d0">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to other <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a3ef60b383ca7c874cb16f69c70814c42">updateFieldsCached()</a> member function, but adds "msg" parameter to access message object if needed.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a3ef60b383ca7c874cb16f69c70814c42" name="a3ef60b383ca7c874cb16f69c70814c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef60b383ca7c874cb16f69c70814c42">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a18fb6a05acc5d1091b7c8e419d06cb59">update()</a> member function, but adds "allFields" parameter to store raw data of the message.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#aa0948d39fa0c0ec936597a0115b5ec04" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a2b4866367d16932a2a0a6632c7e2c3fd" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a4c2a5c54263f8843c4549460e3984304" name="a4c2a5c54263f8843c4549460e3984304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2a5c54263f8843c4549460e3984304">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a981a7fd16d6acde6193c85320e9ef33c">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> read operation of which has failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2375d4960ee9b59f0b059ccb43a31e" name="a8e2375d4960ee9b59f0b059ccb43a31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2375d4960ee9b59f0b059ccb43a31e">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1frame.html#a3566abf140404b6aeef674168678f23c">comms::frame::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#acba89d4affe6bec7637ee8c0b82b358d">read()</a> or <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#ae9fdcbc3382f10452a6d8d0edfd5a41b">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13f74156f9545929fb01967ff9e10da2" name="a13f74156f9545929fb01967ff9e10da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f74156f9545929fb01967ff9e10da2">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#adfba3f74b8fc6cef2cd321c851e093d6" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1frame_1_1TransportValueLayer.html#adfba3f74b8fc6cef2cd321c851e093d6">doWrite</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1frame_1_1TransportValueLayer.html#a27cf65ac2357c98908abf8614b392488">Field</a>&amp; field, <span class="comment">// field object used to update and write required data</span></div>
<div class="line">    <span class="keyword">const</span> TMsg&amp; msg, <span class="comment">// reference to ready to be sent message object</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for writing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Max number of bytes that can be written.</span></div>
<div class="line">    TNextLayerWriter&amp;&amp; nextLayerWriter <span class="comment">// next layer writer object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer write, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform write operation</span></div>
<div class="line">    es = nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1frame_1_1TransportValueLayer_html_adfba3f74b8fc6cef2cd321c851e093d6"><div class="ttname"><a href="classcomms_1_1frame_1_1TransportValueLayer.html#adfba3f74b8fc6cef2cd321c851e093d6">comms::frame::TransportValueLayer::doWrite</a></div><div class="ttdeci">comms::ErrorStatus doWrite(Field &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</div><div class="ttdoc">Customized write functionality, invoked by write().</div><div class="ttdef"><b>Definition</b> TransportValueLayer.h:195</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerWriter.write()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2" title="Serialise message into output data sequence.">write()</a></b> member function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a2b4866367d16932a2a0a6632c7e2c3fd" name="a2b4866367d16932a2a0a6632c7e2c3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4866367d16932a2a0a6632c7e2c3fd">&#9670;&#160;</a></span>writeFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html">comms::frame::FrameLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::writeFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence while caching the written transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a> member function, but adds "allFields" parameter to store raw data of the message. The function will also invoke the same <b><a class="el" href="classcomms_1_1frame_1_1TransportValueLayer.html#adfba3f74b8fc6cef2cd321c851e093d6" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a13f74156f9545929fb01967ff9e10da2">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type defined in the last layer class that defines frame. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a8ad1f0f0aa396ce943b4ec390b3ed7f2">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to the message object that is being written, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a45909af8482a03654e5dcc4ec0ffdf4c" name="a45909af8482a03654e5dcc4ec0ffdf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45909af8482a03654e5dcc4ec0ffdf4c">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>The first argument is a name for innermost layer (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>), while the last one is the name for the outermost one. </p>

</div>
</div>
<a id="a80111e86836c752b860f6ed1aa112d25" name="a80111e86836c752b860f6ed1aa112d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80111e86836c752b860f6ed1aa112d25">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_ACCESS_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_ACCESS_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c">COMMS_FRAME_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a>, but the arguments are expected to be in reverse order, i.e. the first argument is the name of the outermost layer, while the last one is the name for the innermost one (<a class="el" href="classcomms_1_1frame_1_1MsgDataLayer.html">comms::frame::MsgDataLayer</a>) </p>

</div>
</div>
<a id="a0c913a2a9a079b15e3fbfeada67d30d7" name="a0c913a2a9a079b15e3fbfeada67d30d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c913a2a9a079b15e3fbfeada67d30d7">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_DO_LAYER_TYPE_ALIAS(Base, __VA_ARGS__) \</div>
<div class="line">    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a45909af8482a03654e5dcc4ec0ffdf4c" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<a id="a0e8a9056542039e69d95b8af99d3bbaf" name="a0e8a9056542039e69d95b8af99d3bbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8a9056542039e69d95b8af99d3bbaf">&#9670;&#160;</a></span>COMMS_FRAME_LAYERS_NAMES_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_FRAME_LAYERS_NAMES_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a0c913a2a9a079b15e3fbfeada67d30d7">COMMS_FRAME_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1frame_1_1FrameLayerBase.html#a80111e86836c752b860f6ed1aa112d25" title="Provide convenience access functions to protocol layers.">COMMS_FRAME_LAYERS_ACCESS_OUTER()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/comms/frame/details/<a class="el" href="TransportValueLayerBase_8h_source.html">TransportValueLayerBase.h</a></li>
<li>include/comms/frame/<a class="el" href="frame_2TransportValueLayer_8h_source.html">TransportValueLayer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
