<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::protocol::ChecksumPrefixLayer&lt; TField, TCalc, TNextLayer, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1protocol.html">protocol</a></li><li class="navelem"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">comms::protocol::ChecksumPrefixLayer&lt; TField, TCalc, TNextLayer, TOptions &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ChecksumPrefixLayer_8h_source.html">comms/protocol/ChecksumPrefixLayer.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TField, typename TCalc, typename TNextLayer, typename... TOptions&gt;<br />
class comms::protocol::ChecksumPrefixLayer&lt; TField, TCalc, TNextLayer, TOptions &gt;</h3>

<p>Protocol layer that is responsible to calculate checksum on the data written by all the wrapped internal layers and prepend it before the written data. When reading, this layer is responsible to verify the checksum reported at the beginning of the read data. </p>
<p>This protocol layer handles checksum value that usually precedes the data. Some protocols use checksum value that follows the data. In this case use <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html">ChecksumLayer</a> instead. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td>Type of the field that is used as to represent checksum value. </td></tr>
    <tr><td class="paramname">TCalc</td><td>The checksum calculater class that is used to calculate the checksum value on the provided buffer. It must have the operator() defined with the following signature: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">ResultType operator()(TIter&amp; iter, std::size_t len) <span class="keyword">const</span>;</div>
</div><!-- fragment --> It is up to the checksum calculator to choose the "ResultType" it returns. The falue is going to be casted to Field::ValueType before assigning it as a value of the check field being read and/or written.<br  />
 Available checksum algorithms provided by the COMMS library reside in <a class="el" href="namespacecomms_1_1protocol_1_1checksum.html">comms::protocol::checksum</a> namespace (<code>comms/protocol/checkum</code> folder). </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next transport layer in protocol stack. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Extending functionality options. Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead.html">comms::option::def::ChecksumLayerVerifyBeforeRead</a> - By default, the <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">ChecksumPrefixLayer</a></b> will invoke <b>read</b> operation of inner (wrapped) layers and only if it is successful, it will calculate and verify the checksum value. Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead.html">comms::option::def::ChecksumLayerVerifyBeforeRead</a> modifies the default behaviour by forcing the checksum verification prior to invocation of <b>read</b> operation in the wrapped layer(s). </li>
<li><a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> - Use this option to provide a class name of the extending class, which can be used to extend existing functionality. See also <a class="el" href="page_custom_checksum_layer.html">Defining Custom Checksum Protocol Stack Layer</a> tutorial page. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::protocol::ChecksumPrefixLayer&lt; TField, TCalc, TNextLayer, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1protocol_1_1ChecksumPrefixLayer.png" usemap="#comms::protocol::ChecksumPrefixLayer_3C_20TField_2C_20TCalc_2C_20TNextLayer_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::protocol::ChecksumPrefixLayer_3C_20TField_2C_20TCalc_2C_20TNextLayer_2C_20TOptions_20_3E_map" name="comms::protocol::ChecksumPrefixLayer_3C_20TField_2C_20TCalc_2C_20TNextLayer_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers." alt="comms::protocol::ProtocolLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;" shape="rect" coords="0,0,2230,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9c47bcb2d5407fb4679cff923b1f86a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> = typename std::decay&lt; decltype(std::tuple_cat(std::declval&lt; std::tuple&lt; <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &gt; &gt;(), std::declval&lt; typename TNextLayer::AllFields &gt;())) &gt;::type</td></tr>
<tr class="memdesc:ac9c47bcb2d5407fb4679cff923b1f86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of all the fields of all the transport layers wrapped in std::tuple.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">More...</a><br /></td></tr>
<tr class="separator:ac9c47bcb2d5407fb4679cff923b1f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4f94d510fa705d00309a06ba9e3ea8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adb4f94d510fa705d00309a06ba9e3ea8">AllMessages</a> = details::ProtocolLayerAllMessagesType&lt; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &gt;</td></tr>
<tr class="memdesc:adb4f94d510fa705d00309a06ba9e3ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported messages.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adb4f94d510fa705d00309a06ba9e3ea8">More...</a><br /></td></tr>
<tr class="separator:adb4f94d510fa705d00309a06ba9e3ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd7695c1feedc9a64118433e60e3a7"><td class="memItemLeft" align="right" valign="top"><a id="ad6fd7695c1feedc9a64118433e60e3a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> = typename <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">BaseImpl::Field</a></td></tr>
<tr class="memdesc:ad6fd7695c1feedc9a64118433e60e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field object used to read/write checksum value. <br /></td></tr>
<tr class="separator:ad6fd7695c1feedc9a64118433e60e3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b1b0d2a42427cb7c998a41c9aa3174"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> = typename details::ProtocolLayerMsgPtr&lt; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &gt;::Type</td></tr>
<tr class="memdesc:a17b1b0d2a42427cb7c998a41c9aa3174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer to the message.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">More...</a><br /></td></tr>
<tr class="separator:a17b1b0d2a42427cb7c998a41c9aa3174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="memItemLeft" align="right" valign="top"><a id="ac0f9a7163ba2a95f8246fcd8a6b71476"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> = TNextLayer</td></tr>
<tr class="memdesc:ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the next transport layer. <br /></td></tr>
<tr class="separator:ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755040e6a5adfbc88cb1dbad4b77c6c0"><td class="memItemLeft" align="right" valign="top"><a id="a755040e6a5adfbc88cb1dbad4b77c6c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a755040e6a5adfbc88cb1dbad4b77c6c0">ParsedOptions</a> = details::ChecksumLayerOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a755040e6a5adfbc88cb1dbad4b77c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options. <br /></td></tr>
<tr class="separator:a755040e6a5adfbc88cb1dbad4b77c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901830b3e2d9731cba401166650da1a2"><td class="memItemLeft" align="right" valign="top"><a id="a901830b3e2d9731cba401166650da1a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a901830b3e2d9731cba401166650da1a2">ThisLayer</a> = TDerived</td></tr>
<tr class="memdesc:a901830b3e2d9731cba401166650da1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual derived class. <br /></td></tr>
<tr class="separator:a901830b3e2d9731cba401166650da1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc73729bca7a5c530175ec57e8c52afc"><td class="memItemLeft" align="right" valign="top"><a id="adc73729bca7a5c530175ec57e8c52afc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#adc73729bca7a5c530175ec57e8c52afc">ChecksumPrefixLayer</a> ()=default</td></tr>
<tr class="memdesc:adc73729bca7a5c530175ec57e8c52afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:adc73729bca7a5c530175ec57e8c52afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6130012cd187e8fff21a2ebc64541f"><td class="memItemLeft" align="right" valign="top"><a id="adf6130012cd187e8fff21a2ebc64541f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#adf6130012cd187e8fff21a2ebc64541f">ChecksumPrefixLayer</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:adf6130012cd187e8fff21a2ebc64541f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:adf6130012cd187e8fff21a2ebc64541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba8e2d9d0b0e8b01974bb2d2cf9eb4e"><td class="memItemLeft" align="right" valign="top"><a id="a7ba8e2d9d0b0e8b01974bb2d2cf9eb4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a7ba8e2d9d0b0e8b01974bb2d2cf9eb4e">ChecksumPrefixLayer</a> (const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:a7ba8e2d9d0b0e8b01974bb2d2cf9eb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a7ba8e2d9d0b0e8b01974bb2d2cf9eb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29cf51e6de7b885ecd6ee30a922aa5a"><td class="memItemLeft" align="right" valign="top"><a id="ac29cf51e6de7b885ecd6ee30a922aa5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ac29cf51e6de7b885ecd6ee30a922aa5a">~ChecksumPrefixLayer</a> () noexcept=default</td></tr>
<tr class="memdesc:ac29cf51e6de7b885ecd6ee30a922aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ac29cf51e6de7b885ecd6ee30a922aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e188996511ff20f659abad642ea40c"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a41e188996511ff20f659abad642ea40c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">createMsg</a> (TId &amp;&amp;id, unsigned idx=0)</td></tr>
<tr class="memdesc:a41e188996511ff20f659abad642ea40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">More...</a><br /></td></tr>
<tr class="separator:a41e188996511ff20f659abad642ea40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185334b61a4bcf00e57f8494c120b58c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a185334b61a4bcf00e57f8494c120b58c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c">doRead</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a185334b61a4bcf00e57f8494c120b58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c">More...</a><br /></td></tr>
<tr class="separator:a185334b61a4bcf00e57f8494c120b58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173133ed050fe014dbf99681e33a2f1b"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a173133ed050fe014dbf99681e33a2f1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a173133ed050fe014dbf99681e33a2f1b">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a173133ed050fe014dbf99681e33a2f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized update functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a>.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a173133ed050fe014dbf99681e33a2f1b">More...</a><br /></td></tr>
<tr class="separator:a173133ed050fe014dbf99681e33a2f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3eda36afa45e1c226b342980d121ea"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a1f3eda36afa45e1c226b342980d121ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1f3eda36afa45e1c226b342980d121ea">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a1f3eda36afa45e1c226b342980d121ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1f3eda36afa45e1c226b342980d121ea">More...</a><br /></td></tr>
<tr class="separator:a1f3eda36afa45e1c226b342980d121ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e454855b6e3ec1b6c82b4a5c9ebab"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a982e454855b6e3ec1b6c82b4a5c9ebab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab">doUpdate</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a982e454855b6e3ec1b6c82b4a5c9ebab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized update functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a>.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab">More...</a><br /></td></tr>
<tr class="separator:a982e454855b6e3ec1b6c82b4a5c9ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">More...</a><br /></td></tr>
<tr class="separator:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e0ac70f9a9d883cbaba1e2d4d0e488"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </td></tr>
<tr class="memitem:a87e0ac70f9a9d883cbaba1e2d4d0e488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">doWrite</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</td></tr>
<tr class="memdesc:a87e0ac70f9a9d883cbaba1e2d4d0e488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">More...</a><br /></td></tr>
<tr class="separator:a87e0ac70f9a9d883cbaba1e2d4d0e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8d04d96eb426cc76884229e2286bf0"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5d8d04d96eb426cc76884229e2286bf0">length</a> () const</td></tr>
<tr class="memdesc:a5d8d04d96eb426cc76884229e2286bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5d8d04d96eb426cc76884229e2286bf0">More...</a><br /></td></tr>
<tr class="separator:a5d8d04d96eb426cc76884229e2286bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec23ed57e71adb55cf7f11f6282a6279"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:aec23ed57e71adb55cf7f11f6282a6279"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aec23ed57e71adb55cf7f11f6282a6279">length</a> (const TMsg &amp;msg) const</td></tr>
<tr class="memdesc:aec23ed57e71adb55cf7f11f6282a6279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information + length of the provided message.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aec23ed57e71adb55cf7f11f6282a6279">More...</a><br /></td></tr>
<tr class="separator:aec23ed57e71adb55cf7f11f6282a6279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85be582d3c8e022bc5241b7729d96d49"><td class="memItemLeft" align="right" valign="top"><a id="a85be582d3c8e022bc5241b7729d96d49"></a>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a85be582d3c8e022bc5241b7729d96d49">nextLayer</a> ()</td></tr>
<tr class="memdesc:a85be582d3c8e022bc5241b7729d96d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the next layer object. <br /></td></tr>
<tr class="separator:a85be582d3c8e022bc5241b7729d96d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22122fd3e4ec4040ae7f3833b7ccac7"><td class="memItemLeft" align="right" valign="top"><a id="af22122fd3e4ec4040ae7f3833b7ccac7"></a>
const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af22122fd3e4ec4040ae7f3833b7ccac7">nextLayer</a> () const</td></tr>
<tr class="memdesc:af22122fd3e4ec4040ae7f3833b7ccac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to the next layer object. <br /></td></tr>
<tr class="separator:af22122fd3e4ec4040ae7f3833b7ccac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216324a285870e207baabdf0b38ad479"><td class="memItemLeft" align="right" valign="top"><a id="a216324a285870e207baabdf0b38ad479"></a>
<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a216324a285870e207baabdf0b38ad479">operator=</a> (<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a216324a285870e207baabdf0b38ad479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a216324a285870e207baabdf0b38ad479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e6f8f45eee622cdca791a97a001339"><td class="memItemLeft" align="right" valign="top"><a id="ab1e6f8f45eee622cdca791a97a001339"></a>
<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ab1e6f8f45eee622cdca791a97a001339">operator=</a> (const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:ab1e6f8f45eee622cdca791a97a001339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:ab1e6f8f45eee622cdca791a97a001339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">More...</a><br /></td></tr>
<tr class="separator:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a30d6baba8a074f419fe710b809d5"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad22a30d6baba8a074f419fe710b809d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ad22a30d6baba8a074f419fe710b809d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence while caching the read transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">More...</a><br /></td></tr>
<tr class="separator:ad22a30d6baba8a074f419fe710b809d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255e8af10b4282aa26bd26c442af149"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5255e8af10b4282aa26bd26c442af149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5255e8af10b4282aa26bd26c442af149">readFromData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a5255e8af10b4282aa26bd26c442af149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5255e8af10b4282aa26bd26c442af149">More...</a><br /></td></tr>
<tr class="separator:a5255e8af10b4282aa26bd26c442af149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5284c998b89075667fc48c15fde5569d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5284c998b89075667fc48c15fde5569d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5284c998b89075667fc48c15fde5569d">readFromDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a5284c998b89075667fc48c15fde5569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload while caching the read transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5284c998b89075667fc48c15fde5569d">More...</a><br /></td></tr>
<tr class="separator:a5284c998b89075667fc48c15fde5569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4443e76fb35263561c2b285c5d63e"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4bb4443e76fb35263561c2b285c5d63e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a4bb4443e76fb35263561c2b285c5d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload).  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">More...</a><br /></td></tr>
<tr class="separator:a4bb4443e76fb35263561c2b285c5d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6acc0b55d486dc2b4c9b9882af6eac3e">readUntilDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload) while caching the read transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6acc0b55d486dc2b4c9b9882af6eac3e">More...</a><br /></td></tr>
<tr class="separator:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207e91a236c1a42b5e4a0639bf97e83a"><td class="memItemLeft" align="right" valign="top"><a id="a207e91a236c1a42b5e4a0639bf97e83a"></a>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a901830b3e2d9731cba401166650da1a2">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a207e91a236c1a42b5e4a0639bf97e83a">thisLayer</a> ()</td></tr>
<tr class="memdesc:a207e91a236c1a42b5e4a0639bf97e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this layer object. <br /></td></tr>
<tr class="separator:a207e91a236c1a42b5e4a0639bf97e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebc7e17cdf17f1e435fe4ab1ee9daf1"><td class="memItemLeft" align="right" valign="top"><a id="aeebc7e17cdf17f1e435fe4ab1ee9daf1"></a>
const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a901830b3e2d9731cba401166650da1a2">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aeebc7e17cdf17f1e435fe4ab1ee9daf1">thisLayer</a> () const</td></tr>
<tr class="memdesc:aeebc7e17cdf17f1e435fe4ab1ee9daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to this layer object. <br /></td></tr>
<tr class="separator:aeebc7e17cdf17f1e435fe4ab1ee9daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db16fc13a2d49a272b067a6d04ed21"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a40db16fc13a2d49a272b067a6d04ed21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a40db16fc13a2d49a272b067a6d04ed21">update</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a40db16fc13a2d49a272b067a6d04ed21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a40db16fc13a2d49a272b067a6d04ed21">More...</a><br /></td></tr>
<tr class="separator:a40db16fc13a2d49a272b067a6d04ed21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3656112afd3d327855b8d5c93b8a6779"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a3656112afd3d327855b8d5c93b8a6779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a3656112afd3d327855b8d5c93b8a6779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">More...</a><br /></td></tr>
<tr class="separator:a3656112afd3d327855b8d5c93b8a6779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7208620e2ac60a6e3dc8fc4f6b836a8c">updateFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7208620e2ac60a6e3dc8fc4f6b836a8c">More...</a><br /></td></tr>
<tr class="separator:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618765cb8b7314e718cbcbbe7c880c6d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TIter &gt; </td></tr>
<tr class="memitem:a618765cb8b7314e718cbcbbe7c880c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached</a> (TAllFields &amp;allFields, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a618765cb8b7314e718cbcbbe7c880c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">More...</a><br /></td></tr>
<tr class="separator:a618765cb8b7314e718cbcbbe7c880c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6799fbfb090ea3a612d3757a0d28fd06"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a6799fbfb090ea3a612d3757a0d28fd06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a6799fbfb090ea3a612d3757a0d28fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">More...</a><br /></td></tr>
<tr class="separator:a6799fbfb090ea3a612d3757a0d28fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0877d7cedb580508e91ecfb7353227d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:af0877d7cedb580508e91ecfb7353227d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d">writeFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:af0877d7cedb580508e91ecfb7353227d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence while caching the written transport information fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d">More...</a><br /></td></tr>
<tr class="separator:af0877d7cedb580508e91ecfb7353227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3abb2d85e1433979aabeb6b09c7a2037"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields &gt; </td></tr>
<tr class="memitem:a3abb2d85e1433979aabeb6b09c7a2037"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3abb2d85e1433979aabeb6b09c7a2037">accessCachedField</a> (TAllFields &amp;allFields) -&gt; decltype(std::get&lt; std::tuple_size&lt; typename std::decay&lt; TAllFields &gt;::type &gt;::value - std::tuple_size&lt; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> &gt;::value &gt;(allFields))</td></tr>
<tr class="memdesc:a3abb2d85e1433979aabeb6b09c7a2037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access appropriate field from "cached" bundle of all the protocol stack fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3abb2d85e1433979aabeb6b09c7a2037">More...</a><br /></td></tr>
<tr class="separator:a3abb2d85e1433979aabeb6b09c7a2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b40f0c816054179e57b653390662710"><td class="memItemLeft" align="right" valign="top"><a id="a5b40f0c816054179e57b653390662710"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5b40f0c816054179e57b653390662710">canSplitRead</a> ()</td></tr>
<tr class="memdesc:a5b40f0c816054179e57b653390662710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether split read "until" and "from" data layer is allowed. <br /></td></tr>
<tr class="separator:a5b40f0c816054179e57b653390662710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e86bd01b3f9a678e22ec65251d98d07"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength</a> ()</td></tr>
<tr class="memdesc:a8e86bd01b3f9a678e22ec65251d98d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">More...</a><br /></td></tr>
<tr class="separator:a8e86bd01b3f9a678e22ec65251d98d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7b69ced04179d389e1458f94d223c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:adab7b69ced04179d389e1458f94d223c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adab7b69ced04179d389e1458f94d223c">doFieldLength</a> (const TMsg &amp;)</td></tr>
<tr class="memdesc:adab7b69ced04179d389e1458f94d223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval when message is known.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adab7b69ced04179d389e1458f94d223c">More...</a><br /></td></tr>
<tr class="separator:adab7b69ced04179d389e1458f94d223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="memItemLeft" align="right" valign="top"><a id="a8c3cd18e7178cb3587a23622a7c1e6b1"></a>
static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8c3cd18e7178cb3587a23622a7c1e6b1">NumOfLayers</a> = 1 + NextLayer::NumOfLayers</td></tr>
<tr class="memdesc:a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constant indicating amount of transport layers used. <br /></td></tr>
<tr class="separator:a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7d63c9abc2309c63c90aab2bfb881573"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7d63c9abc2309c63c90aab2bfb881573"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a7d63c9abc2309c63c90aab2bfb881573">readField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7d63c9abc2309c63c90aab2bfb881573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the checksum field.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a7d63c9abc2309c63c90aab2bfb881573">More...</a><br /></td></tr>
<tr class="separator:a7d63c9abc2309c63c90aab2bfb881573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5c04cd72f7c4151e6721dce4f5a85aa6">setMissingSize</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the missing size information if such is requested.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5c04cd72f7c4151e6721dce4f5a85aa6">More...</a><br /></td></tr>
<tr class="separator:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12ce31667393e09be74f7c58df52b67"><td class="memTemplParams" colspan="2">template&lt;typename TId , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad12ce31667393e09be74f7c58df52b67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad12ce31667393e09be74f7c58df52b67">setMsgId</a> (TId val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:ad12ce31667393e09be74f7c58df52b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message ID information if such is requested.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad12ce31667393e09be74f7c58df52b67">More...</a><br /></td></tr>
<tr class="separator:ad12ce31667393e09be74f7c58df52b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a835776b7e489560f660e688c1be3c3"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a6a835776b7e489560f660e688c1be3c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6a835776b7e489560f660e688c1be3c3">setMsgIndex</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a6a835776b7e489560f660e688c1be3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message index information if such is requested.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6a835776b7e489560f660e688c1be3c3">More...</a><br /></td></tr>
<tr class="separator:a6a835776b7e489560f660e688c1be3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a16c7d7975ea9fd31bb6bfc0c688bf1af">updateMissingSize</a> (const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a16c7d7975ea9fd31bb6bfc0c688bf1af">More...</a><br /></td></tr>
<tr class="separator:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8526ebff3febc385edec2a1e9ef1ae6e">updateMissingSize</a> (std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8526ebff3febc385edec2a1e9ef1ae6e">More...</a><br /></td></tr>
<tr class="separator:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c251fcf7e13c27323cf64b27d7158fa"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a1c251fcf7e13c27323cf64b27d7158fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a1c251fcf7e13c27323cf64b27d7158fa">writeField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t len) const</td></tr>
<tr class="memdesc:a1c251fcf7e13c27323cf64b27d7158fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the checksum field.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a1c251fcf7e13c27323cf64b27d7158fa">More...</a><br /></td></tr>
<tr class="separator:a1c251fcf7e13c27323cf64b27d7158fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af67a6b3207ae5073e694ff4c1c44cb26"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:af67a6b3207ae5073e694ff4c1c44cb26"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#af67a6b3207ae5073e694ff4c1c44cb26">calculateChecksum</a> (const TMsg *msg, TIter &amp;iter, std::size_t len, bool &amp;checksumValid) -&gt; decltype(TCalc()(iter, len))</td></tr>
<tr class="memdesc:af67a6b3207ae5073e694ff4c1c44cb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate checksum.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#af67a6b3207ae5073e694ff4c1c44cb26">More...</a><br /></td></tr>
<tr class="separator:af67a6b3207ae5073e694ff4c1c44cb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7050fb0df8e4efc8cc3e35214436fe55"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7050fb0df8e4efc8cc3e35214436fe55"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7050fb0df8e4efc8cc3e35214436fe55">doReadField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7050fb0df8e4efc8cc3e35214436fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the layer field.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7050fb0df8e4efc8cc3e35214436fe55">More...</a><br /></td></tr>
<tr class="separator:a7050fb0df8e4efc8cc3e35214436fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a2a7d913a4c2d569ce9c0842b9e16a0cb">doWriteField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the layer field.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a2a7d913a4c2d569ce9c0842b9e16a0cb">More...</a><br /></td></tr>
<tr class="separator:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc4764b60930eed5c1067b303ba6cde"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TAllFields &gt; </td></tr>
<tr class="memitem:acfc4764b60930eed5c1067b303ba6cde"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#acfc4764b60930eed5c1067b303ba6cde">getField</a> (TAllFields &amp;allFields)</td></tr>
<tr class="memdesc:acfc4764b60930eed5c1067b303ba6cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve reference to a layer specific field out of all fields.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#acfc4764b60930eed5c1067b303ba6cde">More...</a><br /></td></tr>
<tr class="separator:acfc4764b60930eed5c1067b303ba6cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7baefef2232316e08980e680d189ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff7baefef2232316e08980e680d189ef"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef</a> ()</td></tr>
<tr class="memdesc:aff7baefef2232316e08980e680d189ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether type is actual message object.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">More...</a><br /></td></tr>
<tr class="separator:aff7baefef2232316e08980e680d189ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c83babc34313e54e04a4f12d24394c9"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a0c83babc34313e54e04a4f12d24394c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a0c83babc34313e54e04a4f12d24394c9">resetMsg</a> (TMsg &amp;msg)</td></tr>
<tr class="memdesc:a0c83babc34313e54e04a4f12d24394c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>).  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a0c83babc34313e54e04a4f12d24394c9">More...</a><br /></td></tr>
<tr class="separator:a0c83babc34313e54e04a4f12d24394c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#abe0e556ee9a28ca50e4e3d6c3e1c3ebc">toMsgPtr</a> (TMsg &amp;msg) -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;()))</td></tr>
<tr class="memdesc:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the message object.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#abe0e556ee9a28ca50e4e3d6c3e1c3ebc">More...</a><br /></td></tr>
<tr class="separator:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a7fb36c91416d5bbfd3434c164cc01692"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(...)&#160;&#160;&#160;COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td></tr>
<tr class="memdesc:a7fb36c91416d5bbfd3434c164cc01692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">More...</a><br /></td></tr>
<tr class="separator:a7fb36c91416d5bbfd3434c164cc01692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd385995c888a08f3c5c8647a3230f"><td class="memItemLeft" align="right" valign="top"><a id="ad8fd385995c888a08f3c5c8647a3230f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad8fd385995c888a08f3c5c8647a3230f">COMMS_PROTOCOL_LAYERS_ACCESS_INNER</a>(...)&#160;&#160;&#160;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:ad8fd385995c888a08f3c5c8647a3230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS()</a> <br /></td></tr>
<tr class="separator:ad8fd385995c888a08f3c5c8647a3230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d12f1394bc4c207a4734d75605c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a394d12f1394bc4c207a4734d75605c87">COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</a>(...)&#160;&#160;&#160;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a394d12f1394bc4c207a4734d75605c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a394d12f1394bc4c207a4734d75605c87">More...</a><br /></td></tr>
<tr class="separator:a394d12f1394bc4c207a4734d75605c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac9c47bcb2d5407fb4679cff923b1f86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c47bcb2d5407fb4679cff923b1f86a">&#9670;&nbsp;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> =  typename std::decay&lt; decltype( std::tuple_cat( std::declval&lt;std::tuple&lt;<a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a>&gt; &gt;(), std::declval&lt;typename TNextLayer::AllFields&gt;()) ) &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of all the fields of all the transport layers wrapped in std::tuple. </p>
<p>The <a class="el" href="classcomms_1_1Field.html">Field</a> type is prepended to the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> and reported as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> of this one. </p>

</div>
</div>
<a id="adb4f94d510fa705d00309a06ba9e3ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4f94d510fa705d00309a06ba9e3ea8">&#9670;&nbsp;</a></span>AllMessages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adb4f94d510fa705d00309a06ba9e3ea8">AllMessages</a> =  details::ProtocolLayerAllMessagesType&lt;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All supported messages. </p>
<p>Same as NextLayer::AllMessages or void if such doesn't exist. </p>

</div>
</div>
<a id="a17b1b0d2a42427cb7c998a41c9aa3174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b1b0d2a42427cb7c998a41c9aa3174">&#9670;&nbsp;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> =  typename details::ProtocolLayerMsgPtr&lt;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a>&gt;::Type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of pointer to the message. </p>
<p>Same as NextLayer::MsgPtr or void if such doesn't exist. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3abb2d85e1433979aabeb6b09c7a2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abb2d85e1433979aabeb6b09c7a2037">&#9670;&nbsp;</a></span>accessCachedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::accessCachedField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;std::tuple_size&lt;typename std::decay&lt;TAllFields&gt;::type&gt;::value - std::tuple_size&lt;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a>&gt;::value&gt;(allFields))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access appropriate field from "cached" bundle of all the protocol stack fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFields</td><td>All fields of the protocol stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to requested field. </dd></dl>

</div>
</div>
<a id="af67a6b3207ae5073e694ff4c1c44cb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67a6b3207ae5073e694ff4c1c44cb26">&#9670;&nbsp;</a></span>calculateChecksum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::calculateChecksum </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>checksumValid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(TCalc()(iter, len))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate checksum. </p>
<p>The default implementation invokes <b>operator()</b> of provided calculation algorithm (<b>TCalc</b> template parameter). The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading data, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">checksumValid</td><td>Indication of whether the return checksum is valid, must be populated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The checksum value, can be of any type, but should field into <b>Field::ValueType</b>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="a41e188996511ff20f659abad642ea40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e188996511ff20f659abad642ea40c">&#9670;&nbsp;</a></span>createMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>The default implementation is to forwards this call to the next layer. One of the layers (usually <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a>) hides and overrides this implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to allocated message object </dd></dl>

</div>
</div>
<a id="a8e86bd01b3f9a678e22ec65251d98d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e86bd01b3f9a678e22ec65251d98d07">&#9670;&nbsp;</a></span>doFieldLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. </dd></dl>

</div>
</div>
<a id="adab7b69ced04179d389e1458f94d223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab7b69ced04179d389e1458f94d223c">&#9670;&nbsp;</a></span>doFieldLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval when message is known. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. <br  />
 </dd></dl>

</div>
</div>
<a id="a185334b61a4bcf00e57f8494c120b58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185334b61a4bcf00e57f8494c120b58c">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerReader &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p>
<p>First, reads the expected checksum value field, then executes the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a> member function of the next layer. If the call returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a>, it calculated the checksum of the read data and compares it to the calculated. If checksums match, <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> is returned, otherwise function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aca3da8f495e4e628912a7798655da6c2">comms::ErrorStatus::ProtocolError</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
    <tr><td class="paramname">TNextLayerReader</td><td>next layer reader object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer that already holds or will hold allocated message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerReader</td><td>Reader object, needs to be invoked to forward read operation to the next layer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic extra output parameters passed to the "read" operatation of the protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a>). Need to passed on as variadic arguments to the <b>nextLayerReader</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be "random access" one. </dd>
<dd>
Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a7050fb0df8e4efc8cc3e35214436fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7050fb0df8e4efc8cc3e35214436fe55">&#9670;&nbsp;</a></span>doReadField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doReadField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a173133ed050fe014dbf99681e33a2f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173133ed050fe014dbf99681e33a2f1b">&#9670;&nbsp;</a></span>doUpdate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized update functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a>. </p>
<p>Should be called when <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">doWrite()</a> returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of recently written message. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a1f3eda36afa45e1c226b342980d121ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3eda36afa45e1c226b342980d121ea">&#9670;&nbsp;</a></span>doUpdate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>Similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate()</a> but also receiving recently written message object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982e454855b6e3ec1b6c82b4a5c9ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982e454855b6e3ec1b6c82b4a5c9ebab">&#9670;&nbsp;</a></span>doUpdate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized update functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a>. </p>
<p>Should be called when <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">doWrite()</a> returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a94f23dc39f0adb4fd7ecd0ab2941588f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f23dc39f0adb4fd7ecd0ab2941588f">&#9670;&nbsp;</a></span>doUpdate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>It will be invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached()</a> member function, unless the derived class provides its own <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab">doUpdate()</a> member function to override the default behavior.<br  />
 This function in this layer does nothing, just advances the iterator by the length of the <a class="el" href="classcomms_1_1Field.html">Field</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87e0ac70f9a9d883cbaba1e2d4d0e488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e0ac70f9a9d883cbaba1e2d4d0e488">&#9670;&nbsp;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p>
<p>First, reserves the appropriate number of bytes in the output buffer which are supposed to contain valid checksum value, then executes the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a> member function of the next layer. If the call returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> and it is possible to re-read what has been written (random access iterator is used for writing), the real checksum value is calculated and updated in the previously reserved area. In case non-random access iterator type is used for writing (for example std::back_insert_iterator), then this function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a> to indicate that call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator is required in order to be able to update written checksum information. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer writer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update and write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerWriter</td><td>Next layer writer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a2a7d913a4c2d569ce9c0842b9e16a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d913a4c2d569ce9c0842b9e16a0cb">&#9670;&nbsp;</a></span>doWriteField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doWriteField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="acfc4764b60930eed5c1067b303ba6cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc4764b60930eed5c1067b303ba6cde">&#9670;&nbsp;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a>&amp; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::getField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve reference to a layer specific field out of all fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field in tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff7baefef2232316e08980e680d189ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7baefef2232316e08980e680d189ef">&#9670;&nbsp;</a></span>isMessageObjRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::isMessageObjRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether type is actual message object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>T</b> type is extending <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>, <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a id="a5d8d04d96eb426cc76884229e2286bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8d04d96eb426cc76884229e2286bf0">&#9670;&nbsp;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information. </p>
<p>The message data always get wrapped with transport information to be successfully delivered to and unpacked on the other side. This function return remaining length of the transport information. It performs a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength()</a> member function to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="aec23ed57e71adb55cf7f11f6282a6279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec23ed57e71adb55cf7f11f6282a6279">&#9670;&nbsp;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information + length of the provided message. </p>
<p>This function usually gets called when there is a need to identify the size of the buffer required to write provided message wrapped in the transport information. This function is very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5d8d04d96eb426cc76884229e2286bf0" title="Get remaining length of wrapping transport information.">length()</a>, but adds also length of the message. It performs a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength()</a> member function with message parameter to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a60d0ea06c68e5b885bf651d7a7b14d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d0ea06c68e5b885bf651d7a7b14d1a">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader, <span class="keyword">typename</span>... TExtraValues&gt;</div>
<div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c">doRead</a>(</div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a>&amp; field, <span class="comment">// field object used to read required data</span></div>
<div class="line">    TMsg&amp; msg, <span class="comment">// Ref to smart pointer to message object, or message object itself</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for reading</span></div>
<div class="line">    std::size_t size, <span class="comment">// size of the remaining data</span></div>
<div class="line">    TNextLayerReader&amp;&amp; nextLayerReader, <span class="comment">// next layer reader object</span></div>
<div class="line">    TExtraValues... extraValues)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer read, such as reading the field value</span></div>
<div class="line">    <span class="keyword">auto</span> es = field.read(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform read operation</span></div>
<div class="line">    es = nextLayerReader.read(msg, iter, size - field.length(), extraValues...);</div>
<div class="line">    ... <span class="comment">// internal logic after next layer read if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The signature of the <b>nextLayerReader.read()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a></b> member function. The implemented <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c" title="Customized read functionality, invoked by read().">doRead()</a></b> member function also may use the following inherited protected member to set values of variadic parameters in case they are provided. </p><ul>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8526ebff3febc385edec2a1e9ef1ae6e">updateMissingSize()</a> - to calculate update missing size if such is requested. </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5c04cd72f7c4151e6721dce4f5a85aa6">setMissingSize()</a> - to set specific value as missing size if suce information is requested. </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad12ce31667393e09be74f7c58df52b67">setMsgId()</a> - to set the value of message id </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6a835776b7e489560f660e688c1be3c3">setMsgIndex()</a> - to set the value of message index. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions: <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>, <a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a>, <a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a>, <a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a7d63c9abc2309c63c90aab2bfb881573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d63c9abc2309c63c90aab2bfb881573">&#9670;&nbsp;</a></span>readField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::readField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the checksum field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be static in the extending class </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Override <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7050fb0df8e4efc8cc3e35214436fe55">doReadField()</a> instead </dd></dl>

</div>
</div>
<a id="ad22a30d6baba8a074f419fe710b809d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a30d6baba8a074f419fe710b809d5">&#9670;&nbsp;</a></span>readFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a5255e8af10b4282aa26bd26c442af149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255e8af10b4282aa26bd26c442af149">&#9670;&nbsp;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a5284c998b89075667fc48c15fde5569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5284c998b89075667fc48c15fde5569d">&#9670;&nbsp;</a></span>readFromDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload while caching the read transport information fields. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6acc0b55d486dc2b4c9b9882af6eac3e">readUntilDataFieldsCached()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a4bb4443e76fb35263561c2b285c5d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb4443e76fb35263561c2b285c5d63e">&#9670;&nbsp;</a></span>readUntilData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload). </p>
<p>Same as <b>read</b> by stops read operation when data layer is reached. Expected to be followed by a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5255e8af10b4282aa26bd26c442af149">readFromData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
missingSize output value is updated if and only if function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </dd></dl>

</div>
</div>
<a id="a6acc0b55d486dc2b4c9b9882af6eac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acc0b55d486dc2b4c9b9882af6eac3e">&#9670;&nbsp;</a></span>readUntilDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload) while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a0c83babc34313e54e04a4f12d24394c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c83babc34313e54e04a4f12d24394c9">&#9670;&nbsp;</a></span>resetMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::resetMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>). </p>
<p>Does nothing if passed parameter is actual message object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a5c04cd72f7c4151e6721dce4f5a85aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c04cd72f7c4151e6721dce4f5a85aa6">&#9670;&nbsp;</a></span>setMissingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the missing size information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad12ce31667393e09be74f7c58df52b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12ce31667393e09be74f7c58df52b67">&#9670;&nbsp;</a></span>setMsgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgId </td>
          <td>(</td>
          <td class="paramtype">TId&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message ID information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a835776b7e489560f660e688c1be3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a835776b7e489560f660e688c1be3c3">&#9670;&nbsp;</a></span>setMsgIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message index information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe0e556ee9a28ca50e4e3d6c3e1c3ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0e556ee9a28ca50e4e3d6c3e1c3ebc">&#9670;&nbsp;</a></span>toMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::toMsgPtr </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the message object. </p>
<p>The function works seamlessly for both smart pointer and reference to the real object </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a40db16fc13a2d49a272b067a6d04ed21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40db16fc13a2d49a272b067a6d04ed21">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> but also receiving recently written message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a3656112afd3d327855b8d5c93b8a6779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3656112afd3d327855b8d5c93b8a6779">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Sometimes, when NON random access iterator is used for writing (for example std::back_insert_iterator), some transport data cannot be properly written. In this case, <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a> function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. When such status is returned it is necessary to call <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator on the written buffer to update written dummy information with proper values.<br  />
 The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided (or inherited) by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab">doUpdate</a>(</div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a>&amp; field, <span class="comment">// field object to update and re-write if necessary</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for updateing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Number of remaning bytes in the output buffer.</span></div>
<div class="line">    TNextLayerUpdater&amp;&amp; nextLayerUpdater <span class="comment">// next layer updater object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer update, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and re-writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform update operation</span></div>
<div class="line">    es = nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779" title="Update recently written (using write()) message contents data.">update()</a></b> member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a7208620e2ac60a6e3dc8fc4f6b836a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7208620e2ac60a6e3dc8fc4f6b836a8c">&#9670;&nbsp;</a></span>updateFieldsCached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached()</a> member function, but adds "msg" parameter to access message object if needed.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a618765cb8b7314e718cbcbbe7c880c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618765cb8b7314e718cbcbbe7c880c6d">&#9670;&nbsp;</a></span>updateFieldsCached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> member function, but adds "allFields" parameter to store raw data of the message.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab" title="Customized update functionality, invoked by update().">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a16c7d7975ea9fd31bb6bfc0c688bf1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7d7975ea9fd31bb6bfc0c688bf1af">&#9670;&nbsp;</a></span>updateMissingSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> read operation of which has failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8526ebff3febc385edec2a1e9ef1ae6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8526ebff3febc385edec2a1e9ef1ae6e">&#9670;&nbsp;</a></span>updateMissingSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6799fbfb090ea3a612d3757a0d28fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6799fbfb090ea3a612d3757a0d28fd06">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line"><a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">doWrite</a>(</div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a>&amp; field, <span class="comment">// field object used to update and write required data</span></div>
<div class="line">    <span class="keyword">const</span> TMsg&amp; msg, <span class="comment">// reference to ready to be sent message object</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for writing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Max number of bytes that can be written.</span></div>
<div class="line">    TNextLayerWriter&amp;&amp; nextLayerWriter <span class="comment">// next layer writer object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer write, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform write operation</span></div>
<div class="line">    es = nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The signature of the <b>nextLayerWriter.write()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a></b> member function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a1c251fcf7e13c27323cf64b27d7158fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c251fcf7e13c27323cf64b27d7158fa">&#9670;&nbsp;</a></span>writeField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TCalc , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>&lt; TField, TCalc, TNextLayer, TOptions &gt;::writeField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the checksum field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be static in the extending class, but needs to be const. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Override <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a2a7d913a4c2d569ce9c0842b9e16a0cb">doWriteField()</a> instead <br  />
 </dd></dl>

</div>
</div>
<a id="af0877d7cedb580508e91ecfb7353227d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0877d7cedb580508e91ecfb7353227d">&#9670;&nbsp;</a></span>writeFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::writeFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence while caching the written transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a> member function, but adds "allFields" parameter to store raw data of the message. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to the message object that is being written, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7fb36c91416d5bbfd3434c164cc01692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb36c91416d5bbfd3434c164cc01692">&#9670;&nbsp;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>The first argument is a name for innermost layer (<a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>), while the last one is the name for the outermost one. </p>

</div>
</div>
<a id="a394d12f1394bc4c207a4734d75605c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d12f1394bc4c207a4734d75605c87">&#9670;&nbsp;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS()</a>, but the arguments are expected to be in reverse order, i.e. the first argument is the name of the outermost layer, while the last one is the name for the innermost one (<a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/protocol/<a class="el" href="ChecksumPrefixLayer_8h_source.html">ChecksumPrefixLayer.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasscomms_1_1protocol_1_1ChecksumPrefixLayer_html_a982e454855b6e3ec1b6c82b4a5c9ebab"><div class="ttname"><a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a982e454855b6e3ec1b6c82b4a5c9ebab">comms::protocol::ChecksumPrefixLayer::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Customized update functionality, invoked by update().</div><div class="ttdef"><b>Definition:</b> ChecksumPrefixLayer.h:242</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition:</b> ErrorStatus.h:17</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ChecksumPrefixLayer_html_ad6fd7695c1feedc9a64118433e60e3a7"><div class="ttname"><a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#ad6fd7695c1feedc9a64118433e60e3a7">comms::protocol::ChecksumPrefixLayer::Field</a></div><div class="ttdeci">typename BaseImpl::Field Field</div><div class="ttdoc">Type of the field object used to read/write checksum value.</div><div class="ttdef"><b>Definition:</b> ChecksumPrefixLayer.h:95</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ChecksumPrefixLayer_html_a185334b61a4bcf00e57f8494c120b58c"><div class="ttname"><a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a185334b61a4bcf00e57f8494c120b58c">comms::protocol::ChecksumPrefixLayer::doRead</a></div><div class="ttdeci">comms::ErrorStatus doRead(Field &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</div><div class="ttdoc">Customized read functionality, invoked by read().</div><div class="ttdef"><b>Definition:</b> ChecksumPrefixLayer.h:146</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ChecksumPrefixLayer_html_a87e0ac70f9a9d883cbaba1e2d4d0e488"><div class="ttname"><a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#a87e0ac70f9a9d883cbaba1e2d4d0e488">comms::protocol::ChecksumPrefixLayer::doWrite</a></div><div class="ttdeci">comms::ErrorStatus doWrite(Field &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</div><div class="ttdoc">Customized write functionality, invoked by write().</div><div class="ttdef"><b>Definition:</b> ChecksumPrefixLayer.h:218</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
