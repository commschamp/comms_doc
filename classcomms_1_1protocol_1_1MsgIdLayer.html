<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1protocol.html">protocol</a></li><li class="navelem"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classcomms_1_1protocol_1_1MsgIdLayer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="MsgIdLayer_8h_source.html">comms/protocol/MsgIdLayer.h</a>&quot;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TField, typename TMessage, typename TAllMessages, typename TNextLayer, typename... TOptions&gt;<br />
class comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;</div><p>Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by other (next) layers. </p>
<p>The main purpose of this layer is to process the message ID information. Holds instance of <a class="el" href="classcomms_1_1MsgFactory.html" title="Message factory class.">comms::MsgFactory</a> as its private member and uses it to create message(s) with the required ID. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TField</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> type that contains message ID. </td></tr>
    <tr><td class="paramname">TMessage</td><td>Interface class for the <b>input</b> messages </td></tr>
    <tr><td class="paramname">TAllMessages</td><td>Types of all <b>input</b> messages, bundled in std::tuple, that this protocol stack must be able to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a> as well as create (using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59" title="Create message object given the ID.">createMsg()</a>). </td></tr>
    <tr><td class="paramname">TNextLayer</td><td>Next transport layer type. </td></tr>
    <tr><td class="paramname">TOptions</td><td>Default functionality extension options. Supported options are: <ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1ExtendingClass.html">comms::option::def::ExtendingClass</a> - Use this option to provide a class name of the extending class, which can be used to extend existing functionality. See also <a class="el" href="page_custom_id_layer.html">Defining Custom Message ID Protocol Stack Layer</a> tutorial page. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1MsgFactory.html">comms::option::app::MsgFactory</a> - Override default message factory class. The overriding class is expected to have the same public interface as <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1MsgFactoryTempl.html">comms::option::app::MsgFactoryTempl</a> - Override default message factory class. The overriding class is expected to have the same public interface as <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. </li>
<li>All the options supported by the <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. All the options except ones listed above will be forwarded to the definition of the inner instance of <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for comms::protocol::MsgIdLayer&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcomms_1_1protocol_1_1MsgIdLayer.png" usemap="#comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map" alt=""/>
  <map id="comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map" name="comms::protocol::MsgIdLayer_3C_20TField_2C_20TMessage_2C_20TAllMessages_2C_20TNextLayer_2C_20TOptions_20_3E_map">
<area href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers." alt="comms::protocol::ProtocolLayerBase&lt; TField, TNextLayer, TDerived, TOptions &gt;" shape="rect" coords="0,0,1308,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9c47bcb2d5407fb4679cff923b1f86a" id="r_ac9c47bcb2d5407fb4679cff923b1f86a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> = typename std::decay&lt; decltype(std::tuple_cat(std::declval&lt; std::tuple&lt; <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &gt; &gt;(), std::declval&lt; typename TNextLayer::AllFields &gt;())) &gt;::type</td></tr>
<tr class="memdesc:ac9c47bcb2d5407fb4679cff923b1f86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of all the fields of all the transport layers wrapped in std::tuple.  <br /></td></tr>
<tr class="separator:ac9c47bcb2d5407fb4679cff923b1f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb6fe918784f02ddcf86d8fb56fc9fd" id="r_abfb6fe918784f02ddcf86d8fb56fc9fd"><td class="memItemLeft" align="right" valign="top"><a id="abfb6fe918784f02ddcf86d8fb56fc9fd" name="abfb6fe918784f02ddcf86d8fb56fc9fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AllMessages</b> = TAllMessages</td></tr>
<tr class="memdesc:abfb6fe918784f02ddcf86d8fb56fc9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All supported message types bundled in std::tuple. <br /></td></tr>
<tr class="separator:abfb6fe918784f02ddcf86d8fb56fc9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d685a7699faa3e9732a23943efab26f" id="r_a1d685a7699faa3e9732a23943efab26f"><td class="memItemLeft" align="right" valign="top"><a id="a1d685a7699faa3e9732a23943efab26f" name="a1d685a7699faa3e9732a23943efab26f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFailureReason</b> = typename <a class="el" href="namespacecomms.html#af61c1bae7a9edbfb7928fc2aed04c55c">MsgFactory::CreateFailureReason</a></td></tr>
<tr class="memdesc:a1d685a7699faa3e9732a23943efab26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reason for message creation failure. <br /></td></tr>
<tr class="separator:a1d685a7699faa3e9732a23943efab26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac44d41a98b7d097e324b235a2d21b6" id="r_adac44d41a98b7d097e324b235a2d21b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#adac44d41a98b7d097e324b235a2d21b6">ExtendingClass</a> = typename ParsedOptionsInternal::ExtendingClass</td></tr>
<tr class="memdesc:adac44d41a98b7d097e324b235a2d21b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of real extending class.  <br /></td></tr>
<tr class="separator:adac44d41a98b7d097e324b235a2d21b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b32cf672476ce4dbb77d1529a064b" id="r_ac32b32cf672476ce4dbb77d1529a064b"><td class="memItemLeft" align="right" valign="top"><a id="ac32b32cf672476ce4dbb77d1529a064b" name="ac32b32cf672476ce4dbb77d1529a064b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> = typename BaseImpl::Field</td></tr>
<tr class="memdesc:ac32b32cf672476ce4dbb77d1529a064b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the field object used to read/write message ID value. <br /></td></tr>
<tr class="separator:ac32b32cf672476ce4dbb77d1529a064b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b70fe3164c7dc2dcb7223d7fcffcf" id="r_a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="memItemLeft" align="right" valign="top"><a id="a620b70fe3164c7dc2dcb7223d7fcffcf" name="a620b70fe3164c7dc2dcb7223d7fcffcf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Message</b> = TMessage</td></tr>
<tr class="memdesc:a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the <b>input</b> message interface. <br /></td></tr>
<tr class="separator:a620b70fe3164c7dc2dcb7223d7fcffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f0776807632af96afcee3fac19a910" id="r_a08f0776807632af96afcee3fac19a910"><td class="memItemLeft" align="right" valign="top"><a id="a08f0776807632af96afcee3fac19a910" name="a08f0776807632af96afcee3fac19a910"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MsgIdParamType</b> = typename <a class="el" href="classcomms_1_1Message.html#aa99780161941773e6bbe2767675c4a03">Message::MsgIdParamType</a></td></tr>
<tr class="memdesc:a08f0776807632af96afcee3fac19a910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message ID when passed by the parameter. <br /></td></tr>
<tr class="separator:a08f0776807632af96afcee3fac19a910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1ea3bdff923c98bf4687ed8b3f2c74" id="r_a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="memItemLeft" align="right" valign="top"><a id="a5e1ea3bdff923c98bf4687ed8b3f2c74" name="a5e1ea3bdff923c98bf4687ed8b3f2c74"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MsgIdType</b> = typename <a class="el" href="classcomms_1_1Message.html#aa7bb56b0758dfa9a8f9be12d3b8295a2">Message::MsgIdType</a></td></tr>
<tr class="memdesc:a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of message ID. <br /></td></tr>
<tr class="separator:a5e1ea3bdff923c98bf4687ed8b3f2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3444598e8ae44eaa5b09f11b694a1670" id="r_a3444598e8ae44eaa5b09f11b694a1670"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a> = typename <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgFactory::MsgPtr</a></td></tr>
<tr class="memdesc:a3444598e8ae44eaa5b09f11b694a1670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of smart pointer that will hold allocated message object.  <br /></td></tr>
<tr class="separator:a3444598e8ae44eaa5b09f11b694a1670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9a7163ba2a95f8246fcd8a6b71476" id="r_ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="memItemLeft" align="right" valign="top"><a id="ac0f9a7163ba2a95f8246fcd8a6b71476" name="ac0f9a7163ba2a95f8246fcd8a6b71476"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NextLayer</b> = TNextLayer</td></tr>
<tr class="memdesc:ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the next transport layer. <br /></td></tr>
<tr class="separator:ac0f9a7163ba2a95f8246fcd8a6b71476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bcc34891cc3e37b325942d2f9f8871" id="r_a53bcc34891cc3e37b325942d2f9f8871"><td class="memItemLeft" align="right" valign="top"><a id="a53bcc34891cc3e37b325942d2f9f8871" name="a53bcc34891cc3e37b325942d2f9f8871"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParsedOptions</b> = details::ProtocolLayerBaseOptionsParser&lt; TOptions... &gt;</td></tr>
<tr class="memdesc:a53bcc34891cc3e37b325942d2f9f8871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed options structure. <br /></td></tr>
<tr class="separator:a53bcc34891cc3e37b325942d2f9f8871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901830b3e2d9731cba401166650da1a2" id="r_a901830b3e2d9731cba401166650da1a2"><td class="memItemLeft" align="right" valign="top"><a id="a901830b3e2d9731cba401166650da1a2" name="a901830b3e2d9731cba401166650da1a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ThisLayer</b> = TDerived</td></tr>
<tr class="memdesc:a901830b3e2d9731cba401166650da1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual derived class. <br /></td></tr>
<tr class="separator:a901830b3e2d9731cba401166650da1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a917e203e5507fb488191deba16f8e5e8" id="r_a917e203e5507fb488191deba16f8e5e8"><td class="memItemLeft" align="right" valign="top"><a id="a917e203e5507fb488191deba16f8e5e8" name="a917e203e5507fb488191deba16f8e5e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgIdLayer</b> ()=default</td></tr>
<tr class="memdesc:a917e203e5507fb488191deba16f8e5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a917e203e5507fb488191deba16f8e5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea4ede865aea5089370fa34fe0381f" id="r_ab0ea4ede865aea5089370fa34fe0381f"><td class="memItemLeft" align="right" valign="top"><a id="ab0ea4ede865aea5089370fa34fe0381f" name="ab0ea4ede865aea5089370fa34fe0381f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgIdLayer</b> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:ab0ea4ede865aea5089370fa34fe0381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ab0ea4ede865aea5089370fa34fe0381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df4fd1b818d780b4e0c7589aa01ea30" id="r_a4df4fd1b818d780b4e0c7589aa01ea30"><td class="memItemLeft" align="right" valign="top"><a id="a4df4fd1b818d780b4e0c7589aa01ea30" name="a4df4fd1b818d780b4e0c7589aa01ea30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MsgIdLayer</b> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a4df4fd1b818d780b4e0c7589aa01ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a4df4fd1b818d780b4e0c7589aa01ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39b3c689a1c446239879f77f7e885b" id="r_a5e39b3c689a1c446239879f77f7e885b"><td class="memItemLeft" align="right" valign="top"><a id="a5e39b3c689a1c446239879f77f7e885b" name="a5e39b3c689a1c446239879f77f7e885b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~MsgIdLayer</b> () noexcept=default</td></tr>
<tr class="memdesc:a5e39b3c689a1c446239879f77f7e885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a5e39b3c689a1c446239879f77f7e885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cd09fb8c2b96fcffdfbad758c0fd59" id="r_a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59">createMsg</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a> id, unsigned idx=0, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a1d685a7699faa3e9732a23943efab26f">CreateFailureReason</a> *reason=nullptr)</td></tr>
<tr class="memdesc:a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.    <br /></td></tr>
<tr class="separator:a96cd09fb8c2b96fcffdfbad758c0fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e188996511ff20f659abad642ea40c" id="r_a41e188996511ff20f659abad642ea40c"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a41e188996511ff20f659abad642ea40c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">createMsg</a> (TId &amp;&amp;id, unsigned idx=0)</td></tr>
<tr class="memdesc:a41e188996511ff20f659abad642ea40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create message object given the ID.  <br /></td></tr>
<tr class="separator:a41e188996511ff20f659abad642ea40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00d71aa57799789befc68189f7f718f" id="r_af00d71aa57799789befc68189f7f718f"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:af00d71aa57799789befc68189f7f718f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f">doRead</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:af00d71aa57799789befc68189f7f718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>.  <br /></td></tr>
<tr class="separator:af00d71aa57799789befc68189f7f718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3eda36afa45e1c226b342980d121ea" id="r_a1f3eda36afa45e1c226b342980d121ea"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a1f3eda36afa45e1c226b342980d121ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1f3eda36afa45e1c226b342980d121ea">doUpdate</a> (const TMsg &amp;msg, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a1f3eda36afa45e1c226b342980d121ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:a1f3eda36afa45e1c226b342980d121ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f23dc39f0adb4fd7ecd0ab2941588f" id="r_a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memTemplParams" colspan="2">template&lt;typename TIter , typename TNextLayerUpdater &gt; </td></tr>
<tr class="memitem:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</td></tr>
<tr class="memdesc:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the "update" functaionality.  <br /></td></tr>
<tr class="separator:a94f23dc39f0adb4fd7ecd0ab2941588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d804fa610375e1379c43549d1b20981" id="r_a7d804fa610375e1379c43549d1b20981"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </td></tr>
<tr class="memitem:a7d804fa610375e1379c43549d1b20981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981">doWrite</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</td></tr>
<tr class="memdesc:a7d804fa610375e1379c43549d1b20981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>.  <br /></td></tr>
<tr class="separator:a7d804fa610375e1379c43549d1b20981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8d04d96eb426cc76884229e2286bf0" id="r_a5d8d04d96eb426cc76884229e2286bf0"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5d8d04d96eb426cc76884229e2286bf0">length</a> () const</td></tr>
<tr class="memdesc:a5d8d04d96eb426cc76884229e2286bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information.  <br /></td></tr>
<tr class="separator:a5d8d04d96eb426cc76884229e2286bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec23ed57e71adb55cf7f11f6282a6279" id="r_aec23ed57e71adb55cf7f11f6282a6279"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:aec23ed57e71adb55cf7f11f6282a6279"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aec23ed57e71adb55cf7f11f6282a6279">length</a> (const TMsg &amp;msg) const</td></tr>
<tr class="memdesc:aec23ed57e71adb55cf7f11f6282a6279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get remaining length of wrapping transport information + length of the provided message.  <br /></td></tr>
<tr class="separator:aec23ed57e71adb55cf7f11f6282a6279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b66bf54cf3ffa37058ff618bdcf163" id="r_a94b66bf54cf3ffa37058ff618bdcf163"><td class="memItemLeft" align="right" valign="top"><a id="a94b66bf54cf3ffa37058ff618bdcf163" name="a94b66bf54cf3ffa37058ff618bdcf163"></a>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> ()</td></tr>
<tr class="memdesc:a94b66bf54cf3ffa37058ff618bdcf163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the next layer object. <br /></td></tr>
<tr class="separator:a94b66bf54cf3ffa37058ff618bdcf163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2dcd861691923f6ce39b6d46040f9c" id="r_a6a2dcd861691923f6ce39b6d46040f9c"><td class="memItemLeft" align="right" valign="top"><a id="a6a2dcd861691923f6ce39b6d46040f9c" name="a6a2dcd861691923f6ce39b6d46040f9c"></a>
const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nextLayer</b> () const</td></tr>
<tr class="memdesc:a6a2dcd861691923f6ce39b6d46040f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to the next layer object. <br /></td></tr>
<tr class="separator:a6a2dcd861691923f6ce39b6d46040f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac471d5e04fcd1e1887b39451e7e7d766" id="r_ac471d5e04fcd1e1887b39451e7e7d766"><td class="memItemLeft" align="right" valign="top"><a id="ac471d5e04fcd1e1887b39451e7e7d766" name="ac471d5e04fcd1e1887b39451e7e7d766"></a>
<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;)=default</td></tr>
<tr class="memdesc:ac471d5e04fcd1e1887b39451e7e7d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:ac471d5e04fcd1e1887b39451e7e7d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec6336d4a377ffed172e38b073ffd9e" id="r_a6ec6336d4a377ffed172e38b073ffd9e"><td class="memItemLeft" align="right" valign="top"><a id="a6ec6336d4a377ffed172e38b073ffd9e" name="a6ec6336d4a377ffed172e38b073ffd9e"></a>
<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a6ec6336d4a377ffed172e38b073ffd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a6ec6336d4a377ffed172e38b073ffd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0ea06c68e5b885bf651d7a7b14d1a" id="r_a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence.  <br /></td></tr>
<tr class="separator:a60d0ea06c68e5b885bf651d7a7b14d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22a30d6baba8a074f419fe710b809d5" id="r_ad22a30d6baba8a074f419fe710b809d5"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad22a30d6baba8a074f419fe710b809d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:ad22a30d6baba8a074f419fe710b809d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise message from the input data sequence while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:ad22a30d6baba8a074f419fe710b809d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255e8af10b4282aa26bd26c442af149" id="r_a5255e8af10b4282aa26bd26c442af149"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5255e8af10b4282aa26bd26c442af149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5255e8af10b4282aa26bd26c442af149">readFromData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a5255e8af10b4282aa26bd26c442af149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload.  <br /></td></tr>
<tr class="separator:a5255e8af10b4282aa26bd26c442af149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5284c998b89075667fc48c15fde5569d" id="r_a5284c998b89075667fc48c15fde5569d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5284c998b89075667fc48c15fde5569d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5284c998b89075667fc48c15fde5569d">readFromDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a5284c998b89075667fc48c15fde5569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise the read operation by reading the message payload while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:a5284c998b89075667fc48c15fde5569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4443e76fb35263561c2b285c5d63e" id="r_a4bb4443e76fb35263561c2b285c5d63e"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4bb4443e76fb35263561c2b285c5d63e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData</a> (TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a4bb4443e76fb35263561c2b285c5d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload).  <br /></td></tr>
<tr class="separator:a4bb4443e76fb35263561c2b285c5d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc0b55d486dc2b4c9b9882af6eac3e" id="r_a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6acc0b55d486dc2b4c9b9882af6eac3e">readUntilDataFieldsCached</a> (TAllFields &amp;allFields, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform read of data fields until data layer (message payload) while caching the read transport information fields.  <br /></td></tr>
<tr class="separator:a6acc0b55d486dc2b4c9b9882af6eac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73c37c7b57ad4ef8e5864c7b6ef9df" id="r_a8e73c37c7b57ad4ef8e5864c7b6ef9df"><td class="memItemLeft" align="right" valign="top"><a id="a8e73c37c7b57ad4ef8e5864c7b6ef9df" name="a8e73c37c7b57ad4ef8e5864c7b6ef9df"></a>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a901830b3e2d9731cba401166650da1a2">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> ()</td></tr>
<tr class="memdesc:a8e73c37c7b57ad4ef8e5864c7b6ef9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to this layer object. <br /></td></tr>
<tr class="separator:a8e73c37c7b57ad4ef8e5864c7b6ef9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add760357aa052c8e69debaa81d07be8d" id="r_add760357aa052c8e69debaa81d07be8d"><td class="memItemLeft" align="right" valign="top"><a id="add760357aa052c8e69debaa81d07be8d" name="add760357aa052c8e69debaa81d07be8d"></a>
const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a901830b3e2d9731cba401166650da1a2">ThisLayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thisLayer</b> () const</td></tr>
<tr class="memdesc:add760357aa052c8e69debaa81d07be8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "const" access to this layer object. <br /></td></tr>
<tr class="separator:add760357aa052c8e69debaa81d07be8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db16fc13a2d49a272b067a6d04ed21" id="r_a40db16fc13a2d49a272b067a6d04ed21"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a40db16fc13a2d49a272b067a6d04ed21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a40db16fc13a2d49a272b067a6d04ed21">update</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a40db16fc13a2d49a272b067a6d04ed21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:a40db16fc13a2d49a272b067a6d04ed21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3656112afd3d327855b8d5c93b8a6779" id="r_a3656112afd3d327855b8d5c93b8a6779"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:a3656112afd3d327855b8d5c93b8a6779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update</a> (TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a3656112afd3d327855b8d5c93b8a6779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data.  <br /></td></tr>
<tr class="separator:a3656112afd3d327855b8d5c93b8a6779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7208620e2ac60a6e3dc8fc4f6b836a8c" id="r_a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7208620e2ac60a6e3dc8fc4f6b836a8c">updateFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a7208620e2ac60a6e3dc8fc4f6b836a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618765cb8b7314e718cbcbbe7c880c6d" id="r_a618765cb8b7314e718cbcbbe7c880c6d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TIter &gt; </td></tr>
<tr class="memitem:a618765cb8b7314e718cbcbbe7c880c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached</a> (TAllFields &amp;allFields, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a618765cb8b7314e718cbcbbe7c880c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields.  <br /></td></tr>
<tr class="separator:a618765cb8b7314e718cbcbbe7c880c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6799fbfb090ea3a612d3757a0d28fd06" id="r_a6799fbfb090ea3a612d3757a0d28fd06"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a6799fbfb090ea3a612d3757a0d28fd06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write</a> (const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:a6799fbfb090ea3a612d3757a0d28fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence.  <br /></td></tr>
<tr class="separator:a6799fbfb090ea3a612d3757a0d28fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0877d7cedb580508e91ecfb7353227d" id="r_af0877d7cedb580508e91ecfb7353227d"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:af0877d7cedb580508e91ecfb7353227d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d">writeFieldsCached</a> (TAllFields &amp;allFields, const TMsg &amp;msg, TIter &amp;iter, std::size_t size) const</td></tr>
<tr class="memdesc:af0877d7cedb580508e91ecfb7353227d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise message into output data sequence while caching the written transport information fields.  <br /></td></tr>
<tr class="separator:af0877d7cedb580508e91ecfb7353227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3abb2d85e1433979aabeb6b09c7a2037" id="r_a3abb2d85e1433979aabeb6b09c7a2037"><td class="memTemplParams" colspan="2">template&lt;typename TAllFields &gt; </td></tr>
<tr class="memitem:a3abb2d85e1433979aabeb6b09c7a2037"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3abb2d85e1433979aabeb6b09c7a2037">accessCachedField</a> (TAllFields &amp;allFields) -&gt; decltype(std::get&lt; std::tuple_size&lt; typename std::decay&lt; TAllFields &gt;::type &gt;::value - std::tuple_size&lt; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> &gt;::value &gt;(allFields))</td></tr>
<tr class="memdesc:a3abb2d85e1433979aabeb6b09c7a2037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access appropriate field from "cached" bundle of all the protocol stack fields.  <br /></td></tr>
<tr class="separator:a3abb2d85e1433979aabeb6b09c7a2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b40f0c816054179e57b653390662710" id="r_a5b40f0c816054179e57b653390662710"><td class="memItemLeft" align="right" valign="top"><a id="a5b40f0c816054179e57b653390662710" name="a5b40f0c816054179e57b653390662710"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSplitRead</b> ()</td></tr>
<tr class="memdesc:a5b40f0c816054179e57b653390662710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether split read "until" and "from" data layer is allowed. <br /></td></tr>
<tr class="separator:a5b40f0c816054179e57b653390662710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e86bd01b3f9a678e22ec65251d98d07" id="r_a8e86bd01b3f9a678e22ec65251d98d07"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength</a> ()</td></tr>
<tr class="memdesc:a8e86bd01b3f9a678e22ec65251d98d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval.  <br /></td></tr>
<tr class="separator:a8e86bd01b3f9a678e22ec65251d98d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7b69ced04179d389e1458f94d223c" id="r_adab7b69ced04179d389e1458f94d223c"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:adab7b69ced04179d389e1458f94d223c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#adab7b69ced04179d389e1458f94d223c">doFieldLength</a> (const TMsg &amp;)</td></tr>
<tr class="memdesc:adab7b69ced04179d389e1458f94d223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of field length retrieval when message is known.  <br /></td></tr>
<tr class="separator:adab7b69ced04179d389e1458f94d223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c349256cce9400c95765098c8dbb9" id="r_a946c349256cce9400c95765098c8dbb9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a946c349256cce9400c95765098c8dbb9">hasExtendingClass</a> ()</td></tr>
<tr class="memdesc:a946c349256cce9400c95765098c8dbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option.  <br /></td></tr>
<tr class="separator:a946c349256cce9400c95765098c8dbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66fa75d25cc446952f80da6141882b" id="r_a2e66fa75d25cc446952f80da6141882b"><td class="memItemLeft" align="right" valign="top"><a id="a2e66fa75d25cc446952f80da6141882b" name="a2e66fa75d25cc446952f80da6141882b"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasMsgFactory</b> ()</td></tr>
<tr class="memdesc:a2e66fa75d25cc446952f80da6141882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry of whether custom message factory class has been provided via <a class="el" href="structcomms_1_1option_1_1app_1_1MsgFactory.html">comms::option::app::MsgFactory</a> or <a class="el" href="structcomms_1_1option_1_1app_1_1MsgFactoryTempl.html">comms::option::app::MsgFactoryTempl</a> options. <br /></td></tr>
<tr class="separator:a2e66fa75d25cc446952f80da6141882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add556798c4254b8307a8934b74425663" id="r_add556798c4254b8307a8934b74425663"><td class="memItemLeft" align="right" valign="top"><a id="add556798c4254b8307a8934b74425663" name="add556798c4254b8307a8934b74425663"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDispatchLinearSwitch</b> ()</td></tr>
<tr class="memdesc:add556798c4254b8307a8934b74425663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether linear switch dispatch is generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:add556798c4254b8307a8934b74425663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4de47b7529fd1e3abfd48e79d5a111" id="r_a7e4de47b7529fd1e3abfd48e79d5a111"><td class="memItemLeft" align="right" valign="top"><a id="a7e4de47b7529fd1e3abfd48e79d5a111" name="a7e4de47b7529fd1e3abfd48e79d5a111"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDispatchPolymorphic</b> ()</td></tr>
<tr class="memdesc:a7e4de47b7529fd1e3abfd48e79d5a111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether polymorphic dispatch tables are generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:a7e4de47b7529fd1e3abfd48e79d5a111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733590a98d0ba765703c8552bd736c78" id="r_a733590a98d0ba765703c8552bd736c78"><td class="memItemLeft" align="right" valign="top"><a id="a733590a98d0ba765703c8552bd736c78" name="a733590a98d0ba765703c8552bd736c78"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDispatchStaticBinSearch</b> ()</td></tr>
<tr class="memdesc:a733590a98d0ba765703c8552bd736c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time inquiry whether static binary search dispatch is generated internally to map message ID to actual type. <br /></td></tr>
<tr class="separator:a733590a98d0ba765703c8552bd736c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8c3cd18e7178cb3587a23622a7c1e6b1" id="r_a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="memItemLeft" align="right" valign="top"><a id="a8c3cd18e7178cb3587a23622a7c1e6b1" name="a8c3cd18e7178cb3587a23622a7c1e6b1"></a>
static const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>NumOfLayers</b> = 1 + NextLayer::NumOfLayers</td></tr>
<tr class="memdesc:a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static constant indicating amount of transport layers used. <br /></td></tr>
<tr class="separator:a8c3cd18e7178cb3587a23622a7c1e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5c04cd72f7c4151e6721dce4f5a85aa6" id="r_a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5c04cd72f7c4151e6721dce4f5a85aa6">setMissingSize</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a5c04cd72f7c4151e6721dce4f5a85aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12ce31667393e09be74f7c58df52b67" id="r_ad12ce31667393e09be74f7c58df52b67"><td class="memTemplParams" colspan="2">template&lt;typename TId , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ad12ce31667393e09be74f7c58df52b67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad12ce31667393e09be74f7c58df52b67">setMsgId</a> (TId val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:ad12ce31667393e09be74f7c58df52b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message ID information if such is requested.  <br /></td></tr>
<tr class="separator:ad12ce31667393e09be74f7c58df52b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a835776b7e489560f660e688c1be3c3" id="r_a6a835776b7e489560f660e688c1be3c3"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a6a835776b7e489560f660e688c1be3c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6a835776b7e489560f660e688c1be3c3">setMsgIndex</a> (std::size_t val, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a6a835776b7e489560f660e688c1be3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the message index information if such is requested.  <br /></td></tr>
<tr class="separator:a6a835776b7e489560f660e688c1be3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c7d7975ea9fd31bb6bfc0c688bf1af" id="r_a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a16c7d7975ea9fd31bb6bfc0c688bf1af">updateMissingSize</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a16c7d7975ea9fd31bb6bfc0c688bf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8526ebff3febc385edec2a1e9ef1ae6e" id="r_a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memTemplParams" colspan="2">template&lt;typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8526ebff3febc385edec2a1e9ef1ae6e">updateMissingSize</a> (std::size_t size, TExtraValues... extraValues) const</td></tr>
<tr class="memdesc:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the missing size information if such is requested.  <br /></td></tr>
<tr class="separator:a8526ebff3febc385edec2a1e9ef1ae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab53d12505a533c7ad4d2741381beec06" id="r_ab53d12505a533c7ad4d2741381beec06"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:ab53d12505a533c7ad4d2741381beec06"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ab53d12505a533c7ad4d2741381beec06">beforeRead</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TMsg &amp;msg)</td></tr>
<tr class="memdesc:ab53d12505a533c7ad4d2741381beec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extra operation before read.  <br /></td></tr>
<tr class="separator:ab53d12505a533c7ad4d2741381beec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7050fb0df8e4efc8cc3e35214436fe55" id="r_a7050fb0df8e4efc8cc3e35214436fe55"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a7050fb0df8e4efc8cc3e35214436fe55"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7050fb0df8e4efc8cc3e35214436fe55">doReadField</a> (const TMsg *msgPtr, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a7050fb0df8e4efc8cc3e35214436fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the layer field.  <br /></td></tr>
<tr class="separator:a7050fb0df8e4efc8cc3e35214436fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d913a4c2d569ce9c0842b9e16a0cb" id="r_a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TIter &gt; </td></tr>
<tr class="memitem:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a2a7d913a4c2d569ce9c0842b9e16a0cb">doWriteField</a> (const TMsg *msgPtr, const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field, TIter &amp;iter, std::size_t len)</td></tr>
<tr class="memdesc:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the layer field.  <br /></td></tr>
<tr class="separator:a2a7d913a4c2d569ce9c0842b9e16a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8953d8b40e947d0b155cffc60ea653f" id="r_ad8953d8b40e947d0b155cffc60ea653f"><td class="memTemplParams" colspan="2">template&lt;std::size_t TIdx, typename TAllFields &gt; </td></tr>
<tr class="memitem:ad8953d8b40e947d0b155cffc60ea653f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad8953d8b40e947d0b155cffc60ea653f">getField</a> (TAllFields &amp;allFields)</td></tr>
<tr class="memdesc:ad8953d8b40e947d0b155cffc60ea653f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve reference to a layer specific field out of all fields.  <br /></td></tr>
<tr class="separator:ad8953d8b40e947d0b155cffc60ea653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ff4a01821751edbf49a568d6b56f47" id="r_a04ff4a01821751edbf49a568d6b56f47"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e1ea3bdff923c98bf4687ed8b3f2c74">MsgIdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a04ff4a01821751edbf49a568d6b56f47">getMsgIdFromField</a> (const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a04ff4a01821751edbf49a568d6b56f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve message id from the field.  <br /></td></tr>
<tr class="separator:a04ff4a01821751edbf49a568d6b56f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7baefef2232316e08980e680d189ef" id="r_aff7baefef2232316e08980e680d189ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff7baefef2232316e08980e680d189ef"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef</a> ()</td></tr>
<tr class="memdesc:aff7baefef2232316e08980e680d189ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether type is actual message object.  <br /></td></tr>
<tr class="separator:aff7baefef2232316e08980e680d189ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0054511435ae10d307f05b458b3420a1" id="r_a0054511435ae10d307f05b458b3420a1"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a0054511435ae10d307f05b458b3420a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a0054511435ae10d307f05b458b3420a1">prepareFieldForWrite</a> (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a> id, const TMsg &amp;msg, <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;field)</td></tr>
<tr class="memdesc:a0054511435ae10d307f05b458b3420a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare field for writing.  <br /></td></tr>
<tr class="separator:a0054511435ae10d307f05b458b3420a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c83babc34313e54e04a4f12d24394c9" id="r_a0c83babc34313e54e04a4f12d24394c9"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:a0c83babc34313e54e04a4f12d24394c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a0c83babc34313e54e04a4f12d24394c9">resetMsg</a> (TMsg &amp;msg)</td></tr>
<tr class="memdesc:a0c83babc34313e54e04a4f12d24394c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>).  <br /></td></tr>
<tr class="separator:a0c83babc34313e54e04a4f12d24394c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0e556ee9a28ca50e4e3d6c3e1c3ebc" id="r_abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memTemplParams" colspan="2">template&lt;typename TMsg &gt; </td></tr>
<tr class="memitem:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#abe0e556ee9a28ca50e4e3d6c3e1c3ebc">toMsgPtr</a> (TMsg &amp;msg) -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;()))</td></tr>
<tr class="memdesc:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the message object.  <br /></td></tr>
<tr class="separator:abe0e556ee9a28ca50e4e3d6c3e1c3ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a7fb36c91416d5bbfd3434c164cc01692" id="r_a7fb36c91416d5bbfd3434c164cc01692"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(...)&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td></tr>
<tr class="memdesc:a7fb36c91416d5bbfd3434c164cc01692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a7fb36c91416d5bbfd3434c164cc01692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd385995c888a08f3c5c8647a3230f" id="r_ad8fd385995c888a08f3c5c8647a3230f"><td class="memItemLeft" align="right" valign="top"><a id="ad8fd385995c888a08f3c5c8647a3230f" name="ad8fd385995c888a08f3c5c8647a3230f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_PROTOCOL_LAYERS_ACCESS_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:ad8fd385995c888a08f3c5c8647a3230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a> <br /></td></tr>
<tr class="separator:ad8fd385995c888a08f3c5c8647a3230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d12f1394bc4c207a4734d75605c87" id="r_a394d12f1394bc4c207a4734d75605c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a394d12f1394bc4c207a4734d75605c87">COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a394d12f1394bc4c207a4734d75605c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a394d12f1394bc4c207a4734d75605c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7d81e8c974a2e774db1c5c126c7fa" id="r_a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(...)</td></tr>
<tr class="memdesc:a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a1ad7d81e8c974a2e774db1c5c126c7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf636c5d3c3b9ff161413c5d043cec99" id="r_abf636c5d3c3b9ff161413c5d043cec99"><td class="memItemLeft" align="right" valign="top"><a id="abf636c5d3c3b9ff161413c5d043cec99" name="abf636c5d3c3b9ff161413c5d043cec99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>COMMS_PROTOCOL_LAYERS_NAMES_INNER</b>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(__VA_ARGS__)</td></tr>
<tr class="memdesc:abf636c5d3c3b9ff161413c5d043cec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa" title="Provide names and convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_NAMES()</a> <br /></td></tr>
<tr class="separator:abf636c5d3c3b9ff161413c5d043cec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4451775274adbd829227dd0f459f70" id="r_a7d4451775274adbd829227dd0f459f70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7d4451775274adbd829227dd0f459f70">COMMS_PROTOCOL_LAYERS_NAMES_OUTER</a>(...)&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td></tr>
<tr class="memdesc:a7d4451775274adbd829227dd0f459f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide names and convenience access functions to protocol layers.  <br /></td></tr>
<tr class="separator:a7d4451775274adbd829227dd0f459f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1fd3aa724abaf48ab9636acb88742e" id="r_a8f1fd3aa724abaf48ab9636acb88742e"><td class="memTemplParams" colspan="2"><a id="a8f1fd3aa724abaf48ab9636acb88742e" name="a8f1fd3aa724abaf48ab9636acb88742e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f1fd3aa724abaf48ab9636acb88742e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isMsgIdLayer</b> ()</td></tr>
<tr class="memdesc:a8f1fd3aa724abaf48ab9636acb88742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of whether the provided type is a variant of <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a>. <br /></td></tr>
<tr class="separator:a8f1fd3aa724abaf48ab9636acb88742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac9c47bcb2d5407fb4679cff923b1f86a" name="ac9c47bcb2d5407fb4679cff923b1f86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c47bcb2d5407fb4679cff923b1f86a">&#9670;&#160;</a></span>AllFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::AllFields =  typename std::decay&lt; decltype( std::tuple_cat( std::declval&lt;std::tuple&lt;<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a>&gt; &gt;(), std::declval&lt;typename TNextLayer::AllFields&gt;()) ) &gt;::type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of all the fields of all the transport layers wrapped in std::tuple. </p>
<p>The <a class="el" href="classcomms_1_1Field.html">Field</a> type is prepended to the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac0f9a7163ba2a95f8246fcd8a6b71476">NextLayer</a> and reported as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> of this one. </p>

</div>
</div>
<a id="adac44d41a98b7d097e324b235a2d21b6" name="adac44d41a98b7d097e324b235a2d21b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac44d41a98b7d097e324b235a2d21b6">&#9670;&#160;</a></span>ExtendingClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::ExtendingClass =  typename ParsedOptionsInternal::ExtendingClass</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of real extending class. </p>
<p>Updated when <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> extension option us used, aliasing <b>void</b> if the options is not used. </p>

</div>
</div>
<a id="a3444598e8ae44eaa5b09f11b694a1670" name="a3444598e8ae44eaa5b09f11b694a1670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3444598e8ae44eaa5b09f11b694a1670">&#9670;&#160;</a></span>MsgPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::MsgPtr =  typename <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7">MsgFactory::MsgPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of smart pointer that will hold allocated message object. </p>
<p>Same as <a class="el" href="classcomms_1_1MsgFactory.html#adfa8fb1cd206c2fd25a97bd0a4e57cd7" title="Smart pointer to Message which holds allocated message object.">comms::MsgFactory::MsgPtr</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3abb2d85e1433979aabeb6b09c7a2037" name="a3abb2d85e1433979aabeb6b09c7a2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abb2d85e1433979aabeb6b09c7a2037">&#9670;&#160;</a></span>accessCachedField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::accessCachedField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td> -&gt; decltype(std::get&lt;std::tuple_size&lt;typename std::decay&lt;TAllFields&gt;::type&gt;::value - std::tuple_size&lt;<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a>&gt;::value&gt;(allFields))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access appropriate field from "cached" bundle of all the protocol stack fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFields</td><td>All fields of the protocol stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to requested field. </dd></dl>

</div>
</div>
<a id="ab53d12505a533c7ad4d2741381beec06" name="ab53d12505a533c7ad4d2741381beec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d12505a533c7ad4d2741381beec06">&#9670;&#160;</a></span>beforeRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::beforeRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extra operation before read. </p>
<p>Function called after appropriate message object has been created and before read operation is forwared to inner layer. <br  />
 Default implementation does nothing, may be overriden in the derived class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> of the layer that was successfully read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to message object, either interface class or message object itself (depending on how <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read().">doRead()</a> was invoked). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a96cd09fb8c2b96fcffdfbad758c0fd59" name="a96cd09fb8c2b96fcffdfbad758c0fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cd09fb8c2b96fcffdfbad758c0fd59">&#9670;&#160;</a></span>createMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a1d685a7699faa3e9732a23943efab26f">CreateFailureReason</a> *&#160;</td>
          <td class="paramname"><em>reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create message object given the ID.   </p>
<p>Hides and overrides <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a96cd09fb8c2b96fcffdfbad758c0fd59" title="Create message object given the ID.">createMsg()</a> function inherited from <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>. This function forwards the request to the message factory object (<a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a>) embedded as a private data member of this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reason</td><td>Failure reason in case creation has failed. May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to the created message object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1MsgFactory.html#a5b1ad877b2b4c26ed0e64675e0b245d3" title="Create message object given the ID of the message.">comms::MsgFactory::createMsg()</a> </dd></dl>

</div>
</div>
<a id="a41e188996511ff20f659abad642ea40c" name="a41e188996511ff20f659abad642ea40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e188996511ff20f659abad642ea40c">&#9670;&#160;</a></span>createMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::createMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create message object given the ID. </p>
<p>The default implementation is to forwards this call to the next layer. One of the layers (usually <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a>) hides and overrides this implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the message. </td></tr>
    <tr><td class="paramname">idx</td><td>Relative index of the message with the same ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer (variant of std::unique_ptr) to allocated message object </dd></dl>

</div>
</div>
<a id="a8e86bd01b3f9a678e22ec65251d98d07" name="a8e86bd01b3f9a678e22ec65251d98d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e86bd01b3f9a678e22ec65251d98d07">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. </dd></dl>

</div>
</div>
<a id="adab7b69ced04179d389e1458f94d223c" name="adab7b69ced04179d389e1458f94d223c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab7b69ced04179d389e1458f94d223c">&#9670;&#160;</a></span>doFieldLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doFieldLength </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of field length retrieval when message is known. </p>
<p>Default implementation returns </p><div class="fragment"><div class="line">Field::minLength();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Can be overriden by the extending class. <br  />
 </dd></dl>

</div>
</div>
<a id="af00d71aa57799789befc68189f7f718f" name="af00d71aa57799789befc68189f7f718f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00d71aa57799789befc68189f7f718f">&#9670;&#160;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerReader , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::doRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerReader &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerReader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized read functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p>
<p>The function will read message ID from the data sequence first, generate appropriate (or validate provided) message object based on the read ID and forward the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a> request to the next layer. If the message object cannot be generated (the message type is not provided inside <b>TAllMessages</b> template parameter), but the <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option has beed used, the <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> may be generated instead.<br  />
 <b>NOTE</b>, that <b>msg</b> parameter can be either reference to a smart pointer, which will hold allocated object, or to previously allocated object itself. In case of the latter, the function will compare read and expected message ID value and will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">comms::ErrorStatus::InvalidMsgId</a> in case of mismatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
    <tr><td class="paramname">TNextLayerReader</td><td>next layer reader object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer that will hold allocated message object, or to the previously allocated message object itself (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerReader</td><td>Reader object, needs to be invoked to forward read operation to the next layer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic extra output parameters passed to the "read" operatation of the protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a>). Need to passed on as variadic arguments to the <b>nextLayerReader</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><b>msg</b> parameter, in case of being a smart pointer, doesn't point to any object: <div class="fragment"><div class="line">assert(!msg); </div>
</div><!-- fragment --> </dd>
<dd>
Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object (in case of being a smart pointer). </dd></dl>

</div>
</div>
<a id="a7050fb0df8e4efc8cc3e35214436fe55" name="a7050fb0df8e4efc8cc3e35214436fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7050fb0df8e4efc8cc3e35214436fe55">&#9670;&#160;</a></span>doReadField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doReadField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be populated </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a1f3eda36afa45e1c226b342980d121ea" name="a1f3eda36afa45e1c226b342980d121ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3eda36afa45e1c226b342980d121ea">&#9670;&#160;</a></span>doUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>Similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate()</a> but also receiving recently written message object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f23dc39f0adb4fd7ecd0ab2941588f" name="a94f23dc39f0adb4fd7ecd0ab2941588f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f23dc39f0adb4fd7ecd0ab2941588f">&#9670;&#160;</a></span>doUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter , typename TNextLayerUpdater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerUpdater &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerUpdater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the "update" functaionality. </p>
<p>It will be invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached()</a> member function, unless the derived class provides its own <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate()</a> member function to override the default behavior.<br  />
 This function in this layer does nothing, just advances the iterator by the length of the <a class="el" href="classcomms_1_1Field.html">Field</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIter</td><td>Type of iterator used for updating. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer updater object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> that needs to be updated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerUpdater</td><td>Next layer updater object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d804fa610375e1379c43549d1b20981" name="a7d804fa610375e1379c43549d1b20981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d804fa610375e1379c43549d1b20981">&#9670;&#160;</a></span>doWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename TNextLayerWriter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::doWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TNextLayerWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>nextLayerWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Customized write functionality, invoked by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p>
<p>The function will write ID of the message to the data sequence, then call <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a> member function of the next protocol layer. If <b>TMsg</b> type is recognised to be actual message type (inherited from <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> while using <a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> option to specify its numeric ID), its defined <b>doGetId()</b> member function (see <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5" title="Default implementation of ID retrieval functionality.">comms::MessageBase::doGetId()</a>) non virtual function is called. Otherwise polymorphic <b>getId()</b> member function is used to retrieve the message ID information, which means the message interface class must use <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option to define appropriate interface. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
    <tr><td class="paramname">TNextLayerWriter</td><td>next layer writer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object to update and write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextLayerWriter</td><td>Next layer writer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="a2a7d913a4c2d569ce9c0842b9e16a0cb" name="a2a7d913a4c2d569ce9c0842b9e16a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d913a4c2d569ce9c0842b9e16a0cb">&#9670;&#160;</a></span>doWriteField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::doWriteField </td>
          <td>(</td>
          <td class="paramtype">const TMsg *&#160;</td>
          <td class="paramname"><em>msgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the layer field. </p>
<p>The default implementation invokes <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a></b> operation of the passed field object. The function can be overriden by the extending class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgPtr</td><td>Pointer to message object (if available), can be nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> object value of which needs to be written </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing, expected to be advanced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class, but needs to be const. </dd></dl>

</div>
</div>
<a id="ad8953d8b40e947d0b155cffc60ea653f" name="ad8953d8b40e947d0b155cffc60ea653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8953d8b40e947d0b155cffc60ea653f">&#9670;&#160;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;std::size_t TIdx, typename TAllFields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp; <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::getField </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve reference to a layer specific field out of all fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIdx</td><td>Index of the field in tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04ff4a01821751edbf49a568d6b56f47" name="a04ff4a01821751edbf49a568d6b56f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ff4a01821751edbf49a568d6b56f47">&#9670;&#160;</a></span>getMsgIdFromField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a5e1ea3bdff923c98bf4687ed8b3f2c74">MsgIdType</a> <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::getMsgIdFromField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve message id from the field. </p>
<p>May be overridden by the extending class </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> for this layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a946c349256cce9400c95765098c8dbb9" name="a946c349256cce9400c95765098c8dbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946c349256cce9400c95765098c8dbb9">&#9670;&#160;</a></span>hasExtendingClass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::hasExtendingClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time inquiry of whether this class was extended via <a class="el" href="namespacecomms_1_1option.html#a36cef7e87cf2288100d2a497f7960ac9">comms::option::ExtendingClass</a> option. </p>
<p>If <b>true</b> is returned, the <a class="el" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html#a500393d855e33af4d7debff9d127c0f6">ExtendingClass</a> type aliasing the real layer type. </p>

</div>
</div>
<a id="aff7baefef2232316e08980e680d189ef" name="aff7baefef2232316e08980e680d189ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7baefef2232316e08980e680d189ef">&#9670;&#160;</a></span>isMessageObjRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::isMessageObjRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether type is actual message object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <b>T</b> type is extending <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>, <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a id="a5d8d04d96eb426cc76884229e2286bf0" name="a5d8d04d96eb426cc76884229e2286bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8d04d96eb426cc76884229e2286bf0">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information. </p>
<p>The message data always get wrapped with transport information to be successfully delivered to and unpacked on the other side. This function return remaining length of the transport information. It performs a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength()</a> member function to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="aec23ed57e71adb55cf7f11f6282a6279" name="aec23ed57e71adb55cf7f11f6282a6279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec23ed57e71adb55cf7f11f6282a6279">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::length </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get remaining length of wrapping transport information + length of the provided message. </p>
<p>This function usually gets called when there is a need to identify the size of the buffer required to write provided message wrapped in the transport information. This function is very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5d8d04d96eb426cc76884229e2286bf0" title="Get remaining length of wrapping transport information.">length()</a>, but adds also length of the message. It performs a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8e86bd01b3f9a678e22ec65251d98d07">doFieldLength()</a> member function with message parameter to get info about current field length. To update the default behaviour just override the function in the derived class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of message object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the field + length reported by the next layer. </dd></dl>

</div>
</div>
<a id="a0054511435ae10d307f05b458b3420a1" name="a0054511435ae10d307f05b458b3420a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0054511435ae10d307f05b458b3420a1">&#9670;&#160;</a></span>prepareFieldForWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TMessage , typename TAllMessages , typename TNextLayer , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt; TField, TMessage, TAllMessages, TNextLayer, TOptions &gt;::prepareFieldForWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a08f0776807632af96afcee3fac19a910">MsgIdParamType</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare field for writing. </p>
<p>Must assign provided id value. May be overridden by the extending class if some complex functionality is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object being written </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a>, value of which needs to be populated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>May be non-static in the extending class </dd></dl>

</div>
</div>
<a id="a60d0ea06c68e5b885bf651d7a7b14d1a" name="a60d0ea06c68e5b885bf651d7a7b14d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d0ea06c68e5b885bf651d7a7b14d1a">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::read </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader, <span class="keyword">typename</span>... TExtraValues&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f">doRead</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a>&amp; field, <span class="comment">// field object used to read required data</span></div>
<div class="line">    TMsg&amp; msg, <span class="comment">// Ref to smart pointer to message object, or message object itself</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for reading</span></div>
<div class="line">    std::size_t size, <span class="comment">// size of the remaining data</span></div>
<div class="line">    TNextLayerReader&amp;&amp; nextLayerReader, <span class="comment">// next layer reader object</span></div>
<div class="line">    TExtraValues... extraValues)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer read, such as reading the field value</span></div>
<div class="line">    <span class="keyword">auto</span> es = field.read(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform read operation</span></div>
<div class="line">    es = nextLayerReader.read(msg, iter, size - field.length(), extraValues...);</div>
<div class="line">    ... <span class="comment">// internal logic after next layer read if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgIdLayer_html_ac32b32cf672476ce4dbb77d1529a064b"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">comms::protocol::MsgIdLayer::Field</a></div><div class="ttdeci">typename BaseImpl::Field Field</div><div class="ttdoc">Type of the field object used to read/write message ID value.</div><div class="ttdef"><b>Definition</b> MsgIdLayer.h:126</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgIdLayer_html_af00d71aa57799789befc68189f7f718f"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f">comms::protocol::MsgIdLayer::doRead</a></div><div class="ttdeci">comms::ErrorStatus doRead(Field &amp;field, TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerReader &amp;&amp;nextLayerReader, TExtraValues... extraValues)</div><div class="ttdoc">Customized read functionality, invoked by read().</div><div class="ttdef"><b>Definition</b> MsgIdLayer.h:205</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition</b> ErrorStatus.h:17</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerReader.read()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a" title="Deserialise message from the input data sequence.">read()</a></b> member function. The implemented <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read().">doRead()</a></b> member function also may use the following inherited protected member to set values of variadic parameters in case they are provided. </p><ul>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a8526ebff3febc385edec2a1e9ef1ae6e">updateMissingSize()</a> - to calculate update missing size if such is requested. </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5c04cd72f7c4151e6721dce4f5a85aa6">setMissingSize()</a> - to set specific value as missing size if suce information is requested. </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad12ce31667393e09be74f7c58df52b67">setMsgId()</a> - to set the value of message id </li>
<li><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6a835776b7e489560f660e688c1be3c3">setMsgIndex()</a> - to set the value of message index. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions: <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>, <a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a>, <a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a>, <a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
Returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation.">comms::ErrorStatus::Success</a> if and only if msg points to a valid object. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ad22a30d6baba8a074f419fe710b809d5" name="ad22a30d6baba8a074f419fe710b809d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22a30d6baba8a074f419fe710b809d5">&#9670;&#160;</a></span>readFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialise message from the input data sequence while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a5255e8af10b4282aa26bd26c442af149" name="a5255e8af10b4282aa26bd26c442af149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255e8af10b4282aa26bd26c442af149">&#9670;&#160;</a></span>readFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>

</div>
</div>
<a id="a5284c998b89075667fc48c15fde5569d" name="a5284c998b89075667fc48c15fde5569d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5284c998b89075667fc48c15fde5569d">&#9670;&#160;</a></span>readFromDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readFromDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finalise the read operation by reading the message payload while caching the read transport information fields. </p>
<p>Should be called to finalise the read operation started by <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6acc0b55d486dc2b4c9b9882af6eac3e">readUntilDataFieldsCached()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a4bb4443e76fb35263561c2b285c5d63e" name="a4bb4443e76fb35263561c2b285c5d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb4443e76fb35263561c2b285c5d63e">&#9670;&#160;</a></span>readUntilData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilData </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload). </p>
<p>Same as <b>read</b> by stops read operation when data layer is reached. Expected to be followed by a call to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a5255e8af10b4282aa26bd26c442af149">readFromData()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Input iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data in the sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually read. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd>
<dd>
missingSize output value is updated if and only if function returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </dd></dl>

</div>
</div>
<a id="a6acc0b55d486dc2b4c9b9882af6eac3e" name="a6acc0b55d486dc2b4c9b9882af6eac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acc0b55d486dc2b4c9b9882af6eac3e">&#9670;&#160;</a></span>readUntilDataFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::readUntilDataFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform read of data fields until data layer (message payload) while caching the read transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a4bb4443e76fb35263561c2b285c5d63e">readUntilData()</a> member function, but adds "allFields" parameter to store read transport information fields. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#af00d71aa57799789befc68189f7f718f" title="Customized read functionality, invoked by read().">doRead()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Reference to smart pointer, that already holds or will hold allocated message object, or reference to actual message object (which extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for reading. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes available for reading. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Extra output parameters provided using one of the following functions <ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a05ca17bbf32e909d635a9fd8f53e9127">comms::protocol::msgPayload()</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>

</div>
</div>
<a id="a0c83babc34313e54e04a4f12d24394c9" name="a0c83babc34313e54e04a4f12d24394c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c83babc34313e54e04a4f12d24394c9">&#9670;&#160;</a></span>resetMsg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::resetMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset msg in case it is a smart pointer (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a>). </p>
<p>Does nothing if passed parameter is actual message object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a5c04cd72f7c4151e6721dce4f5a85aa6" name="a5c04cd72f7c4151e6721dce4f5a85aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c04cd72f7c4151e6721dce4f5a85aa6">&#9670;&#160;</a></span>setMissingSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the missing size information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad12ce31667393e09be74f7c58df52b67" name="ad12ce31667393e09be74f7c58df52b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12ce31667393e09be74f7c58df52b67">&#9670;&#160;</a></span>setMsgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TId , typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgId </td>
          <td>(</td>
          <td class="paramtype">TId&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message ID information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#a7d438d680a6554bdfd0acce5624f867d">comms::protocol::msgId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a835776b7e489560f660e688c1be3c3" name="a6a835776b7e489560f660e688c1be3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a835776b7e489560f660e688c1be3c3">&#9670;&#160;</a></span>setMsgIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::setMsgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the message index information if such is requested. </p>
<p>Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe0e556ee9a28ca50e4e3d6c3e1c3ebc" name="abe0e556ee9a28ca50e4e3d6c3e1c3ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0e556ee9a28ca50e4e3d6c3e1c3ebc">&#9670;&#160;</a></span>toMsgPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::toMsgPtr </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> -&gt; decltype(toMsgPtrInternal(msg, MsgTypeTag&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the message object. </p>
<p>The function works seamlessly for both smart pointer and reference to the real object </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef()</a>. </dd></dl>

</div>
</div>
<a id="a40db16fc13a2d49a272b067a6d04ed21" name="a40db16fc13a2d49a272b067a6d04ed21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40db16fc13a2d49a272b067a6d04ed21">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> but also receiving recently written message object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a3656112afd3d327855b8d5c93b8a6779" name="a3656112afd3d327855b8d5c93b8a6779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3656112afd3d327855b8d5c93b8a6779">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::update </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>) message contents data. </p>
<p>Sometimes, when NON random access iterator is used for writing (for example std::back_insert_iterator), some transport data cannot be properly written. In this case, <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a> function will return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. When such status is returned it is necessary to call <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779" title="Update recently written (using write()) message contents data.">update()</a> with random access iterator on the written buffer to update written dummy information with proper values.<br  />
 The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided (or inherited) by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a>&amp; field, <span class="comment">// field object to update and re-write if necessary</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for updateing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Number of remaning bytes in the output buffer.</span></div>
<div class="line">    TNextLayerUpdater&amp;&amp; nextLayerUpdater <span class="comment">// next layer updater object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer update, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and re-writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform update operation</span></div>
<div class="line">    es = nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ProtocolLayerBase_html_a94f23dc39f0adb4fd7ecd0ab2941588f"><div class="ttname"><a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">comms::protocol::ProtocolLayerBase::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Default implementation of the &quot;update&quot; functaionality.</div><div class="ttdef"><b>Definition</b> ProtocolLayerBase.h:707</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779" title="Update recently written (using write()) message contents data.">update()</a></b> member function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Any random access iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a7208620e2ac60a6e3dc8fc4f6b836a8c" name="a7208620e2ac60a6e3dc8fc4f6b836a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7208620e2ac60a6e3dc8fc4f6b836a8c">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to other <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached()</a> member function, but adds "msg" parameter to access message object if needed.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of <b>msg</b> parameter. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to recently written message object. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a618765cb8b7314e718cbcbbe7c880c6d" name="a618765cb8b7314e718cbcbbe7c880c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618765cb8b7314e718cbcbbe7c880c6d">&#9670;&#160;</a></span>updateFieldsCached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update recently written (using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>) message data as well as cached transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> member function, but adds "allFields" parameter to store raw data of the message.<br  />
 The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f" title="Default implementation of the &quot;update&quot; functaionality.">doUpdate()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of the random access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Random access iterator to the written data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes that have been written using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d" title="Serialise message into output data sequence while caching the written transport information fields.">writeFieldsCached()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the update operation. </dd></dl>

</div>
</div>
<a id="a16c7d7975ea9fd31bb6bfc0c688bf1af" name="a16c7d7975ea9fd31bb6bfc0c688bf1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7d7975ea9fd31bb6bfc0c688bf1af">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a37d1bfc9f9d2e53ce518ebf019781f82">Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> read operation of which has failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8526ebff3febc385edec2a1e9ef1ae6e" name="a8526ebff3febc385edec2a1e9ef1ae6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8526ebff3febc385edec2a1e9ef1ae6e">&#9670;&#160;</a></span>updateMissingSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename... TExtraValues&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::updateMissingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the missing size information if such is requested. </p>
<p>Calculates the minimal required length to be yet read. Updates the value reference to which was passed to the "read" operation using <a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Remaining number of bytes in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extraValues</td><td>Variadic parameters passed to the "read" function such as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> or <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6799fbfb090ea3a612d3757a0d28fd06" name="a6799fbfb090ea3a612d3757a0d28fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6799fbfb090ea3a612d3757a0d28fd06">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence. </p>
<p>The function will invoke <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, which must have the following signature and logic: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line"><a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981">doWrite</a>(</div>
<div class="line">    <a class="code hl_typedef" href="classcomms_1_1protocol_1_1MsgIdLayer.html#ac32b32cf672476ce4dbb77d1529a064b">Field</a>&amp; field, <span class="comment">// field object used to update and write required data</span></div>
<div class="line">    <span class="keyword">const</span> TMsg&amp; msg, <span class="comment">// reference to ready to be sent message object</span></div>
<div class="line">    TIter&amp; iter, <span class="comment">// iterator used for writing</span></div>
<div class="line">    std::size_t size, <span class="comment">// Max number of bytes that can be written.</span></div>
<div class="line">    TNextLayerWriter&amp;&amp; nextLayerWriter <span class="comment">// next layer writer object</span></div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// internal logic prior next layer write, such as</span></div>
<div class="line">    <span class="comment">// updating field&#39;s value and writing it.</span></div>
<div class="line">    field.value() = ...;</div>
<div class="line">    <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// request next layer to perform write operation</span></div>
<div class="line">    es = nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    ... <span class="comment">// internal logic after next layer write if applicable</span></div>
<div class="line">    <span class="keywordflow">return</span> es;</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgIdLayer_html_a7d804fa610375e1379c43549d1b20981"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981">comms::protocol::MsgIdLayer::doWrite</a></div><div class="ttdeci">ErrorStatus doWrite(Field &amp;field, const TMsg &amp;msg, TIter &amp;iter, std::size_t size, TNextLayerWriter &amp;&amp;nextLayerWriter) const</div><div class="ttdoc">Customized write functionality, invoked by write().</div><div class="ttdef"><b>Definition</b> MsgIdLayer.h:273</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerWriter.write()</b> function is the same as the signature of this <b><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06" title="Serialise message into output data sequence.">write()</a></b> member function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to message object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Output iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Iterator must be valid and can be dereferenced and incremented at least "size" times; </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The iterator will be advanced by the number of bytes was actually written. In case of an error, distance between original position and advanced will pinpoint the location of the error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<a id="af0877d7cedb580508e91ecfb7353227d" name="af0877d7cedb580508e91ecfb7353227d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0877d7cedb580508e91ecfb7353227d">&#9670;&#160;</a></span>writeFieldsCached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<div class="memtemplate">
template&lt;typename TAllFields , typename TMsg , typename TIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions &gt;::writeFieldsCached </td>
          <td>(</td>
          <td class="paramtype">TAllFields &amp;&#160;</td>
          <td class="paramname"><em>allFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialise message into output data sequence while caching the written transport information fields. </p>
<p>Very similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a> member function, but adds "allFields" parameter to store raw data of the message. The function will also invoke the same <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a7d804fa610375e1379c43549d1b20981" title="Customized write functionality, invoked by write().">doWrite()</a></b> member function provided by the derived class, as described with <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllFields</td><td>std::tuple of all the transport fields, must be <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type defined in the last layer class that defines protocol stack. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the message being written. </td></tr>
    <tr><td class="paramname">TIter</td><td>Type of iterator used for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allFields</td><td>Reference to the std::tuple object that wraps all transport fields (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> type of the last protocol layer class). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Reference to the message object that is being written, </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter</td><td>Iterator used for writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Max number of bytes that can be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a7fb36c91416d5bbfd3434c164cc01692" name="a7fb36c91416d5bbfd3434c164cc01692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb36c91416d5bbfd3434c164cc01692">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>The first argument is a name for innermost layer (<a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>), while the last one is the name for the outermost one. </p>

</div>
</div>
<a id="a394d12f1394bc4c207a4734d75605c87" name="a394d12f1394bc4c207a4734d75605c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d12f1394bc4c207a4734d75605c87">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_ACCESS_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a>, but the arguments are expected to be in reverse order, i.e. the first argument is the name of the outermost layer, while the last one is the name for the innermost one (<a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>) </p>

</div>
</div>
<a id="a1ad7d81e8c974a2e774db1c5c126c7fa" name="a1ad7d81e8c974a2e774db1c5c126c7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad7d81e8c974a2e774db1c5c126c7fa">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_NAMES</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_NAMES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    COMMS_DO_LAYER_TYPE_ALIAS(Base, __VA_ARGS__) \</div>
<div class="line">    COMMS_DO_ACCESS_LAYER_ACC_FUNC(__VA_ARGS__)</div>
</div><!-- fragment -->
<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<a id="a7d4451775274adbd829227dd0f459f70" name="a7d4451775274adbd829227dd0f459f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4451775274adbd829227dd0f459f70">&#9670;&#160;</a></span>COMMS_PROTOCOL_LAYERS_NAMES_OUTER</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMS_PROTOCOL_LAYERS_NAMES_OUTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a1ad7d81e8c974a2e774db1c5c126c7fa">COMMS_PROTOCOL_LAYERS_NAMES</a>(COMMS_EXPAND(COMMS_REVERSE_MACRO_ARGS(__VA_ARGS__)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide names and convenience access functions to protocol layers. </p>
<p>Similar to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a394d12f1394bc4c207a4734d75605c87" title="Provide convenience access functions to protocol layers.">COMMS_PROTOCOL_LAYERS_ACCESS_OUTER()</a> but defines "Layer_&lt;name&gt;" type names. </p><dl class="section pre"><dt>Precondition</dt><dd>Requires definition of inner "Base" type aliasing the base class. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/comms/protocol/<a class="el" href="MsgIdLayer_8h_source.html">MsgIdLayer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
