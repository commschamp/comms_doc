<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">comms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace for all classes / functions of COMMS library.  
<a href="namespacecomms.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for all classes / functions of COMMS library. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecomms_1_1field"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1field.html">field</a></td></tr>
<tr class="memdesc:namespacecomms_1_1field"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace that contains definitions of all message fields. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecomms_1_1option"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1option.html">option</a></td></tr>
<tr class="memdesc:namespacecomms_1_1option"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace that contains all the options used to define protocol as well as customize application specific configuration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecomms_1_1protocol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html">protocol</a></td></tr>
<tr class="memdesc:namespacecomms_1_1protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace that contains definition of layers that can be used to wrap message data with transport data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecomms_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1traits.html">traits</a></td></tr>
<tr class="memdesc:namespacecomms_1_1traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for various traits tag classes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecomms_1_1units"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1units.html">units</a></td></tr>
<tr class="memdesc:namespacecomms_1_1units"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing units conversion operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecomms_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecomms_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for various utility classes and/or functions used by COMMS library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Assert.html">Assert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for any custom assertion behaviour.  <a href="classcomms_1_1Assert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1EmptyHandler.html">EmptyHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty message handler, does nothing.  <a href="classcomms_1_1EmptyHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1EnableAssert.html">EnableAssert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable new assertion behaviour.  <a href="classcomms_1_1EnableAssert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to all the field classes.  <a href="classcomms_1_1Field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericHandler.html">GenericHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic common message handler.  <a href="classcomms_1_1GenericHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1GenericMessage.html">GenericMessage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a>.  <a href="classcomms_1_1GenericMessage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1Message.html">Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main interface class for all the messages.  <a href="classcomms_1_1Message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all the custom protocol messages.  <a href="classcomms_1_1MessageBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgDispatcher.html">MsgDispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxiliary class to force a particular way of dispatching message to its handler.  <a href="classcomms_1_1MsgDispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1MsgFactory.html">MsgFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> factory class.  <a href="classcomms_1_1MsgFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7f9725d68be4564134834976fc83ba20"><td class="memTemplParams" colspan="2">template&lt;typename TFieldBase , typename TExtraOpts  = comms::option::app::EmptyOption&gt; </td></tr>
<tr class="memitem:a7f9725d68be4564134834976fc83ba20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a7f9725d68be4564134834976fc83ba20">GenericMessageFields</a> = std::tuple&lt; <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, std::uint8_t, TExtraOpts &gt; &gt;</td></tr>
<tr class="memdesc:a7f9725d68be4564134834976fc83ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of fields for <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> message.  <a href="namespacecomms.html#a7f9725d68be4564134834976fc83ba20">More...</a><br /></td></tr>
<tr class="separator:a7f9725d68be4564134834976fc83ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4df982066e6271a25217d483f6034b"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename TDefaultType  = std::intmax_t&gt; </td></tr>
<tr class="memitem:a6e4df982066e6271a25217d483f6034b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a6e4df982066e6271a25217d483f6034b">MessageIdType</a> = typename comms::util::LazyDeepConditional&lt; TMsg::InterfaceOptions::HasMsgIdType &gt;::template Type&lt; comms::details::MessageIdTypeRetriever, comms::util::AliasType, TDefaultType, TMsg &gt;</td></tr>
<tr class="memdesc:a6e4df982066e6271a25217d483f6034b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of message ID used by interface class.  <a href="namespacecomms.html#a6e4df982066e6271a25217d483f6034b">More...</a><br /></td></tr>
<tr class="separator:a6e4df982066e6271a25217d483f6034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0a259a03d68bce98b4a129fb34aaa2e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a> { <br />
&#160;&#160;<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">ErrorStatus::Success</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">ErrorStatus::UpdateRequired</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">ErrorStatus::NotEnoughData</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aca3da8f495e4e628912a7798655da6c2">ErrorStatus::ProtocolError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a68ec6e62c5fcbbb68b5ce093bdd60717">ErrorStatus::BufferOverflow</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">ErrorStatus::InvalidMsgId</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1af8ae6974f1ae12f9dd119049c9c47ebb">ErrorStatus::InvalidMsgData</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a37b538d9e3266acd66229ede1dcceb70">ErrorStatus::MsgAllocFailure</a>, 
<br />
&#160;&#160;<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb">ErrorStatus::NotSupported</a>, 
<a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a87f1cfab47938d0234207590e51f2959">ErrorStatus::NumOfErrorStatuses</a>
<br />
 }</td></tr>
<tr class="memdesc:a0a259a03d68bce98b4a129fb34aaa2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error statuses reported by the Communication module.  <a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">More...</a><br /></td></tr>
<tr class="separator:a0a259a03d68bce98b4a129fb34aaa2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b8201618df7a2022eb502b194826a4e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b8201618df7a2022eb502b194826a4e"><td class="memTemplItemLeft" align="right" valign="top">details::ValueAssignWrapper&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">cast_assign</a> (T &amp;value)</td></tr>
<tr class="memdesc:a5b8201618df7a2022eb502b194826a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to assign value with static_cast to appropriate type.  <a href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">More...</a><br /></td></tr>
<tr class="separator:a5b8201618df7a2022eb502b194826a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157c91f0dbf389c13f01975886124916"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a157c91f0dbf389c13f01975886124916"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a157c91f0dbf389c13f01975886124916">dispatchMsg</a> (TId &amp;&amp;id, std::size_t index, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:a157c91f0dbf389c13f01975886124916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior.  <a href="namespacecomms.html#a157c91f0dbf389c13f01975886124916">More...</a><br /></td></tr>
<tr class="separator:a157c91f0dbf389c13f01975886124916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2452362a2fe3788e868e4f40e54cf102"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a2452362a2fe3788e868e4f40e54cf102"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg</a> (TId &amp;&amp;id, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:a2452362a2fe3788e868e4f40e54cf102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior.  <a href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">More...</a><br /></td></tr>
<tr class="separator:a2452362a2fe3788e868e4f40e54cf102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1fdd50cb9a0cc15c108dfba57a23a4"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:afa1fdd50cb9a0cc15c108dfba57a23a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#afa1fdd50cb9a0cc15c108dfba57a23a4">dispatchMsg</a> (TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:afa1fdd50cb9a0cc15c108dfba57a23a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior.  <a href="namespacecomms.html#afa1fdd50cb9a0cc15c108dfba57a23a4">More...</a><br /></td></tr>
<tr class="separator:afa1fdd50cb9a0cc15c108dfba57a23a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2c64f47246460f460f2b7c7d3031df"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a0c2c64f47246460f460f2b7c7d3031df"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect</a> ()</td></tr>
<tr class="memdesc:a0c2c64f47246460f460f2b7c7d3031df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the message object can use its own polymorphic <b>dispatch()</b> (see <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>) when <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> is invoked.  <a href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">More...</a><br /></td></tr>
<tr class="separator:a0c2c64f47246460f460f2b7c7d3031df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c9c182e141da40135598e5f54ccfb"><td class="memTemplParams" colspan="2">template&lt;typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a5e8c9c182e141da40135598e5f54ccfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a5e8c9c182e141da40135598e5f54ccfb">dispatchMsgIsDirect</a> (TMsg &amp;&amp;msg, THandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a5e8c9c182e141da40135598e5f54ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to other <a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a>, but can help in deducing template arguments.  <a href="namespacecomms.html#a5e8c9c182e141da40135598e5f54ccfb">More...</a><br /></td></tr>
<tr class="separator:a5e8c9c182e141da40135598e5f54ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616720714175c82e10a6725d62393a5"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a0616720714175c82e10a6725d62393a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic</a> ()</td></tr>
<tr class="memdesc:a0616720714175c82e10a6725d62393a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> will use "polymorphic" (including "direct") dispatch for provided tuple of messages and handler.  <a href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">More...</a><br /></td></tr>
<tr class="separator:a0616720714175c82e10a6725d62393a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4130b5e308065717b8d71356fbd91f"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a3a4130b5e308065717b8d71356fbd91f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3a4130b5e308065717b8d71356fbd91f">dispatchMsgIsPolymorphic</a> (TMsg &amp;&amp;msg, THandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a3a4130b5e308065717b8d71356fbd91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to other <a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic()</a>, but can help in deducing template arguments.  <a href="namespacecomms.html#a3a4130b5e308065717b8d71356fbd91f">More...</a><br /></td></tr>
<tr class="separator:a3a4130b5e308065717b8d71356fbd91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c7f05f508ffaa6e3de6c7249c7f607"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a61c7f05f508ffaa6e3de6c7249c7f607"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch</a> ()</td></tr>
<tr class="memdesc:a61c7f05f508ffaa6e3de6c7249c7f607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> will use "static binary search" dispatch for provided tuple of messages and handler.  <a href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">More...</a><br /></td></tr>
<tr class="separator:a61c7f05f508ffaa6e3de6c7249c7f607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60741f830029beea5c6e38ef741b073"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ac60741f830029beea5c6e38ef741b073"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ac60741f830029beea5c6e38ef741b073">dispatchMsgIsStaticBinSearch</a> (TMsg &amp;&amp;msg, THandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ac60741f830029beea5c6e38ef741b073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to other <a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch()</a>, but can help in deducing template arguments.  <a href="namespacecomms.html#ac60741f830029beea5c6e38ef741b073">More...</a><br /></td></tr>
<tr class="separator:ac60741f830029beea5c6e38ef741b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f596641d4143e5fae65c5eea8f9a828"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a3f596641d4143e5fae65c5eea8f9a828"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3f596641d4143e5fae65c5eea8f9a828">dispatchMsgLinearSwitch</a> (TId &amp;&amp;id, std::size_t index, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:a3f596641d4143e5fae65c5eea8f9a828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior.  <a href="namespacecomms.html#a3f596641d4143e5fae65c5eea8f9a828">More...</a><br /></td></tr>
<tr class="separator:a3f596641d4143e5fae65c5eea8f9a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73708f2fe7ad6c62b9294106dd44fe5"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ad73708f2fe7ad6c62b9294106dd44fe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ad73708f2fe7ad6c62b9294106dd44fe5">dispatchMsgLinearSwitch</a> (TId &amp;&amp;id, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:ad73708f2fe7ad6c62b9294106dd44fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior.  <a href="namespacecomms.html#ad73708f2fe7ad6c62b9294106dd44fe5">More...</a><br /></td></tr>
<tr class="separator:ad73708f2fe7ad6c62b9294106dd44fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13cfefc96018a937a529e4e951033cb"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:af13cfefc96018a937a529e4e951033cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#af13cfefc96018a937a529e4e951033cb">dispatchMsgLinearSwitch</a> (TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:af13cfefc96018a937a529e4e951033cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior.  <a href="namespacecomms.html#af13cfefc96018a937a529e4e951033cb">More...</a><br /></td></tr>
<tr class="separator:af13cfefc96018a937a529e4e951033cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16d04b7d414caf729daa52a710b74ed"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ad16d04b7d414caf729daa52a710b74ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ad16d04b7d414caf729daa52a710b74ed">dispatchMsgPolymorphic</a> (TId &amp;&amp;id, std::size_t index, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:ad16d04b7d414caf729daa52a710b74ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior.  <a href="namespacecomms.html#ad16d04b7d414caf729daa52a710b74ed">More...</a><br /></td></tr>
<tr class="separator:ad16d04b7d414caf729daa52a710b74ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0286f72522d7804868bb551505a08e1"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ad0286f72522d7804868bb551505a08e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">dispatchMsgPolymorphic</a> (TId &amp;&amp;id, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:ad0286f72522d7804868bb551505a08e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior.  <a href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">More...</a><br /></td></tr>
<tr class="separator:ad0286f72522d7804868bb551505a08e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e57563068fbb504b49e5ad9835a692"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ab7e57563068fbb504b49e5ad9835a692"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ab7e57563068fbb504b49e5ad9835a692">dispatchMsgPolymorphic</a> (TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:ab7e57563068fbb504b49e5ad9835a692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior.  <a href="namespacecomms.html#ab7e57563068fbb504b49e5ad9835a692">More...</a><br /></td></tr>
<tr class="separator:ab7e57563068fbb504b49e5ad9835a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31149d8672043acec9acc15cb8072af9"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:a31149d8672043acec9acc15cb8072af9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">dispatchMsgStaticBinSearch</a> (TId &amp;&amp;id, std::size_t index, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:a31149d8672043acec9acc15cb8072af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior.  <a href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">More...</a><br /></td></tr>
<tr class="separator:a31149d8672043acec9acc15cb8072af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa770bd45a42589ce57a2263c48e89b48"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:aa770bd45a42589ce57a2263c48e89b48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#aa770bd45a42589ce57a2263c48e89b48">dispatchMsgStaticBinSearch</a> (TId &amp;&amp;id, TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:aa770bd45a42589ce57a2263c48e89b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior.  <a href="namespacecomms.html#aa770bd45a42589ce57a2263c48e89b48">More...</a><br /></td></tr>
<tr class="separator:aa770bd45a42589ce57a2263c48e89b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c95eaab170e35647ca537cd13f4d83"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </td></tr>
<tr class="memitem:ac3c95eaab170e35647ca537cd13f4d83"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ac3c95eaab170e35647ca537cd13f4d83">dispatchMsgStaticBinSearch</a> (TMsg &amp;msg, THandler &amp;handler) -&gt; details::MessageInterfaceDispatchRetType&lt; typename std::decay&lt; decltype(handler)&gt;::type &gt;</td></tr>
<tr class="memdesc:ac3c95eaab170e35647ca537cd13f4d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior.  <a href="namespacecomms.html#ac3c95eaab170e35647ca537cd13f4d83">More...</a><br /></td></tr>
<tr class="separator:ac3c95eaab170e35647ca537cd13f4d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de1104c31ee7b06c782dd84c9746e9"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:ab1de1104c31ee7b06c782dd84c9746e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ab1de1104c31ee7b06c782dd84c9746e9">dispatchMsgType</a> (TId &amp;&amp;id, std::size_t index, THandler &amp;handler)</td></tr>
<tr class="memdesc:ab1de1104c31ee7b06c782dd84c9746e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior.  <a href="namespacecomms.html#ab1de1104c31ee7b06c782dd84c9746e9">More...</a><br /></td></tr>
<tr class="separator:ab1de1104c31ee7b06c782dd84c9746e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6afbd722340e3bf0d18054bdab484cd"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:ae6afbd722340e3bf0d18054bdab484cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType</a> (TId &amp;&amp;id, THandler &amp;handler)</td></tr>
<tr class="memdesc:ae6afbd722340e3bf0d18054bdab484cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior.  <a href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">More...</a><br /></td></tr>
<tr class="separator:ae6afbd722340e3bf0d18054bdab484cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7e7a7833eb7c1c80a665fd0f15f0af"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId &gt; </td></tr>
<tr class="memitem:a5b7e7a7833eb7c1c80a665fd0f15f0af"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a5b7e7a7833eb7c1c80a665fd0f15f0af">dispatchMsgTypeCountStaticBinSearch</a> (TId &amp;&amp;id)</td></tr>
<tr class="memdesc:a5b7e7a7833eb7c1c80a665fd0f15f0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of message types in the provided tuple that have the requested numeric ID.  <a href="namespacecomms.html#a5b7e7a7833eb7c1c80a665fd0f15f0af">More...</a><br /></td></tr>
<tr class="separator:a5b7e7a7833eb7c1c80a665fd0f15f0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba1e1002f4c6c0868d4d13c2f427bc2"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages &gt; </td></tr>
<tr class="memitem:a7ba1e1002f4c6c0868d4d13c2f427bc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a7ba1e1002f4c6c0868d4d13c2f427bc2">dispatchMsgTypeIsPolymorphic</a> ()</td></tr>
<tr class="memdesc:a7ba1e1002f4c6c0868d4d13c2f427bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> will use "polymorphic" dispatch for provided tuple of messages.  <a href="namespacecomms.html#a7ba1e1002f4c6c0868d4d13c2f427bc2">More...</a><br /></td></tr>
<tr class="separator:a7ba1e1002f4c6c0868d4d13c2f427bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219e19e1a89e42dfbaf2f7769b32dfa"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages &gt; </td></tr>
<tr class="memitem:a9219e19e1a89e42dfbaf2f7769b32dfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a9219e19e1a89e42dfbaf2f7769b32dfa">dispatchMsgTypeIsStaticBinSearch</a> ()</td></tr>
<tr class="memdesc:a9219e19e1a89e42dfbaf2f7769b32dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check whether the <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> or <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> will use "static binary search" dispatch for provided tuple of messages.  <a href="namespacecomms.html#a9219e19e1a89e42dfbaf2f7769b32dfa">More...</a><br /></td></tr>
<tr class="separator:a9219e19e1a89e42dfbaf2f7769b32dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fe9edcfc8a3ce5d43801e59d71655a"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:a86fe9edcfc8a3ce5d43801e59d71655a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a86fe9edcfc8a3ce5d43801e59d71655a">dispatchMsgTypeLinearSwitch</a> (TId &amp;&amp;id, std::size_t index, THandler &amp;handler)</td></tr>
<tr class="memdesc:a86fe9edcfc8a3ce5d43801e59d71655a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using linear switch behavior.  <a href="namespacecomms.html#a86fe9edcfc8a3ce5d43801e59d71655a">More...</a><br /></td></tr>
<tr class="separator:a86fe9edcfc8a3ce5d43801e59d71655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca49c981c039de029515c9f7398cef4"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:a5ca49c981c039de029515c9f7398cef4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a5ca49c981c039de029515c9f7398cef4">dispatchMsgTypeLinearSwitch</a> (TId &amp;&amp;id, THandler &amp;handler)</td></tr>
<tr class="memdesc:a5ca49c981c039de029515c9f7398cef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using linear switch behavior.  <a href="namespacecomms.html#a5ca49c981c039de029515c9f7398cef4">More...</a><br /></td></tr>
<tr class="separator:a5ca49c981c039de029515c9f7398cef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccf6f0995d1938053b47e420b4b7397"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:abccf6f0995d1938053b47e420b4b7397"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#abccf6f0995d1938053b47e420b4b7397">dispatchMsgTypePolymorphic</a> (TId &amp;&amp;id, std::size_t index, THandler &amp;handler)</td></tr>
<tr class="memdesc:abccf6f0995d1938053b47e420b4b7397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior.  <a href="namespacecomms.html#abccf6f0995d1938053b47e420b4b7397">More...</a><br /></td></tr>
<tr class="separator:abccf6f0995d1938053b47e420b4b7397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f40a3a8b3c14678fa6335a36539b03"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:a59f40a3a8b3c14678fa6335a36539b03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a59f40a3a8b3c14678fa6335a36539b03">dispatchMsgTypePolymorphic</a> (TId &amp;&amp;id, THandler &amp;handler)</td></tr>
<tr class="memdesc:a59f40a3a8b3c14678fa6335a36539b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior.  <a href="namespacecomms.html#a59f40a3a8b3c14678fa6335a36539b03">More...</a><br /></td></tr>
<tr class="separator:a59f40a3a8b3c14678fa6335a36539b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7396f73d035672becc696d9147163aae"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:a7396f73d035672becc696d9147163aae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a7396f73d035672becc696d9147163aae">dispatchMsgTypeStaticBinSearch</a> (TId &amp;&amp;id, std::size_t index, THandler &amp;handler)</td></tr>
<tr class="memdesc:a7396f73d035672becc696d9147163aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using static binary search behavior.  <a href="namespacecomms.html#a7396f73d035672becc696d9147163aae">More...</a><br /></td></tr>
<tr class="separator:a7396f73d035672becc696d9147163aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051115c21a00a6502177712cf2e63cb"><td class="memTemplParams" colspan="2">template&lt;typename TAllMessages , typename TId , typename THandler &gt; </td></tr>
<tr class="memitem:af051115c21a00a6502177712cf2e63cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#af051115c21a00a6502177712cf2e63cb">dispatchMsgTypeStaticBinSearch</a> (TId &amp;&amp;id, THandler &amp;handler)</td></tr>
<tr class="memdesc:af051115c21a00a6502177712cf2e63cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch message id into appropriate <b>handle()</b> function in the provided handler using static binary search behavior.  <a href="namespacecomms.html#af051115c21a00a6502177712cf2e63cb">More...</a><br /></td></tr>
<tr class="separator:af051115c21a00a6502177712cf2e63cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503a7696e8a2d355614c52f5f01db177"><td class="memTemplParams" colspan="2">template&lt;typename TFieldTo , typename TFieldFrom &gt; </td></tr>
<tr class="memitem:a503a7696e8a2d355614c52f5f01db177"><td class="memTemplItemLeft" align="right" valign="top">TFieldTo&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a503a7696e8a2d355614c52f5f01db177">field_cast</a> (const TFieldFrom &amp;field)</td></tr>
<tr class="memdesc:a503a7696e8a2d355614c52f5f01db177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast between fields.  <a href="namespacecomms.html#a503a7696e8a2d355614c52f5f01db177">More...</a><br /></td></tr>
<tr class="separator:a503a7696e8a2d355614c52f5f01db177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed34619c9153ce1e4f5243e63825cb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed34619c9153ce1e4f5243e63825cb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3ed34619c9153ce1e4f5243e63825cb6">isMessage</a> ()</td></tr>
<tr class="memdesc:a3ed34619c9153ce1e4f5243e63825cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of of whether the type is a message.  <a href="namespacecomms.html#a3ed34619c9153ce1e4f5243e63825cb6">More...</a><br /></td></tr>
<tr class="separator:a3ed34619c9153ce1e4f5243e63825cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade869d4b71e53aca05174f25be60257d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade869d4b71e53aca05174f25be60257d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ade869d4b71e53aca05174f25be60257d">isMessageBase</a> ()</td></tr>
<tr class="memdesc:ade869d4b71e53aca05174f25be60257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check of of whether the type is a message extending <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>.  <a href="namespacecomms.html#ade869d4b71e53aca05174f25be60257d">More...</a><br /></td></tr>
<tr class="separator:ade869d4b71e53aca05174f25be60257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad268bb091d752a4c557374f65e4f44"><td class="memTemplParams" colspan="2">template&lt;typename TBufIter , typename TFrame , typename THandler , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a1ad268bb091d752a4c557374f65e4f44"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">processAllWithDispatch</a> (TBufIter bufIter, std::size_t len, TFrame &amp;&amp;frame, THandler &amp;handler)</td></tr>
<tr class="memdesc:a1ad268bb091d752a4c557374f65e4f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all available input and dispatch all created message objects to appropriate handling function.  <a href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">More...</a><br /></td></tr>
<tr class="separator:a1ad268bb091d752a4c557374f65e4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a09c4ded3af5eae3c39fa4926478bb"><td class="memTemplParams" colspan="2">template&lt;typename TDispatcher , typename TBufIter , typename TFrame , typename THandler , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:ab5a09c4ded3af5eae3c39fa4926478bb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">processAllWithDispatchViaDispatcher</a> (TBufIter bufIter, std::size_t len, TFrame &amp;&amp;frame, THandler &amp;handler)</td></tr>
<tr class="memdesc:ab5a09c4ded3af5eae3c39fa4926478bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all available input and dispatch all created message objects to appropriate handling function.  <a href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">More...</a><br /></td></tr>
<tr class="separator:ab5a09c4ded3af5eae3c39fa4926478bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df361b68b43438d84c63c70f5fce161"><td class="memTemplParams" colspan="2">template&lt;typename TBufIter , typename TFrame , typename TMsg , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a4df361b68b43438d84c63c70f5fce161"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">processSingle</a> (TBufIter &amp;bufIter, std::size_t len, TFrame &amp;&amp;frame, TMsg &amp;msg, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a4df361b68b43438d84c63c70f5fce161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process input until first message is recognized and its object is created or missing data is reported.  <a href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">More...</a><br /></td></tr>
<tr class="separator:a4df361b68b43438d84c63c70f5fce161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6192c4f27a8a642677487c3fd9c56768"><td class="memTemplParams" colspan="2">template&lt;typename TBufIter , typename TFrame , typename TMsg , typename THandler , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a6192c4f27a8a642677487c3fd9c56768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">processSingleWithDispatch</a> (TBufIter &amp;bufIter, std::size_t len, TFrame &amp;&amp;frame, TMsg &amp;msg, THandler &amp;handler, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a6192c4f27a8a642677487c3fd9c56768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process input until first message is recognized, its object is created and dispatched to appropriate handling function, or missing data is reported.  <a href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">More...</a><br /></td></tr>
<tr class="separator:a6192c4f27a8a642677487c3fd9c56768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7088de229a0103c1de50a2a1deebad45"><td class="memTemplParams" colspan="2">template&lt;typename TDispatcher , typename TBufIter , typename TFrame , typename TMsg , typename THandler , typename... TExtraValues&gt; </td></tr>
<tr class="memitem:a7088de229a0103c1de50a2a1deebad45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">processSingleWithDispatchViaDispatcher</a> (TBufIter &amp;bufIter, std::size_t len, TFrame &amp;&amp;frame, TMsg &amp;msg, THandler &amp;handler, TExtraValues... extraValues)</td></tr>
<tr class="memdesc:a7088de229a0103c1de50a2a1deebad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process input until first message is recognized, its object is created and dispatched to appropriate handling function, or missing data is reported.  <a href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">More...</a><br /></td></tr>
<tr class="separator:a7088de229a0103c1de50a2a1deebad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe9279fa541d5bd8d91368a65dc8e52"><td class="memTemplParams" colspan="2">template&lt;typename TMessage , typename TIter &gt; </td></tr>
<tr class="memitem:a3fe9279fa541d5bd8d91368a65dc8e52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3fe9279fa541d5bd8d91368a65dc8e52">readIteratorFor</a> (TIter &amp;&amp;iter) -&gt; decltype(details::ReadIteratorHelper&lt;&gt;::template get&lt; TMessage &gt;(std::forward&lt; TIter &gt;(iter)))</td></tr>
<tr class="memdesc:a3fe9279fa541d5bd8d91368a65dc8e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise iterator for message read.  <a href="namespacecomms.html#a3fe9279fa541d5bd8d91368a65dc8e52">More...</a><br /></td></tr>
<tr class="separator:a3fe9279fa541d5bd8d91368a65dc8e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d878e6b08584d5fb215f20ecae0681"><td class="memTemplParams" colspan="2">template&lt;typename TMessage , typename TIter &gt; </td></tr>
<tr class="memitem:a68d878e6b08584d5fb215f20ecae0681"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a68d878e6b08584d5fb215f20ecae0681">readIteratorFor</a> (TMessage &amp;&amp;msg, TIter &amp;&amp;iter) -&gt; decltype(details::ReadIteratorHelper&lt;&gt;::template get&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;(std::forward&lt; TIter &gt;(iter)))</td></tr>
<tr class="memdesc:a68d878e6b08584d5fb215f20ecae0681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise iterator for message read.  <a href="namespacecomms.html#a68d878e6b08584d5fb215f20ecae0681">More...</a><br /></td></tr>
<tr class="separator:a68d878e6b08584d5fb215f20ecae0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936712101e22038d5d20b4e4a7321635"><td class="memTemplParams" colspan="2"><a id="a936712101e22038d5d20b4e4a7321635"></a>
template&lt;typename... TOptions&gt; </td></tr>
<tr class="memitem:a936712101e22038d5d20b4e4a7321635"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1Message.html">Message</a>&lt; TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a936712101e22038d5d20b4e4a7321635">toMessage</a> (const <a class="el" href="classcomms_1_1Message.html">Message</a>&lt; TOptions... &gt; &amp;msg)</td></tr>
<tr class="memdesc:a936712101e22038d5d20b4e4a7321635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the message object to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a936712101e22038d5d20b4e4a7321635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfdaf9bcb9780874bac5b1f69601f6d"><td class="memTemplParams" colspan="2"><a id="a6cfdaf9bcb9780874bac5b1f69601f6d"></a>
template&lt;typename... TOptions&gt; </td></tr>
<tr class="memitem:a6cfdaf9bcb9780874bac5b1f69601f6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1Message.html">Message</a>&lt; TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a6cfdaf9bcb9780874bac5b1f69601f6d">toMessage</a> (<a class="el" href="classcomms_1_1Message.html">Message</a>&lt; TOptions... &gt; &amp;msg)</td></tr>
<tr class="memdesc:a6cfdaf9bcb9780874bac5b1f69601f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the message object to <a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">comms::Message</a> in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a6cfdaf9bcb9780874bac5b1f69601f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea8a0b2514bdb531153ae127b419e3a"><td class="memTemplParams" colspan="2"><a id="a3ea8a0b2514bdb531153ae127b419e3a"></a>
template&lt;typename TMessage , typename... TOptions&gt; </td></tr>
<tr class="memitem:a3ea8a0b2514bdb531153ae127b419e3a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3ea8a0b2514bdb531153ae127b419e3a">toMessageBase</a> (const <a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage, TOptions... &gt; &amp;msg)</td></tr>
<tr class="memdesc:a3ea8a0b2514bdb531153ae127b419e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the message object to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a3ea8a0b2514bdb531153ae127b419e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13fefc26f742c9d1b8715264a116de"><td class="memTemplParams" colspan="2"><a id="a0f13fefc26f742c9d1b8715264a116de"></a>
template&lt;typename TMessage , typename... TOptions&gt; </td></tr>
<tr class="memitem:a0f13fefc26f742c9d1b8715264a116de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">toMessageBase</a> (<a class="el" href="classcomms_1_1MessageBase.html">MessageBase</a>&lt; TMessage, TOptions... &gt; &amp;msg)</td></tr>
<tr class="memdesc:a0f13fefc26f742c9d1b8715264a116de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast type of the message object to <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a0f13fefc26f742c9d1b8715264a116de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124576497d233cf87eb7432190e6c9fe"><td class="memItemLeft" align="right" valign="top"><a id="a124576497d233cf87eb7432190e6c9fe"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a> ()</td></tr>
<tr class="memdesc:a124576497d233cf87eb7432190e6c9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of the COMMS library as single numeric value. <br /></td></tr>
<tr class="separator:a124576497d233cf87eb7432190e6c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289f4cb60bfb6781538e79462b133f98"><td class="memItemLeft" align="right" valign="top"><a id="a289f4cb60bfb6781538e79462b133f98"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a289f4cb60bfb6781538e79462b133f98">versionCreate</a> (unsigned major, unsigned minor, unsigned patch)</td></tr>
<tr class="memdesc:a289f4cb60bfb6781538e79462b133f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create version of the library as single unsigned numeric value. <br /></td></tr>
<tr class="separator:a289f4cb60bfb6781538e79462b133f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c46adb9a926d1dae36796268639c1f"><td class="memItemLeft" align="right" valign="top"><a id="ae5c46adb9a926d1dae36796268639c1f"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#ae5c46adb9a926d1dae36796268639c1f">versionMajor</a> ()</td></tr>
<tr class="memdesc:ae5c46adb9a926d1dae36796268639c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major verion of the library. <br /></td></tr>
<tr class="separator:ae5c46adb9a926d1dae36796268639c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e2acb4409bee277668d0595034413"><td class="memItemLeft" align="right" valign="top"><a id="a2e5e2acb4409bee277668d0595034413"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a2e5e2acb4409bee277668d0595034413">versionMinor</a> ()</td></tr>
<tr class="memdesc:a2e5e2acb4409bee277668d0595034413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minor verion of the library. <br /></td></tr>
<tr class="separator:a2e5e2acb4409bee277668d0595034413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674340e07c24316d07df6a3a19e8f9de"><td class="memItemLeft" align="right" valign="top"><a id="a674340e07c24316d07df6a3a19e8f9de"></a>
constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a674340e07c24316d07df6a3a19e8f9de">versionPatch</a> ()</td></tr>
<tr class="memdesc:a674340e07c24316d07df6a3a19e8f9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch level of the library. <br /></td></tr>
<tr class="separator:a674340e07c24316d07df6a3a19e8f9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9bde48100a84b880ef17d4ad02076b"><td class="memTemplParams" colspan="2">template&lt;typename TMessage , typename TIter &gt; </td></tr>
<tr class="memitem:abc9bde48100a84b880ef17d4ad02076b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#abc9bde48100a84b880ef17d4ad02076b">writeIteratorFor</a> (TIter &amp;&amp;iter) -&gt; decltype(details::WriteIteratorHelper&lt;&gt;::template get&lt; TMessage &gt;(std::forward&lt; TIter &gt;(iter)))</td></tr>
<tr class="memdesc:abc9bde48100a84b880ef17d4ad02076b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise iterator for message write.  <a href="namespacecomms.html#abc9bde48100a84b880ef17d4ad02076b">More...</a><br /></td></tr>
<tr class="separator:abc9bde48100a84b880ef17d4ad02076b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983c2d4181f7c74d2cab5a3d1405db3"><td class="memTemplParams" colspan="2">template&lt;typename TMessage , typename TIter &gt; </td></tr>
<tr class="memitem:a3983c2d4181f7c74d2cab5a3d1405db3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms.html#a3983c2d4181f7c74d2cab5a3d1405db3">writeIteratorFor</a> (TMessage &amp;&amp;msg, TIter &amp;&amp;iter) -&gt; decltype(details::WriteIteratorHelper&lt;&gt;::template get&lt; typename std::decay&lt; decltype(msg)&gt;::type &gt;(std::forward&lt; TIter &gt;(iter)))</td></tr>
<tr class="memdesc:a3983c2d4181f7c74d2cab5a3d1405db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise iterator for message write.  <a href="namespacecomms.html#a3983c2d4181f7c74d2cab5a3d1405db3">More...</a><br /></td></tr>
<tr class="separator:a3983c2d4181f7c74d2cab5a3d1405db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7f9725d68be4564134834976fc83ba20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9725d68be4564134834976fc83ba20">&#9670;&nbsp;</a></span>GenericMessageFields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldBase , typename TExtraOpts  = comms::option::app::EmptyOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecomms.html#a7f9725d68be4564134834976fc83ba20">comms::GenericMessageFields</a> = typedef std::tuple&lt; <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt; TFieldBase, std::uint8_t, TExtraOpts &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of fields for <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> message. </p>
<p>Defined as single variable length raw bytes sequence (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Base</td><td>class for the sequence field definition, expected to be a variant of <a class="el" href="classcomms_1_1Field.html">comms::Field</a> </td></tr>
    <tr><td class="paramname">Extra</td><td>option(s) (bundled as <b>std::tuple</b> if multiple) to be passed to <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> field definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4df982066e6271a25217d483f6034b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4df982066e6271a25217d483f6034b">&#9670;&nbsp;</a></span>MessageIdType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsg , typename TDefaultType  = std::intmax_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecomms.html#a6e4df982066e6271a25217d483f6034b">comms::MessageIdType</a> = typedef typename comms::util::LazyDeepConditional&lt; TMsg::InterfaceOptions::HasMsgIdType &gt;::template Type&lt; comms::details::MessageIdTypeRetriever, comms::util::AliasType, TDefaultType, TMsg &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of message ID used by interface class. </p>
<p>In case common interface class defines its message ID type (using <a class="el" href="namespacecomms_1_1option.html#ae116d8be9449c27165351b3f07151284">comms::option::MsgIdType</a> option) the latter is returned, otherwise the default type (<b>TDefaultType</b>) is reported. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> interface class (extended or typedef-ed <a class="el" href="classcomms_1_1Message.html">comms::Message</a>) </td></tr>
    <tr><td class="paramname">TDefaultType</td><td>Default type to return in case message interface class doesn't define its ID type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0a259a03d68bce98b4a129fb34aaa2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a259a03d68bce98b4a129fb34aaa2e1">&#9670;&nbsp;</a></span>ErrorStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error statuses reported by the Communication module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38"></a>Success&#160;</td><td class="fielddoc"><p>Used to indicate successful outcome of the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d"></a>UpdateRequired&#160;</td><td class="fielddoc"><p>Used to indicate that write operation wasn't complete, call to update(...) is required. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac"></a>NotEnoughData&#160;</td><td class="fielddoc"><p>Used to indicate that stream buffer didn't contain enough data to complete read operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1aca3da8f495e4e628912a7798655da6c2"></a>ProtocolError&#160;</td><td class="fielddoc"><p>Used to indicate that any of the used protocols encountered an error while processing the data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a68ec6e62c5fcbbb68b5ce093bdd60717"></a>BufferOverflow&#160;</td><td class="fielddoc"><p>Used to indicate that stream buffer was overflowed when attempting to write data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab"></a>InvalidMsgId&#160;</td><td class="fielddoc"><p>Used to indicate that received message has unknown id. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1af8ae6974f1ae12f9dd119049c9c47ebb"></a>InvalidMsgData&#160;</td><td class="fielddoc"><p>Used to indicate that a message has invalid data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a37b538d9e3266acd66229ede1dcceb70"></a>MsgAllocFailure&#160;</td><td class="fielddoc"><p>Used to indicate that message allocation has failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb"></a>NotSupported&#160;</td><td class="fielddoc"><p>The operation is not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0a259a03d68bce98b4a129fb34aaa2e1a87f1cfab47938d0234207590e51f2959"></a>NumOfErrorStatuses&#160;</td><td class="fielddoc"><p>Number of supported error statuses, must be last. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5b8201618df7a2022eb502b194826a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8201618df7a2022eb502b194826a4e">&#9670;&nbsp;</a></span>cast_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">details::ValueAssignWrapper&lt;T&gt; comms::cast_assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to assign value with static_cast to appropriate type. </p>
<p>Can be used to assign any value, including value of a field. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> someValue = ...;</div>
<div class="line"><a class="code" href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign</a>(field.value()) = someValue; <span class="comment">// Sets field&#39;s value with appropriate static_cast.</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Defined in "comms/cast.h" headerfile </dd></dl>

</div>
</div>
<a id="a157c91f0dbf389c13f01975886124916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157c91f0dbf389c13f01975886124916">&#9670;&nbsp;</a></span>dispatchMsg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior. </p>
<p>The function performs compile time evaluation of the provided <b>TAllMessages</b> tuple and uses logic described in <a class="el" href="page_dispatch.html#page_dispatch_message_object_default">Default Way to Dispatch</a> to choose the way to dispatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a>; </dd></dl>

</div>
</div>
<a id="a2452362a2fe3788e868e4f40e54cf102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2452362a2fe3788e868e4f40e54cf102">&#9670;&nbsp;</a></span>dispatchMsg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsg </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior. </p>
<p>The function performs compile time evaluation of the provided <b>TAllMessages</b> tuple and uses logic described in <a class="el" href="page_dispatch.html#page_dispatch_message_object_default">Default Way to Dispatch</a> to choose the way to dispatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a>; </dd></dl>

</div>
</div>
<a id="afa1fdd50cb9a0cc15c108dfba57a23a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1fdd50cb9a0cc15c108dfba57a23a4">&#9670;&nbsp;</a></span>dispatchMsg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsg </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior. </p>
<p>The function performs compile time evaluation of the provided <b>TAllMessages</b> tuple and uses logic described in <a class="el" href="page_dispatch.html#page_dispatch_message_object_default">Default Way to Dispatch</a> to choose the way to dispatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a>; </dd></dl>

</div>
</div>
<a id="a0c2c64f47246460f460f2b7c7d3031df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2c64f47246460f460f2b7c7d3031df">&#9670;&nbsp;</a></span>dispatchMsgIsDirect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check whether the message object can use its own polymorphic <b>dispatch()</b> (see <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>) when <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> is invoked. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMsg</td><td>Type of the message interface. </td></tr>
    <tr><td class="paramname">THandler</td><td>Type of the message handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a5e8c9c182e141da40135598e5f54ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c9c182e141da40135598e5f54ccfb">&#9670;&nbsp;</a></span>dispatchMsgIsDirect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsDirect </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to other <a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a>, but can help in deducing template arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Reference to the message object via its interface class. </td></tr>
    <tr><td class="paramname">handler</td><td>Reference to the handler object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The result can be evaluated at compile time, but compilers don't support usage of this form in static_assert. </dd>
<dd>
Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a0616720714175c82e10a6725d62393a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0616720714175c82e10a6725d62393a5">&#9670;&nbsp;</a></span>dispatchMsgIsPolymorphic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsPolymorphic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check whether the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> will use "polymorphic" (including "direct") dispatch for provided tuple of messages and handler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the common message interface. </td></tr>
    <tr><td class="paramname">THandler</td><td>Type of the handler being used for dispatch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Will return <b>true</b> in case <a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a> returns true; </dd>
<dd>
Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a3a4130b5e308065717b8d71356fbd91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4130b5e308065717b8d71356fbd91f">&#9670;&nbsp;</a></span>dispatchMsgIsPolymorphic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsPolymorphic </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to other <a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">dispatchMsgIsPolymorphic()</a>, but can help in deducing template arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Reference to the message object via its interface class. </td></tr>
    <tr><td class="paramname">handler</td><td>Reference to the handler object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The result can be evaluated at compile time, but compilers don't support usage of this form in static_assert. </dd>
<dd>
Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a61c7f05f508ffaa6e3de6c7249c7f607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c7f05f508ffaa6e3de6c7249c7f607">&#9670;&nbsp;</a></span>dispatchMsgIsStaticBinSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsStaticBinSearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check whether the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">dispatchMsg()</a> will use "static binary search" dispatch for provided tuple of messages and handler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
    <tr><td class="paramname">TMsg</td><td>Type of the common message interface. </td></tr>
    <tr><td class="paramname">THandler</td><td>Type of the handler being used for dispatch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Will return <b>false</b> in case <a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a> returns true; </dd>
<dd>
Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ac60741f830029beea5c6e38ef741b073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60741f830029beea5c6e38ef741b073">&#9670;&nbsp;</a></span>dispatchMsgIsStaticBinSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgIsStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to other <a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">dispatchMsgIsStaticBinSearch()</a>, but can help in deducing template arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Reference to the message object via its interface class. </td></tr>
    <tr><td class="paramname">handler</td><td>Reference to the handler object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The result can be evaluated at compile time, but compilers don't support usage of this form in static_assert. </dd>
<dd>
Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a3f596641d4143e5fae65c5eea8f9a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f596641d4143e5fae65c5eea8f9a828">&#9670;&nbsp;</a></span>dispatchMsgLinearSwitch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgLinearSwitch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ad73708f2fe7ad6c62b9294106dd44fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73708f2fe7ad6c62b9294106dd44fe5">&#9670;&nbsp;</a></span>dispatchMsgLinearSwitch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgLinearSwitch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="af13cfefc96018a937a529e4e951033cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13cfefc96018a937a529e4e951033cb">&#9670;&nbsp;</a></span>dispatchMsgLinearSwitch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgLinearSwitch </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using linear switch behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ad16d04b7d414caf729daa52a710b74ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16d04b7d414caf729daa52a710b74ed">&#9670;&nbsp;</a></span>dispatchMsgPolymorphic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgPolymorphic </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ad0286f72522d7804868bb551505a08e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0286f72522d7804868bb551505a08e1">&#9670;&nbsp;</a></span>dispatchMsgPolymorphic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgPolymorphic </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ab7e57563068fbb504b49e5ad9835a692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e57563068fbb504b49e5ad9835a692">&#9670;&nbsp;</a></span>dispatchMsgPolymorphic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgPolymorphic </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a31149d8672043acec9acc15cb8072af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31149d8672043acec9acc15cb8072af9">&#9670;&nbsp;</a></span>dispatchMsgStaticBinSearch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="aa770bd45a42589ce57a2263c48e89b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa770bd45a42589ce57a2263c48e89b48">&#9670;&nbsp;</a></span>dispatchMsgStaticBinSearch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ac3c95eaab170e35647ca537cd13f4d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c95eaab170e35647ca537cd13f4d83">&#9670;&nbsp;</a></span>dispatchMsgStaticBinSearch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TMsg , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::dispatchMsgStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; details::MessageInterfaceDispatchRetType&lt;
        typename std::decay&lt;decltype(handler)&gt;::type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message object into appropriate <b>handle()</b> function in the provided handler using static binary search behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> object held by reference to its interface class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>What the called <b>handle()</b> member function of handler object returns. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="ab1de1104c31ee7b06c782dd84c9746e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1de1104c31ee7b06c782dd84c9746e9">&#9670;&nbsp;</a></span>dispatchMsgType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgType </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior. </p>
<p>The function performs compile time evaluation of the provided <b>TAllMessages</b> tuple and uses logic described in <a class="el" href="page_dispatch.html#page_dispatch_message_object_default">Default Way to Dispatch</a> to choose the way to dispatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a7ba1e1002f4c6c0868d4d13c2f427bc2">dispatchMsgTypeIsPolymorphic()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a9219e19e1a89e42dfbaf2f7769b32dfa">dispatchMsgTypeIsStaticBinSearch()</a> </dd></dl>

</div>
</div>
<a id="ae6afbd722340e3bf0d18054bdab484cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6afbd722340e3bf0d18054bdab484cd">&#9670;&nbsp;</a></span>dispatchMsgType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgType </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using either "polymorphic" or "static binary search" behavior. </p>
<p>The function performs compile time evaluation of the provided <b>TAllMessages</b> tuple and uses logic described in <a class="el" href="page_dispatch.html#page_dispatch_message_object_default">Default Way to Dispatch</a> to choose the way to dispatch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a7ba1e1002f4c6c0868d4d13c2f427bc2">dispatchMsgTypeIsPolymorphic()</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#a9219e19e1a89e42dfbaf2f7769b32dfa">dispatchMsgTypeIsStaticBinSearch()</a> </dd></dl>

</div>
</div>
<a id="a5b7e7a7833eb7c1c80a665fd0f15f0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7e7a7833eb7c1c80a665fd0f15f0af">&#9670;&nbsp;</a></span>dispatchMsgTypeCountStaticBinSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t comms::dispatchMsgTypeCountStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of message types in the provided tuple that have the requested numeric ID. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a7ba1e1002f4c6c0868d4d13c2f427bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba1e1002f4c6c0868d4d13c2f427bc2">&#9670;&nbsp;</a></span>dispatchMsgTypeIsPolymorphic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgTypeIsPolymorphic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check whether the <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> will use "polymorphic" dispatch for provided tuple of messages. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a9219e19e1a89e42dfbaf2f7769b32dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219e19e1a89e42dfbaf2f7769b32dfa">&#9670;&nbsp;</a></span>dispatchMsgTypeIsStaticBinSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::dispatchMsgTypeIsStaticBinSearch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check whether the <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> or <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">dispatchMsgType()</a> will use "static binary search" dispatch for provided tuple of messages. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a86fe9edcfc8a3ce5d43801e59d71655a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fe9edcfc8a3ce5d43801e59d71655a">&#9670;&nbsp;</a></span>dispatchMsgTypeLinearSwitch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypeLinearSwitch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using linear switch behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a5ca49c981c039de029515c9f7398cef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca49c981c039de029515c9f7398cef4">&#9670;&nbsp;</a></span>dispatchMsgTypeLinearSwitch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypeLinearSwitch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using linear switch behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="abccf6f0995d1938053b47e420b4b7397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccf6f0995d1938053b47e420b4b7397">&#9670;&nbsp;</a></span>dispatchMsgTypePolymorphic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypePolymorphic </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a59f40a3a8b3c14678fa6335a36539b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f40a3a8b3c14678fa6335a36539b03">&#9670;&nbsp;</a></span>dispatchMsgTypePolymorphic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypePolymorphic </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using polymorphic behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a7396f73d035672becc696d9147163aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7396f73d035672becc696d9147163aae">&#9670;&nbsp;</a></span>dispatchMsgTypeStaticBinSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypeStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using static binary search behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index (or offset) of the message type among those having the same ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="af051115c21a00a6502177712cf2e63cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af051115c21a00a6502177712cf2e63cb">&#9670;&nbsp;</a></span>dispatchMsgTypeStaticBinSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAllMessages , typename TId , typename THandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool comms::dispatchMsgTypeStaticBinSearch </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch message id into appropriate <b>handle()</b> function in the provided handler using static binary search behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TAllMessages</td><td><b>std::tuple</b> of supported message classes, sorted in ascending order by their numeric IDs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the message known at runtime. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler object, it's required public interface is explained in <a class="el" href="page_dispatch.html#page_dispatch_message_type">Dispatch of the Message Type</a> section of the <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> tutorial page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> in case the appropriate <b>handle()</b> member function of the handler object has been called, <b>false</b> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="dispatch_8h.html">comms/dispatch.h</a> </dd></dl>

</div>
</div>
<a id="a503a7696e8a2d355614c52f5f01db177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503a7696e8a2d355614c52f5f01db177">&#9670;&nbsp;</a></span>field_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFieldTo , typename TFieldFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFieldTo comms::field_cast </td>
          <td>(</td>
          <td class="paramtype">const TFieldFrom &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast between fields. </p>
<p>Sometimes the protocol may treat some specific field differently based on indication bit in some other field. This function can be used to cast one field to another type. </p><div class="fragment"><div class="line">SomeFieldType someField = comms::field_cast&lt;SomeFieldType&gt;(someOtherField);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFieldTo</td><td>Type to cast to. </td></tr>
    <tr><td class="paramname">TFieldFrom</td><td>Type to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>Original field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes.">Field</a> of the new type with internal value equivalent to one of the original field. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in "comms/cast.h" headerfile </dd></dl>

</div>
</div>
<a id="a3ed34619c9153ce1e4f5243e63825cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed34619c9153ce1e4f5243e63825cb6">&#9670;&nbsp;</a></span>isMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::isMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check of of whether the type is a message. </p>
<p>Checks existence of <b>InterfaceOptions</b> inner type. </p>

</div>
</div>
<a id="ade869d4b71e53aca05174f25be60257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade869d4b71e53aca05174f25be60257d">&#9670;&nbsp;</a></span>isMessageBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool comms::isMessageBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile time check of of whether the type is a message extending <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. </p>
<p>Checks existence of <b>ImplOptions</b> inner type. </p>

</div>
</div>
<a id="a1ad268bb091d752a4c557374f65e4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad268bb091d752a4c557374f65e4f44">&#9670;&nbsp;</a></span>processAllWithDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TBufIter , typename TFrame , typename THandler , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t comms::processAllWithDispatch </td>
          <td>(</td>
          <td class="paramtype">TBufIter&#160;</td>
          <td class="paramname"><em>bufIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFrame &amp;&amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process all available input and dispatch all created message objects to appropriate handling function. </p>
<p>All the created message objects are immediatelly destructed after dispatching. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufIter</td><td>Iterator to input buffer. Passed by value and is <b>NOT</b> updated when buffer is iterated over (unlike <a class="el" href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">comms::processSingle()</a>, <a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a>, <a class="el" href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">comms::processSingleWithDispatchViaDispatcher()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of remaining bytes in input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Protocol frame / stack (see <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) that is used to process the raw input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler to handle message object when dispatched. The dispatch is performed using <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of consumed bytes from the buffer. The caller is responsible to remove them from the buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="process_8h.html">comms/process.h</a> </dd>
<dd>
If default dispatch behaviour of the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> function doesn't suit the application needs, consider using <a class="el" href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">comms::processAllWithDispatchViaDispatcher()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">comms::processAllWithDispatchViaDispatcher()</a>. </dd>
<dd>
<a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a> </dd></dl>

</div>
</div>
<a id="ab5a09c4ded3af5eae3c39fa4926478bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a09c4ded3af5eae3c39fa4926478bb">&#9670;&nbsp;</a></span>processAllWithDispatchViaDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDispatcher , typename TBufIter , typename TFrame , typename THandler , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t comms::processAllWithDispatchViaDispatcher </td>
          <td>(</td>
          <td class="paramtype">TBufIter&#160;</td>
          <td class="paramname"><em>bufIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFrame &amp;&amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process all available input and dispatch all created message objects to appropriate handling function. </p>
<p>Similar to <a class="el" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch()</a>, but allows forcing a particular dispatch policy. All the created message objects are immediatelly destructed after dispatching. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDispatcher</td><td>A variant of <a class="el" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a> class. It's going to be used to dispatch message object into appropriate handling function instead of using <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> like <a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a> does. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufIter</td><td>Iterator to input buffer. Passed by value and is <b>NOT</b> updated when buffer is iterated over (unlike <a class="el" href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">comms::processSingle()</a>, <a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a>, <a class="el" href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">comms::processSingleWithDispatchViaDispatcher()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of remaining bytes in input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Protocol frame / stack (see <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) that is used to process the raw input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler to handle message object when dispatched. The dispatch is performed via provded <b>TDispatcher</b> class (see <a class="el" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of consumed bytes from the buffer. The caller is responsible to remove them from the buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="process_8h.html">comms/process.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch()</a>. </dd>
<dd>
<a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a> </dd></dl>

</div>
</div>
<a id="a4df361b68b43438d84c63c70f5fce161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df361b68b43438d84c63c70f5fce161">&#9670;&nbsp;</a></span>processSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TBufIter , typename TFrame , typename TMsg , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> comms::processSingle </td>
          <td>(</td>
          <td class="paramtype">TBufIter &amp;&#160;</td>
          <td class="paramname"><em>bufIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFrame &amp;&amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process input until first message is recognized and its object is created or missing data is reported. </p>
<p>Can be used to implement <a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufIter</td><td>Iterator to input buffer. Passed by reference and is updated when buffer is iterated over. Number of consumed bytes cat be determined by calculating the distance between originally passed value and the one after function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of remaining bytes in input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Protocol frame / stack (see <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) that is used to process the raw input. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Smart pointer (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> defintion of the <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) to message object to be allocated, or reference to actual message object (extending <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>) when such is known. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">extraValues</td><td>Extra values that are passed as variadic parameters to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function of the protocol frame / stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ErrorStatus of the protocol frame / stack <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="process_8h.html">comms/process.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd></dl>

</div>
</div>
<a id="a6192c4f27a8a642677487c3fd9c56768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6192c4f27a8a642677487c3fd9c56768">&#9670;&nbsp;</a></span>processSingleWithDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TBufIter , typename TFrame , typename TMsg , typename THandler , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> comms::processSingleWithDispatch </td>
          <td>(</td>
          <td class="paramtype">TBufIter &amp;&#160;</td>
          <td class="paramname"><em>bufIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFrame &amp;&amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process input until first message is recognized, its object is created and dispatched to appropriate handling function, or missing data is reported. </p>
<p>Similar to <a class="el" href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">comms::processSingle()</a>, but adds dispatch stage. Can be used to implement <a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufIter</td><td>Iterator to input buffer. Passed by reference and is updated when buffer is iterated over. Number of consumed bytes cat be determined by calculating the distance between originally passed value and the one after function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of remaining bytes in input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Protocol frame / stack (see <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) that is used to process the raw input. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Smart pointer (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> defintion of the <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) to message object to be allocated, or reference to actual message object (extending <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>) when such is known. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler to handle message object when dispatched. The dispatch is performed using <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">extraValues</td><td>Extra values that are passed as variadic parameters to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function of the protocol frame / stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ErrorStatus of the protocol frame / stack <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="process_8h.html">comms/process.h</a> </dd>
<dd>
If default dispatch behaviour of the <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> function doesn't suit the application needs, consider using <a class="el" href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">comms::processSingleWithDispatchViaDispatcher()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd></dl>

</div>
</div>
<a id="a7088de229a0103c1de50a2a1deebad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7088de229a0103c1de50a2a1deebad45">&#9670;&nbsp;</a></span>processSingleWithDispatchViaDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDispatcher , typename TBufIter , typename TFrame , typename TMsg , typename THandler , typename... TExtraValues&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> comms::processSingleWithDispatchViaDispatcher </td>
          <td>(</td>
          <td class="paramtype">TBufIter &amp;&#160;</td>
          <td class="paramname"><em>bufIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFrame &amp;&amp;&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMsg &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler &amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExtraValues...&#160;</td>
          <td class="paramname"><em>extraValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process input until first message is recognized, its object is created and dispatched to appropriate handling function, or missing data is reported. </p>
<p>Similar to <a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a>, but allows forcing a particular dispatch policy. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TDispatcher</td><td>A variant of <a class="el" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a> class. It's going to be used to dispatch message object into appropriate handling function instead of using <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> like <a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a> does. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufIter</td><td>Iterator to input buffer. Passed by reference and is updated when buffer is iterated over. Number of consumed bytes cat be determined by calculating the distance between originally passed value and the one after function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of remaining bytes in input buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>Protocol frame / stack (see <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) that is used to process the raw input. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msg</td><td>Smart pointer (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> defintion of the <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>) to message object to be allocated, or reference to actual message object (extending <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>) when such is known. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Handler to handle message object when dispatched. The dispatch is performed via provded <b>TDispatcher</b> class (see <a class="el" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">extraValues</td><td>Extra values that are passed as variadic parameters to <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function of the protocol frame / stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ErrorStatus of the protocol frame / stack <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Defined in <a class="el" href="process_8h.html">comms/process.h</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a>. </dd>
<dd>
<a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> </dd>
<dd>
<a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a> </dd></dl>

</div>
</div>
<a id="a3fe9279fa541d5bd8d91368a65dc8e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe9279fa541d5bd8d91368a65dc8e52">&#9670;&nbsp;</a></span>readIteratorFor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::readIteratorFor </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> -&gt; decltype(details::ReadIteratorHelper&lt;&gt;::template get&lt;TMessage&gt;(std::forward&lt;TIter&gt;(iter)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise iterator for message read. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>Type of message interface class or smart pointer to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>Iterator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same <b>iter</b> value, but casted to appropriate type </dd></dl>

</div>
</div>
<a id="a68d878e6b08584d5fb215f20ecae0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d878e6b08584d5fb215f20ecae0681">&#9670;&nbsp;</a></span>readIteratorFor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::readIteratorFor </td>
          <td>(</td>
          <td class="paramtype">TMessage &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(details::ReadIteratorHelper&lt;&gt;::template get&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;(std::forward&lt;TIter&gt;(iter)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise iterator for message read. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>Type of message interface class or smart pointer to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Unused message object helps detecting proper message type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>Iterator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same <b>iter</b> value, but casted to appropriate type </dd></dl>

</div>
</div>
<a id="abc9bde48100a84b880ef17d4ad02076b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9bde48100a84b880ef17d4ad02076b">&#9670;&nbsp;</a></span>writeIteratorFor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::writeIteratorFor </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> -&gt; decltype(details::WriteIteratorHelper&lt;&gt;::template get&lt;TMessage&gt;(std::forward&lt;TIter&gt;(iter)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise iterator for message write. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>Type of message interface class or smart pointer to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>Iterator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same <b>iter</b> value, but casted to appropriate type </dd></dl>

</div>
</div>
<a id="a3983c2d4181f7c74d2cab5a3d1405db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983c2d4181f7c74d2cab5a3d1405db3">&#9670;&nbsp;</a></span>writeIteratorFor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMessage , typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto comms::writeIteratorFor </td>
          <td>(</td>
          <td class="paramtype">TMessage &amp;&amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIter &amp;&amp;&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(details::WriteIteratorHelper&lt;&gt;::template get&lt;typename std::decay&lt;decltype(msg)&gt;::type&gt;(std::forward&lt;TIter&gt;(iter)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise iterator for message write. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMessage</td><td>Type of message interface class or smart pointer to it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Unused message object helps detecting proper message type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter</td><td>Iterator value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same <b>iter</b> value, but casted to appropriate type </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecomms_html_a5b8201618df7a2022eb502b194826a4e"><div class="ttname"><a href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign</a></div><div class="ttdeci">details::ValueAssignWrapper&lt; T &gt; cast_assign(T &amp;value)</div><div class="ttdoc">Helper function to assign value with static_cast to appropriate type.</div><div class="ttdef"><b>Definition:</b> cast.h:29</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
