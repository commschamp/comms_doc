<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: comms::protocol Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecomms.html">comms</a></li><li class="navelem"><a class="el" href="namespacecomms_1_1protocol.html">protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">comms::protocol Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace that contains definition of layers that can be used to wrap message data with transport data.  
<a href="namespacecomms_1_1protocol.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace that contains definition of layers that can be used to wrap message data with transport data. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecomms_1_1protocol_1_1checksum"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol_1_1checksum.html">checksum</a></td></tr>
<tr class="memdesc:namespacecomms_1_1protocol_1_1checksum"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace that contains definition of checksum calculator classes which can be used with <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">comms::protocol::ChecksumLayer</a> transport layer class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html">ChecksumLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that is responsible to calculate checksum on the data written by all the wrapped internal layers and append it to the end of the written data. When reading, this layer is responsible to verify the checksum reported at the end of the read data.  <a href="classcomms_1_1protocol_1_1ChecksumLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">ChecksumPrefixLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that is responsible to calculate checksum on the data written by all the wrapped internal layers and prepend it before the written data. When reading, this layer is responsible to verify the checksum reported at the beginning of the read data.  <a href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">MsgDataLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> data layer.  <a href="classcomms_1_1protocol_1_1MsgDataLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">MsgIdLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by other (next) layers.  <a href="classcomms_1_1protocol_1_1MsgIdLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">MsgSizeLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that uses size field as a prefix to all the subsequent data written by other (next) layers.  <a href="classcomms_1_1protocol_1_1MsgSizeLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all the middle (non <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">MsgDataLayer</a>) protocol transport layers.  <a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html">SyncPrefixLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that uses "sync" field as a prefix to all the subsequent data written by other (next) layers.  <a href="classcomms_1_1protocol_1_1SyncPrefixLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">TransportValueLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol layer that reads a value from transport wrapping and reassigns it to appropriate "extra transport" data member of the created message object.  <a href="classcomms_1_1protocol_1_1TransportValueLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac267c873369aacc9a16b9b205d85246b"><td class="memItemLeft" align="right" valign="top">details::MissingSizeRetriever&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">missingSize</a> (std::size_t &amp;val)</td></tr>
<tr class="memdesc:ac267c873369aacc9a16b9b205d85246b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add "missing size" output parameter to protocol stack's (frame's) "read" operation.  <a href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">More...</a><br /></td></tr>
<tr class="separator:ac267c873369aacc9a16b9b205d85246b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb5a97bd086a5926c9101f467f8683"><td class="memTemplParams" colspan="2">template&lt;typename TId &gt; </td></tr>
<tr class="memitem:a4dfb5a97bd086a5926c9101f467f8683"><td class="memTemplItemLeft" align="right" valign="top">details::MsgIdRetriever&lt; TId &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a> (TId &amp;val)</td></tr>
<tr class="memdesc:a4dfb5a97bd086a5926c9101f467f8683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add "message ID" output parameter to protocol stack's (frame's) "read" operation.  <a href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">More...</a><br /></td></tr>
<tr class="separator:a4dfb5a97bd086a5926c9101f467f8683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5ef8b32dcb4f47fb149397c14897ae"><td class="memItemLeft" align="right" valign="top">details::MsgIndexRetriever&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a> (std::size_t &amp;val)</td></tr>
<tr class="memdesc:a8b5ef8b32dcb4f47fb149397c14897ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add "message index" output parameter to protocol stack's (frame's) "read" operation.  <a href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">More...</a><br /></td></tr>
<tr class="separator:a8b5ef8b32dcb4f47fb149397c14897ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85afb77abdbfda64916cc6e0d2cb521"><td class="memTemplParams" colspan="2">template&lt;typename TIter &gt; </td></tr>
<tr class="memitem:ae85afb77abdbfda64916cc6e0d2cb521"><td class="memTemplItemLeft" align="right" valign="top">details::MsgPayloadRetriever&lt; TIter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">msgPayload</a> (TIter &amp;iter, std::size_t &amp;len)</td></tr>
<tr class="memdesc:ae85afb77abdbfda64916cc6e0d2cb521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add "payload start" and "payload size" output parameters to protocol stack's (frame's) "read" operation.  <a href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">More...</a><br /></td></tr>
<tr class="separator:ae85afb77abdbfda64916cc6e0d2cb521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a9578cd823b835711af0b0ae51b3e9"><td class="memTemplParams" colspan="2"><a id="a46a9578cd823b835711af0b0ae51b3e9"></a>
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </td></tr>
<tr class="memitem:a46a9578cd823b835711af0b0ae51b3e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#a46a9578cd823b835711af0b0ae51b3e9">toProtocolLayerBase</a> (const <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions... &gt; &amp;layer)</td></tr>
<tr class="memdesc:a46a9578cd823b835711af0b0ae51b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast protocol layer in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a46a9578cd823b835711af0b0ae51b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a5b4747f728d5d98612943a9582048"><td class="memTemplParams" colspan="2"><a id="a91a5b4747f728d5d98612943a9582048"></a>
template&lt;typename TField , typename TNextLayer , typename TDerived , typename... TOptions&gt; </td></tr>
<tr class="memitem:a91a5b4747f728d5d98612943a9582048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecomms_1_1protocol.html#a91a5b4747f728d5d98612943a9582048">toProtocolLayerBase</a> (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">ProtocolLayerBase</a>&lt; TField, TNextLayer, TDerived, TOptions... &gt; &amp;layer)</td></tr>
<tr class="memdesc:a91a5b4747f728d5d98612943a9582048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upcast protocol layer in order to have access to its internal types. <br /></td></tr>
<tr class="separator:a91a5b4747f728d5d98612943a9582048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac267c873369aacc9a16b9b205d85246b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267c873369aacc9a16b9b205d85246b">&#9670;&nbsp;</a></span>missingSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">details::MissingSizeRetriever comms::protocol::missingSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add "missing size" output parameter to protocol stack's (frame's) "read" operation. </p>
<p>Can be passed as variadic parameters to "read" functions of protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a>). It can be used to retrieve missing length information in case "read" of protocol stack operation returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>. </p><div class="fragment"><div class="line"><span class="keyword">using</span> ProtocolStack = ...</div>
<div class="line">ProtocolStack stack;</div>
<div class="line">ProtocolStack::MsgPtr msg;</div>
<div class="line">std::size_t <a class="code" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">missingSize</a> = 0U;</div>
<div class="line"><span class="keyword">auto</span> es = stack.read(msg, readIter, size, <a class="code" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize</a>(<a class="code" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">missingSize</a>));</div>
<div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a>) {</div>
<div class="line">    ... <span class="comment">// missingSize will hold a minimal number of bytes that are required to be yet read</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>Missing size value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation dependent object accepted by "read" functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a> </dd></dl>

</div>
</div>
<a id="a4dfb5a97bd086a5926c9101f467f8683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfb5a97bd086a5926c9101f467f8683">&#9670;&nbsp;</a></span>msgId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TId &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">details::MsgIdRetriever&lt;TId&gt; comms::protocol::msgId </td>
          <td>(</td>
          <td class="paramtype">TId &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add "message ID" output parameter to protocol stack's (frame's) "read" operation. </p>
<p>Can be passed as variadic parameters to "read" functions of protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a>). It can be used to retrieve numeric message ID value. </p><div class="fragment"><div class="line"><span class="keyword">using</span> ProtocolStack = ...</div>
<div class="line">ProtocolStack stack;</div>
<div class="line">ProtocolStack::MsgPtr msg;</div>
<div class="line">my_prot::MsgId <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a> = my_prot::MsgId();</div>
<div class="line"><span class="keyword">auto</span> es = stack.read(msg, readIter, size, <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId</a>(<a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a>));</div>
<div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">    assert(msg); <span class="comment">// Message object must be created</span></div>
<div class="line">    ... <span class="comment">// use msgId value</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>Numeric message ID value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation dependent object accepted by "read" functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a> </dd></dl>

</div>
</div>
<a id="a8b5ef8b32dcb4f47fb149397c14897ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5ef8b32dcb4f47fb149397c14897ae">&#9670;&nbsp;</a></span>msgIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">details::MsgIndexRetriever comms::protocol::msgIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add "message index" output parameter to protocol stack's (frame's) "read" operation. </p>
<p>In case the expected input message types tuple contains multiple <b>different</b> message classes but having the <b>same</b> numeric ID, it may be beneficial to know the reletive index (starting from the first message type having the same ID) of the detected message. This function can be used to retrieve such information. Can be passed as variadic parameters to "read" functions of protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a>). </p><div class="fragment"><div class="line"><span class="keyword">using</span> ProtocolStack = ...</div>
<div class="line">ProtocolStack stack;</div>
<div class="line">ProtocolStack::MsgPtr msg;</div>
<div class="line">my_prot::MsgId <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a> = my_prot::MsgId();</div>
<div class="line">std::size_t <a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a> = 0U;</div>
<div class="line"><span class="keyword">auto</span> es =</div>
<div class="line">   stack.read(</div>
<div class="line">       msg,</div>
<div class="line">       readIter,</div>
<div class="line">       size,</div>
<div class="line">       <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId</a>(<a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a>),</div>
<div class="line">       <a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex</a>(<a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a>));</div>
<div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">    assert(msg); <span class="comment">// Message object must be created</span></div>
<div class="line">    ... <span class="comment">// use msgId and msgIndex values</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td><a class="el" href="classcomms_1_1Message.html" title="Main interface class for all the messages.">Message</a> index value to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation dependent object accepted by "read" functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a> </dd></dl>

</div>
</div>
<a id="ae85afb77abdbfda64916cc6e0d2cb521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85afb77abdbfda64916cc6e0d2cb521">&#9670;&nbsp;</a></span>msgPayload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">details::MsgPayloadRetriever&lt;TIter&gt; comms::protocol::msgPayload </td>
          <td>(</td>
          <td class="paramtype">TIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add "payload start" and "payload size" output parameters to protocol stack's (frame's) "read" operation. </p>
<p>Can be passed as variadic parameters to "read" functions of protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a>). It can be used to retrieve information on payload start location as well as its size. </p><div class="fragment"><div class="line"><span class="keyword">using</span> ProtocolStack = ...</div>
<div class="line">ProtocolStack stack;</div>
<div class="line">ProtocolStack::MsgPtr msg;</div>
<div class="line">decltype(readIter) payloadIter;</div>
<div class="line">std::size_t payloadSize = 0U;</div>
<div class="line"><span class="keyword">auto</span> es = stack.read(msg, readIter, size, <a class="code" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload</a>(payloadIter, payloadSize));</div>
<div class="line">... <span class="comment">// use payload location and size information</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">iter</td><td>Iterator pointing to the begining of the message payload in the input buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>Number of bytes in the detected payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation dependent object accepted by "read" functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read()</a> </dd>
<dd>
<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">comms::protocol::ProtocolLayerBase::readFieldsCached()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1ab6e495eeaee7cdf1bac313472e4681ac">comms::ErrorStatus::NotEnoughData</a></div><div class="ttdeci">@ NotEnoughData</div></div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_a4dfb5a97bd086a5926c9101f467f8683"><div class="ttname"><a href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId</a></div><div class="ttdeci">details::MsgIdRetriever&lt; TId &gt; msgId(TId &amp;val)</div><div class="ttdoc">Add &quot;message ID&quot; output parameter to protocol stack's (frame's) &quot;read&quot; operation.</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1493</div></div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_a8b5ef8b32dcb4f47fb149397c14897ae"><div class="ttname"><a href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex</a></div><div class="ttdeci">details::MsgIndexRetriever msgIndex(std::size_t &amp;val)</div><div class="ttdoc">Add &quot;message index&quot; output parameter to protocol stack's (frame's) &quot;read&quot; operation.</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1531</div></div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_ac267c873369aacc9a16b9b205d85246b"><div class="ttname"><a href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize</a></div><div class="ttdeci">details::MissingSizeRetriever missingSize(std::size_t &amp;val)</div><div class="ttdoc">Add &quot;missing size&quot; output parameter to protocol stack's (frame's) &quot;read&quot; operation.</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1466</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdoc">Used to indicate successful outcome of the operation.</div></div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_ae85afb77abdbfda64916cc6e0d2cb521"><div class="ttname"><a href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload</a></div><div class="ttdeci">details::MsgPayloadRetriever&lt; TIter &gt; msgPayload(TIter &amp;iter, std::size_t &amp;len)</div><div class="ttdoc">Add &quot;payload start&quot; and &quot;payload size&quot; output parameters to protocol stack's (frame's) &quot;read&quot; operati...</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1559</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
