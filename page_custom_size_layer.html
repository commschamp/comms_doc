<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: Defining Custom Message Size Protocol Stack Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Defining Custom Message Size Protocol Stack Layer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <b>COMMS</b> library provides default <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> protocol stack layer to handle remaining length information in the protocol framing. However, it may be insufficient (or incorrect) for some particular use cases, such as using <b>bitfield</b> field to store both remaining size (length) and some extra flags. The <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_new_layers">Implementing New Layers</a> section of the <a class="el" href="page_prot_stack_tutorial.html">Protocol Stack Definition Tutorial</a> page explains how to define new (custom) protocol layer.</p>
<p>However, since <b>v1.2</b> COMMS library provides an ability to extend the existing definition of <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> and customize some bits and pieces. Let's implement the mentioned example of sharing the same byte for numeric ID and some flags.</p>
<p>For this example the protocol framing is defined to be </p><div class="fragment"><div class="line">ID | SIZE | PAYLOAD</div>
</div><!-- fragment --><p> <b>Note</b>, that <b>ID</b> layer, which is responsible to create proper message object, precedes the <b>SIZE</b> one.</p>
<p>First of all let's define the <a class="el" href="page_define_prot.html#page_define_prot_interface">Common Interface Class</a>, which holds the <b>flags</b> information as data member of every message object. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enum used for numeric message IDs</span></div>
<div class="line"><span class="keyword">enum</span> MsgId</div>
<div class="line">{</div>
<div class="line">    MsgId_Message1,</div>
<div class="line">    MsgId_Message2,</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Base class for all the fields defining serialization endian</span></div>
<div class="line"><span class="keyword">using</span> FieldBase = comms::field::Field&lt;comms::option::def::BigEndian&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of the message flags</span></div>
<div class="line"><span class="keyword">class </span>MessageFlags : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        FieldBase,</div>
<div class="line">        comms::option::def::BitmaskReservedBits&lt;0xf0&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provides names and generates access functions for internal bits.</span></div>
<div class="line">    COMMS_BITMASK_BITS_SEQ(bit0, bit1, bit2, bit3);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of the extensible common message interface</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        TOptions...,</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;std::tuple&lt;MessageFlags&gt; &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">//  Allow access to extra transport fields.</span></div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_NAMES(flags);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_prot</span></div>
</div><!-- fragment --><p> Just to refresh the reader's memory: the usage of <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro for the interface definition will generate <b>transportField_flags()</b> convenience member function to access the stored <b>flags</b> field, while usage of <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a> in the flags field definition will genereate <b>getBitValue_X()</b> and <b>setBitValue_X()</b> convenience member functions to get / set values of the bits (where X is one of the defined names: <b>bit0</b>, <b>bit1</b>, <b>bit2</b>, and <b>bit3</b>).</p>
<p>Now, let's define the <b>bitfield</b> field, that splits two bytes to store remaining length (in lower 12 bits) as well as extra flags (in upper 4 bits) </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SizeAndFlagsField : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;</div>
<div class="line">        FieldBase,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            comms::field::IntValue&lt;FieldBase, std::uint16_t, comms::option::def::FixedBitLength&lt;12&gt; &gt;,</div>
<div class="line">            comms::field::IntValue&lt;FieldBase, std::uint8_t, comms::option::def::FixedBitLength&lt;4&gt; &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Allow access to internal member fields.</span></div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(size, flags);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// my_prot</span></div>
</div><!-- fragment --><p> Again, just to refresh the reader's memory: the usage of <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> macro for the bitfield definition will generate <b>field_X()</b> convenience access member functions for the listed names.</p>
<p>Now it's time to actually extend the provided definition of the <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> and support usage of the defined earlier <b>SizeAndFlagsField</b> field. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MsgSizeAndFlagsLayer : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;</div>
<div class="line">        SizeAndFlagsField,   <span class="comment">// Used field that contains remaining length</span></div>
<div class="line">        TNextLayer,          <span class="comment">// Next layer in the protocol stack</span></div>
<div class="line">        comms::option::def::ExtendingClass&lt;MsgSizeAndFlagsLayer&lt;TNextLayer&gt; &gt;</div>
<div class="line">                             <span class="comment">// Make the comms::protocol::MsgSizeLayer aware of it being extended</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Repeat definition of the base class</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Repeat types defined in the base class (not visible by default)</span></div>
<div class="line">    <span class="keyword">using</span> Field = <span class="keyword">typename</span> Base::Field; <span class="comment">// same as SizeAndFlagsField</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Retrieve remaining length value from the given SizeAndFlagsField field</span></div>
<div class="line">    <span class="keyword">static</span> std::size_t getRemainingSizeFromField(<span class="keyword">const</span> Field&amp; field)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(field.field_size().value());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set flags value for the message object before proceeding to the next layer read</span></div>
<div class="line">    <span class="comment">// The message object is passed by pointer (which may be nullptr for some cases)</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> beforeRead(<span class="keyword">const</span> Field&amp; field, TMsg* msg)</div>
<div class="line">    {</div>
<div class="line">        assert(msg != <span class="keyword">nullptr</span>); <span class="comment">// mustn&#39;t be nullptr for this example</span></div>
<div class="line">        msg-&gt;transportField_flags().value() = field.field_flags().value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Assemble the field&#39;s value before its write, given remaining length as well</span></div>
<div class="line">    <span class="comment">// as message object itself.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> prepareFieldForWrite(std::size_t size, <span class="keyword">const</span> TMsg* msg, Field&amp; field)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span>&amp; sizeMemberField = field.field_size();</div>
<div class="line">        <span class="keyword">using</span> SizeMemberFieldType = <span class="keyword">typename</span> std::decay&lt;decltype(sizeMemberField)&gt;::type;</div>
<div class="line">        sizeMemberField.value() = <span class="keyword">static_cast&lt;</span>typename SizeMemberFieldType::ValueType<span class="keyword">&gt;</span>(size);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (msg != <span class="keyword">nullptr</span>) {</div>
<div class="line">            field.field_flags().value() = msg-&gt;transportField_flags().value();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_prot</span></div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> doesn't have any virtual functions and as the result not able to provide any polymorphic behavior. In order to be able to extend its default functionality there is a need to use <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously Recurring Template Pattern</a>. It is done by passing <a class="el" href="structcomms_1_1option_1_1def_1_1ExtendingClass.html">comms::option::def::ExtendingClass</a> extension option with the type of the layer class being defined to the <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>.</p>
<p>The extending class is expected to define the listed below functions. They do not necessarily need to be <b>static</b>, accessing inner private state of the layer object is also acceptable. </p><ul>
<li><b>getRemainingSizeFromField()</b> - Member function that is invoked to retrieve the remaining length out of the provided field object. </li>
<li><b>beforeRead()</b> - Member function that is invoked before the read operation is forwarded to the next layer. It gives the developer a chance to update some extra transport fields accessible via message interface class (if such exists). Note that the message object is passed by the pointer to allow cases when it is not created yet. In the example above <b>ID</b> layer precedes the <b>SIZE</b>, so the message object must already be created. </li>
<li><b>prepareFieldForWrite()</b> - Member function that is invoked to prepare the field value before its write (serialization). After the function returns, the <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> will invoke <b>write</b> member function of the passed field in order to serialize it. Note, that the message object is passed by the pointer. There may be cases when <b>doUpdate()</b> member function is going to be called without having actual message object being present. In this case the <b>msg</b> parameter will be <b>nullptr</b>.</li>
</ul>
<p>The newly defined custom protocol stack layer can be used instead of <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> when defining <a class="el" href="page_prot_stack_tutorial.html">protocol stack</a> (framing) of the protocol. For example: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage, <span class="keyword">typename</span> TAllMessages&gt;</div>
<div class="line"><span class="keyword">struct </span>Frame1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt;                     <span class="comment">// ID</span></div>
<div class="line">        comms::feild::EnumValue&lt;FieldBase, MsgId&gt;,</div>
<div class="line">        TMessage,</div>
<div class="line">        TAllMessages,</div>
<div class="line">        MsgSizeAndFlagsLayer&lt;                          <span class="comment">// SIZE + FLAGS</span></div>
<div class="line">            comms::protocol::MsgDataLayer&lt;&gt;          <span class="comment">// PAYLOAD</span></div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Generate convenience access functions for various layers</span></div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS_OUTER(<span class="keywordtype">id</span>, size, payload);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_prot</span></div>
</div><!-- fragment --><p>For completeness of the picture, let's also do similar example when <b>SIZE</b> precedes the <b>ID</b>. </p><div class="fragment"><div class="line">SIZE | ID | PAYLOAD</div>
</div><!-- fragment --><p> The main problem with such scenario is that message object is created by the <b>ID</b> layer (<a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>), and is not available in <b>beforeRead()</b> member function the <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> invokes. <b>However</b>, the flags may influence the way the message payload is being processed, so the flags expected to be already assigned to message object before message body is being read (before read operation reaches <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>).</p>
<p>In order to resolve such case there is a need to do a bit of cheating by introducing <b>pseudo</b> layer to manage <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_transport_value">Extra Transport Values</a> after the <b>ID</b> layer and before the <b>PAYLOAD</b>. </p><div class="fragment"><div class="line">SIZE | ID | FLAGS (pseudo) | PAYLOAD</div>
</div><!-- fragment --><p> The <b>SIZE</b> layer will access and assign the flags value to <b>FLAGS (pseudo)</b> layer, which will reassign it to the message object created later by the <b>ID</b> one. <b>NOTE</b>, that <b>pseudo</b> <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_transport_value">transport value</a> layer does <b>NOT</b> serialize its field and as the result preserves binary compatibility of the protocol framing.</p>
<p>The extension to <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> may be implemented like this: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MsgSizeAndFlagsLayer : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;</div>
<div class="line">        SizeAndFlagsField,   <span class="comment">// Used field that contains remaining length</span></div>
<div class="line">        TNextLayer,          <span class="comment">// Next layer in the protocol stack</span></div>
<div class="line">        comms::option::def::ExtendingClass&lt;MsgSizeAndFlagsLayer&lt;TNextLayer&gt; &gt;</div>
<div class="line">                             <span class="comment">// Make the comms::protocol::MsgSizeLayer aware of it being extended</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Repeat definition of the base class</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Repeat types defined in the base class (not visible by default)</span></div>
<div class="line">    <span class="keyword">using</span> Field = <span class="keyword">typename</span> Base::Field; <span class="comment">// same as SizeAndFlagsField</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Retrieve remaining length value from the given SizeAndFlagsField field</span></div>
<div class="line">    <span class="keyword">static</span> std::size_t getRemainingSizeFromField(<span class="keyword">const</span> Field&amp; field)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(field.field_size().value());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set flags value for the message object before proceeding to the next layer read</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line">    <span class="keywordtype">void</span> beforeRead(<span class="keyword">const</span> Field&amp; field, TMsg* msg)</div>
<div class="line">    {</div>
<div class="line">        assert(msg == <span class="keyword">nullptr</span>); <span class="comment">// message is not created yet</span></div>
<div class="line">        <span class="keyword">auto</span>&amp; pseudoFlagsLayer = Base::nextLayer().nextLayer(); </div>
<div class="line">        pseudoFlagsLayer.pseudoField().value() = field.field_flags().value();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Assemble the field&#39;s value before its write, given remaining length as well</span></div>
<div class="line">    <span class="comment">// as message object itself.</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> prepareFieldForWrite(std::size_t size, <span class="keyword">const</span> TMsg* msg, Field&amp; field)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span>&amp; sizeMemberField = field.field_size();</div>
<div class="line">        <span class="keyword">using</span> SizeMemberFieldType = <span class="keyword">typename</span> std::decay&lt;decltype(sizeMemberField)&gt;::type;</div>
<div class="line">        sizeMemberField.value() = <span class="keyword">static_cast&lt;</span>typename SizeMemberFieldType::ValueType<span class="keyword">&gt;</span>(size);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (msg != <span class="keyword">nullptr</span>) {</div>
<div class="line">            field.field_flags().value() = msg-&gt;transportField_flags().value();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_prot</span></div>
</div><!-- fragment --><p> The protocol stack (transport framing) itself needs to be defined like this: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_prot</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage, <span class="keyword">typename</span> TAllMessages&gt;</div>
<div class="line"><span class="keyword">struct </span>Frame2 : <span class="keyword">public</span> </div>
<div class="line">    MsgSizeAndFlagsLayer&lt;                                        <span class="comment">// SIZE + FLAGS </span></div>
<div class="line">        comms::protocol::MsgIdLayer&lt;                             <span class="comment">// ID</span></div>
<div class="line">            comms::feild::EnumValue&lt;FieldBase, MsgId&gt;</div>
<div class="line">            TMessage,</div>
<div class="line">            TAllMessages,</div>
<div class="line">            comms::protocol::TransportValueLayer&lt;                <span class="comment">// FLAGS</span></div>
<div class="line">                comms::field::IntValue&lt;FieldBase, std::uint8_t&gt;, </div>
<div class="line">                0U,                                              </div>
<div class="line">                comms::protocol::MsgDataLayer&lt;&gt;,                 <span class="comment">// PAYLOAD      </span></div>
<div class="line">                comms::option::def::PseudoValue                  <span class="comment">// Make flags &quot;pseudo&quot; </span></div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Generate convenience access functions for various layers</span></div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS_OUTER(size, <span class="keywordtype">id</span>, flags, payload);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_prot</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aField_8h_html_af74198f06b52d3f58c92e795b2ff7129"><div class="ttname"><a href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a></div><div class="ttdeci">#define COMMS_FIELD_MEMBERS_NAMES(...)</div><div class="ttdoc">Provide names for member fields of composite fields, such as comms::field::Bundle or comms::field::Bi...</div><div class="ttdef"><b>Definition:</b> Field.h:372</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgSizeLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a></div><div class="ttdoc">Protocol layer that uses size field as a prefix to all the subsequent data written by other (next) la...</div><div class="ttdef"><b>Definition:</b> MsgSizeLayer.h:59</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgIdLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a></div><div class="ttdoc">Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...</div><div class="ttdef"><b>Definition:</b> MsgIdLayer.h:64</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html"><div class="ttname"><a href="classcomms_1_1Message.html">comms::Message</a></div><div class="ttdoc">Main interface class for all the messages.</div><div class="ttdef"><b>Definition:</b> Message.h:79</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bitfield_html"><div class="ttname"><a href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a></div><div class="ttdoc">Bitfield field.</div><div class="ttdef"><b>Definition:</b> Bitfield.h:101</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a></div><div class="ttdoc">Bitmask value field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:101</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
