<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: How to Define New Custom Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to Define New Custom Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#page_define_prot_headers">Headers and Libraries</a></li>
<li class="level1"><a href="#page_define_prot_conditions">Checking pre- and post- Conditions</a></li>
<li class="level1"><a href="#page_define_prot_options">Configuration Options</a></li>
<li class="level1"><a href="#page_define_prot_interface">Common Interface Class</a><ul><li class="level2"><a href="#page_define_prot_interface_extra_transport">Extra Transport Values</a></li>
<li class="level2"><a href="#page_define_prot_interface_version">Version in Extra Transport Values</a></li>
</ul>
</li>
<li class="level1"><a href="#page_define_prot_message_base">Message Implementation Class</a><ul><li class="level2"><a href="#page_define_prot_message_base_field_names">Providing Names to the Fields</a></li>
<li class="level2"><a href="#page_define_prot_message_base_custom_read">Custom Read Functionality</a></li>
<li class="level2"><a href="#page_define_prot_message_base_custom_refresh">Custom Refresh Functionality</a></li>
<li class="level2"><a href="#page_define_prot_message_base_custom_write">Custom Write Functionality</a></li>
<li class="level2"><a href="#page_define_prot_message_base_custom_length">Custom Length Calculation</a></li>
<li class="level2"><a href="#page_define_prot_message_base_custom_valid">Custom Validity Check</a></li>
<li class="level2"><a href="#page_define_prot_message_base_name">Reporting Message Name</a></li>
<li class="level2"><a href="#page_define_prot_message_version">Protocol Version Support</a></li>
</ul>
</li>
<li class="level1"><a href="#page_define_prot_field_aliases">Aliases to Field Names</a><ul><li class="level2"><a href="#page_define_prot_field_aliases_messages">Aliases to Field Names Inside Message Definition</a></li>
<li class="level2"><a href="#page_define_prot_field_aliases_bundles">Aliases to Field Names Inside Bundle Fields</a></li>
<li class="level2"><a href="#page_define_prot_field_aliases_interfaces">Aliases to Extra Transport Field Names Inside Interface</a></li>
</ul>
</li>
<li class="level1"><a href="#page_define_prot_lenth_verification">Extra Compile Time Checks</a></li>
<li class="level1"><a href="#page_define_prot_customisation">Application Specific Customisation</a></li>
<li class="level1"><a href="#page_define_prot_transport_framing">Transport Framing Definition</a></li>
</ul>
</div>
<div class="textblock"><p>The protocol definition is mostly about defining messages and their fields. As the first stage please read <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a> in order to understand what types of fields are available and how to define them.</p>
<h1><a class="anchor" id="page_define_prot_headers"></a>
Headers and Libraries</h1>
<p>COMMS is a headers only library without any object files to link against. In order to include the whole functionality of the library please use single include statement: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
</div><!-- fragment --><p>If the protocol grows and the compilation takes a significant amount of time, more fine-grained include statements may be used: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fields_8h.html">comms/fields.h</a>&quot;</span> <span class="comment">// Provides all definitions from comms::field namespace</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="protocols_8h.html">comms/protocols.h</a>&quot;</span> <span class="comment">// Provides all definitions from comms::protocol namespace</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="units_8h.html">comms/units.h</a>&quot;</span> <span class="comment">// Provides all definitions from comms::units namespace</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="Message_8h.html">comms/Message.h</a>&quot;</span> <span class="comment">// Definition of comms::Message class to define interface</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="MessageBase_8h.html">comms/MessageBase.h</a>&quot;</span> <span class="comment">// Definition of comms::MessageBase class to define message impl</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="GenericHandler_8h.html">comms/GenericHandler.h</a>&quot;</span> <span class="comment">// Definition of comms::GenericHandler class</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="MsgFactory_8h.html">comms/MsgFactory.h</a>&quot;</span> <span class="comment">// Definition of comms::MessageFactory class</span></div>
</div><!-- fragment --><h1><a class="anchor" id="page_define_prot_conditions"></a>
Checking pre- and post- Conditions</h1>
<p>The COMMS library is intended to be used in embedded systems (including bare metal), which may have standard library excluded from the compilation. In order to check pre- and post- conditions as well as inner assumptions, please use <a class="el" href="Assert_8h.html#a941aec86290602caa61d86b671aea550">COMMS_ASSERT</a> macro (instead of standard <b>assert()</b>). It gives and ability to the application being developed in the future to choose and use its own means to report assertion failures.</p>
<h1><a class="anchor" id="page_define_prot_options"></a>
Configuration Options</h1>
<p>Many classes provided by the <b>COMMS</b> library allow change and/or extention of their default functionality using various options. The option classes and/or types that can (and should) be used to define a protocol reside in <a class="el" href="namespacecomms_1_1option_1_1def.html">comms::option::def</a> namespace. All option classes / types that intended to be used by the end application for its own customization reside in <a class="el" href="namespacecomms_1_1option_1_1app.html">comms::option::app</a> namespace and should <b>NOT</b> be used in protocol definition.</p>
<h1><a class="anchor" id="page_define_prot_interface"></a>
Common Interface Class</h1>
<p>Protocol definition needs to be started by defining all the available numeric IDs of the messages as separate enum. For example in file <b>MsgId.h</b> </p><div class="fragment"><div class="line"><span class="comment">// file MsgId.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> MsgId : std::uint8_t</div>
<div class="line">    {</div>
<div class="line">        MsgId_Message1,</div>
<div class="line">        MsgId_Message2,</div>
<div class="line">        MsgId_Message3,</div>
<div class="line">        ...</div>
<div class="line">    };</div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> <b>NOTE</b>, that most probably the same enum will be used to define a field that responsible to read / write message ID information in the transport framing. That's the reason why the underlying type of the enum needs to be specified (please see <a class="el" href="page_field_tutorial.html#sec_field_tutorial_enum_value">Enum Value Fields</a> for more details).</p>
<p>After the numeric IDs are specified, there is a need to define common message interface class by extending <a class="el" href="classcomms_1_1Message.html">comms::Message</a>. The defined class / type needs to pin the type used for message IDs with <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> and defined earlier enum. It also should specify the serialisation endian with either <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> options. However it must also allow extension with other options by the application. </p><div class="fragment"><div class="line"><span class="comment">// file Message.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">using</span> Message = </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType&lt;MsgId&gt;</a>,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> The application, that is going to use protocol definition later, will use extra options to specify polymorphic behaviour it needs.</p>
<h2><a class="anchor" id="page_define_prot_interface_extra_transport"></a>
Extra Transport Values</h2>
<p>Some protocols may use extra values in their transport information, which may influence the way how message payload is being read and/or message object being handled. Good example would be having a protocol version, which defines what message payload fields were serialised and which were not (because they were introduced in later version of the protocol). Another example is having some kind of flags relevant to all the messages. Such extra information needs to be stored in the message object itself. The most straightforward way of achieving this is to define appropriate API functions and member fields in common message interface class: </p><div class="fragment"><div class="line"><span class="comment">// file Message.h</span></div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>MyMessage : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">unsigned</span> getVersion()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_version; }</div>
<div class="line">    <span class="keywordtype">void</span> setVersion(<span class="keywordtype">unsigned</span> value) { m_version = value; }</div>
<div class="line">    std::uint8_t getFlags()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_flags; }</div>
<div class="line">    <span class="keywordtype">void</span> setFlags(std::uint8_t value) { m_flags = value; }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">unsigned</span> m_version = 0;</div>
<div class="line">    std::uint8_t m_flags = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> <b>HOWEVER</b>, it will require implementation of a custom protocol transport layer (See <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_new_layers">Implementing New Layers</a>) that read the required values and re-assign them to the message object using appropriate API function. The COMMS library has a built-in way to automate such assignments (see <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_transport_value">Extra Transport Values</a> section in <a class="el" href="page_prot_stack_tutorial.html">Protocol Stack Definition Tutorial</a>). In order to support usage of <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> the message interface class must define "extra transport fields".</p>
<p>First, such extra transport field(s) must be defined using a field abstraction (see <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a>) and bundled in <b>std::tuple:</b> </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Base class of all the fields</span></div>
<div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Field describing protocol version.</span></div>
<div class="line"><span class="keyword">using</span> MyVersionField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Field describing protocol version.</span></div>
<div class="line"><span class="keyword">using</span> MyFlagsField = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt;</a> &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Relevant extra transport fields, bundled in std::tuple</span></div>
<div class="line"><span class="keyword">using</span> MyExtraTransportFields =</div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        MyVersionField,</div>
<div class="line">        MyFlagsField</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> Second, provide the defined tuple to message interface class using <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> It is equivalent to having the following public interface defined: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>MyMessage : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Type of extra fields</span></div>
<div class="line">    <span class="keyword">using</span> TransportFields = MyExtraTransportFields;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessors for defined transport fields</span></div>
<div class="line">    TransportFields&amp; transportFields() { <span class="keywordflow">return</span> m_transportFields; }</div>
<div class="line">    <span class="keyword">const</span> TransportFields&amp; transportFields()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_transportFields; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    TransportFields m_transportFields;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> An access to the version and flags information, given a reference to the message object will look like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(my_protocol::Message&lt;&gt;&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Access to tuple of extra transport fields</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; extraTransportFields = msg.transportFields();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the version field</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; versionField = std::get&lt;0&gt;(extraTransportFields);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Retrieve the version numeric value</span></div>
<div class="line">    <span class="keyword">auto</span> versionValue = versionField.value();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the flags field</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; flagsField = std::get&lt;1&gt;(extraTransportFields);</div>
<div class="line"> </div>
<div class="line">    ... <span class="comment">// do something with version and flags information</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The version and/or flags information may be accessed in the same way when implementing <a class="el" href="page_define_prot.html#page_define_prot_message_base_custom_read">Custom Read Functionality</a> and acted accordingly.</p>
<p><b>NOTE</b>, that example above accesses the index of the field within the holding tuple. For convenience, the COMMS library defines <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro which allows providing meaningful names to the extra transport fields: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div>
<div class="line">    <span class="comment">// required by COMMS_MSG_TRANSPORT_FIELDS_NAMES() macro</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(<a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>, flags)</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b> requirement to (re)define base class as inner <b>Base</b> type. It is needed to be able to access <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">TransportFields</a> type defined by the <a class="el" href="classcomms_1_1Message.html">comms::Message</a>.</p>
<p>Using such macro is equivalent to manually defining the following public interface: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> TransportFieldIdx</div>
<div class="line">    {</div>
<div class="line">        TransportFieldIdx_version,</div>
<div class="line">        TransportFieldIdx_flags,</div>
<div class="line">        TransportFieldIdx_numOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_version() -&gt; decltype(std::get&lt;TransportFieldIdx_version&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_version&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_version() const -&gt; decltype(std::get&lt;TransportFieldIdx_version&gt;(transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_version&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_flags() -&gt; decltype(std::get&lt;TransportFieldIdx_flags&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_flags&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> transportField_flags() const -&gt; decltype(std::get&lt;TransportFieldIdx_flags&gt;(transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_flags&gt;(<a class="code" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">transportFields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Definition of the transport field&#39;s types</span></div>
<div class="line">    <span class="keyword">using</span> TransportField_version = ...;</div>
<div class="line">    <span class="keyword">using</span> TransportField_flags = ...;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that the defined "extra transport fields" are there to attach some extra information, delivered as part of transport framing, to message object itself. These fields are <b>NOT</b> getting serialised / deserialised when message object being read / written.</p>
<p><b>SIDE NOTE:</b> In addition to <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro there is <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a> one. It is very similar to <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> but does <b>NOT</b> (re)define the inner <b>TransportField_*</b> types. It also does not require (except for <b>clang</b>) having base class to be (re)defined as inner <b>Base</b> type. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a>(<a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>, flags)</div>
<div class="line">};</div>
</div><!-- fragment --><p> In fact <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> is implemented as the wrapper around <a class="el" href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">COMMS_MSG_TRANSPORT_FIELDS_ACCESS()</a>.</p>
<h2><a class="anchor" id="page_define_prot_interface_version"></a>
Version in Extra Transport Values</h2>
<p>As was described in previous section, the extra transport values may contain protocol version information. The COMMS library contains extra functionality to help with protocol versioning. If extra transport values contain version, then it is recommended to let the library know which field in the provided ones is the version. To do so <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a>, with index of the field as a template argument needs to be used. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        comms::option::def::VersionInExtraTransportFields&lt;0&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> This option adds the following type and convenience access member functions. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// Type used for version storage</span></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a> = ...;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Convenience access to the version value</span></div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a>&amp; <a class="code" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">version</a>();</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a>&amp; <a class="code" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">version</a>() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> If message contents depend on the version of the protocol, this information will be used inside <a class="el" href="page_define_prot.html#page_define_prot_message_base">Message Implementation Class</a> (described below) to properly implement various functionalities. More details in <a class="el" href="page_define_prot.html#page_define_prot_message_version">Protocol Version Support</a> section below.</p>
<h1><a class="anchor" id="page_define_prot_message_base"></a>
Message Implementation Class</h1>
<p>The next stage is to define protocol messages with their fields.</p>
<p><b>Recommended Practice</b> </p><ul>
<li>Use separate header file for every message class. </li>
<li>Use separate folder and/or namespace for all the messages (for example <b>message</b>) </li>
<li>Define all the relevant to the message fields in the same file, but in separate scope (struct), that has the same name as the message, but has extra suffix (<b>*Fields</b>). </li>
<li>Define inner type (for example <b>All</b>) that bundles all the defined fields in single <b>std::tuple</b>.</li>
</ul>
<p>For example, let's assume there is a protocol message called "Message1". Then, define it in separate header filed (<b>Message1.h</b>) </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Message1Fields</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> field1 = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> field2 = ...</div>
<div class="line">    <span class="keyword">using</span> field3 = ...</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bunding type</span></div>
<div class="line">    <span class="keyword">using</span> All = </div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            field1,</div>
<div class="line">            field2,</div>
<div class="line">            field3</div>
<div class="line">        &gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of the message itself, described and explained later</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;TBase, ...&gt; </div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p>The message definition class has to extend <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> and receive at least one template parameter, that is passed as first one to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;TBase, ...&gt; </div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> The <b>TBase</b> template parameter is chosen by the application being developed. It is expected to be a variant of <a class="el" href="page_define_prot.html#page_define_prot_interface">Common Interface Class</a> (<b>my_protocol::Message</b>), which specifies polymorphic interface that needs to be implemented. The <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class in turn will publicly inherit from the provided common interface class. As the result the full class inheritance graph may look like this: <div class="diagraph">
<img src="dia_message_class_hierarchy.png" />
</div>
 <br  />
 There are <b>at least</b> 3 additional options that should be passed to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. </p><ul>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a> with numeric ID of the message. </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a> with <b>std::tuple</b> of message fields ( defined earlier <b>my_protocol::Message1Fields::All</b>) </li>
<li><a class="el" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a> with actual message type (<b>Message1</b>).</li>
</ul>
<p>For example </p><div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields::All&gt;,</div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase&gt; &gt; <span class="comment">// type of the message being defined</span></div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p>It is equivalent to having the following types and <b>NON-virtual</b> functions defined </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> TBase</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Redefining the provided std::tuple of fields as internal type</span></div>
<div class="line">    <span class="keyword">using</span> AllFields = ... <span class="comment">/* std::tuple of fields */</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access the stored std::tuple of fields</span></div>
<div class="line">    AllFields&amp; fields()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fields_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the stored std::tuple of fields</span></div>
<div class="line">    <span class="keyword">const</span> AllFields&amp; fields()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> fields_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementation of read functionality</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(TIter&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Read all the fields one by one by invoking</span></div>
<div class="line">        <span class="comment">// read() member function of all the fields.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementation of write functionality</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doWrite(TIter&amp; iter, std::size_t len)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Write all the fields one by one by invoking</span></div>
<div class="line">        <span class="comment">// write() member function of all the fields.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementation of validity check functionality</span></div>
<div class="line">    <span class="keywordtype">bool</span> doValid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Call to valid() member function of all the fields one by one.</span></div>
<div class="line">        <span class="comment">// The message is valid if all the fields are valid.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Default implementation of length calculation functionality</span></div>
<div class="line">    std::size_t doLength()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Invoke the length() member function of every field and</span></div>
<div class="line">        <span class="comment">// report sum of the values</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Defalut implementation of the refreshing functionality</span></div>
<div class="line">    <span class="keywordtype">bool</span> doRefresh()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Invokes refresh() member function of every field and returns</span></div>
<div class="line">        <span class="comment">// true if at least one of the fields has been updated (returned true).</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    AllFields fields_; <span class="comment">// Fields stored as tuple.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> See also relevant API documentation: </p><ul>
<li><a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">comms::MessageBase::doRead()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">comms::MessageBase::doWrite()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">comms::MessageBase::doLength()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">comms::MessageBase::doValid()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">comms::MessageBase::doRefresh()</a></li>
</ul>
<p>In case the passed message interface class as template parameter (<b>TBase</b>) defines some polymorphic interface functions, their implementation is automatically generated by the <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. For example if passed interface class required polymorphic read operation, the following member function will also be automatically implemented: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> TBase</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">protected:</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> readImpl(<a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">ReadIterator</a>&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> doRead(iter, len);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="page_define_prot_message_base_field_names"></a>
Providing Names to the Fields</h2>
<p>When preparing message object to send or when handling received message, the fields it contains need to be accessed to set or get their values. The default (build-in) way of achieving that is to get access to the fields tuple using inherited <a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891" title="Get an access to the fields of the message.">comms::MessageBase::fields()</a> member function and then using <b>std::get()</b> function to access the fields inside the tuple. </p><div class="fragment"><div class="line">Message1&lt;SomeInterface&gt; msg;</div>
<div class="line"><span class="keyword">auto</span>&amp; allFields = msg.fields();</div>
<div class="line"><span class="keyword">auto</span>&amp; field1 = std::get&lt;0&gt;(allFields);</div>
<div class="line"><span class="keyword">auto</span>&amp; field2 = std::get&lt;1&gt;(allFields);</div>
<div class="line"> </div>
<div class="line">field1.value() = 100;</div>
<div class="line">field2.value() = 32;</div>
<div class="line">sendMessage(msg);</div>
</div><!-- fragment --><p> Although it works, it is not very convenient way to access and operate the fields. There is <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> macro that allows to provide meaningful names for the fields: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Definition of the Base class is a requirement</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(value1, value2, value3);</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b> requirement to (re)define base class as inner <b>Base</b> type. It is needed to be able to access <a class="el" href="classcomms_1_1MessageBase.html#a108df722c6d6e5016ab6b35b961b43cd">AllFields</a> type defined by the <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>.</p>
<p>The said macro creates the following definitions of inner enum <b>FieldIdx</b> type, <b>field_*</b> accessor functions as well as <b>Field_*</b> type definitions. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> FieldIdx</div>
<div class="line">    {</div>
<div class="line">        FieldIdx_value1,</div>
<div class="line">        FieldIdx_value2,</div>
<div class="line">        FieldIdx_value3,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value1&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value1() -&gt; decltype(std::get&lt;FieldIdx_value1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value1&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value1() const -&gt; decltype(std::get&lt;FieldIdx_value1&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value1&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value2&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value2() -&gt; decltype(std::get&lt;FieldIdx_value2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value2&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value2() const -&gt; decltype(std::get&lt;FieldIdx_value2&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value2&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value3&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() -&gt; decltype(std::get&lt;FieldIdx_value3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value3&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() const -&gt; decltype(std::get&lt;FieldIdx_value3&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value3&gt;(<a class="code" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">fields</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Definition of the field&#39;s types</span></div>
<div class="line">    <span class="keyword">using</span> Field_value1 = Field1;</div>
<div class="line">    <span class="keyword">using</span> Field_value2 = Field2;</div>
<div class="line">    <span class="keyword">using</span> Field_value3 = Field3;</div>
<div class="line">};</div>
</div><!-- fragment --><p> As the result, accessing to the fields becomes much easier and clearer: </p><div class="fragment"><div class="line">Message1&lt;SomeInterface&gt; msg;</div>
<div class="line">msg.field_value1().value() = 100;</div>
<div class="line">msg.field_value2().value() = 32;</div>
<div class="line">sendMessage(msg);</div>
</div><!-- fragment --><p> <b>SIDE NOTE:</b> In addition to <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> macro there is <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> one. It is very similar to <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> but does <b>NOT</b> (re)define the inner <b>Field_*</b> types. It also does not require (except for <b>clang</b>) having base class to be (re)defined as inner <b>Base</b> type. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS</a>(value1, value2, value3);</div>
<div class="line">};</div>
</div><!-- fragment --><p> In fact <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> is implemented as the wrapper around <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a>.</p>
<h2><a class="anchor" id="page_define_prot_message_base_custom_read"></a>
Custom Read Functionality</h2>
<p>The default read functionality implemented by <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">comms::MessageBase::doRead()</a> is to invoke <b>read()</b> member function of every field and return <b>success</b> if all the invocations returned <b>success</b>. Sometimes such default implementation may be incomplete or incorrect and may require additional or different implementation. It is very easy to fix by defining new <b>doRead()</b> public member function with updated functionality. The <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class contains inner "magic" to call the provided <b>doRead()</b> instead of default one when implementing virtual <a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">comms::MessageBase::readImpl()</a>. As an example let's define new message type (<b>Message2</b>), which has two fields. The first one is a 1 byte bitmask, the least significant bit of which defines whether the second field exists. The second field is optional 2 byte unsigned integer one. </p><div class="fragment"><div class="line"><span class="comment">// file Message2.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Message2Fields</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> field1 =     </div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">            MyFieldBase, </div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength&lt;1&gt;</a>,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::BitmaskReservedBits&lt;0xfe, 0&gt;</a> </div>
<div class="line">        &gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> field2 = </div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div>
<div class="line">            <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::MissingByDefault</a></div>
<div class="line">        &gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bundle all the fields</span></div>
<div class="line">    <span class="keyword">using</span> All = std::tuple&lt;</div>
<div class="line">        field1,</div>
<div class="line">        field2</div>
<div class="line">    &gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message2&gt;, </div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message2Fields::All&gt;,</div>
<div class="line">        comms::option::def::MsgType&lt;Message2&lt;TBase&gt; &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Redefinition of the base class as inner Base type, required</span></div>
<div class="line">    <span class="comment">// by COMMS_MSG_FIELDS_NAMES() macro.</span></div>
<div class="line">    <span class="keyword">using</span> Base = </div>
<div class="line">        <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">            TBase, </div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl&lt;MsgId_Message2&gt;</a>, </div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl&lt;Message2Fields::All&gt;</a>,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType&lt;Message2&lt;TBase&gt;</a> &gt;</div>
<div class="line">        &gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_MSG_FIELDS_NAMES(flags, data);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(TIter&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get type of the base class</span></div>
<div class="line">        <span class="keyword">using</span> Base = <span class="keyword">typename</span> std::decay&lt;decltype(<a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*<span class="keyword">this</span>))&gt;::type;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Read only the flags value</span></div>
<div class="line">        <span class="keyword">auto</span> es = Base::template doReadUntilAndUpdateLen&lt;FieldIdx_data&gt;(iter, len);</div>
<div class="line">        <span class="keywordflow">if</span> (es != <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> es;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update mode (exists/missing) of the optional value to follow</span></div>
<div class="line">        <span class="keywordflow">if</span> (field_flags().value() != 0) {</div>
<div class="line">            field_data().setExists();</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            field_data().setMissing();</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">        <span class="comment">// Read the rest of the fields</span></div>
<div class="line">        <span class="keywordflow">return</span> Base::template doReadFrom&lt;FieldIdx_data&gt;(iter, len);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Please <b>note</b>, that due to the fact that defined message class is a template one, the member functions defined in <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> are not accessible directly, there is a need to specify the base class scope. If there is no inner <b>Base</b> type defined in the class scope (required to support clang and earlier versions of gcc), it is possible to use <a class="el" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase()</a> function to detect it.</p>
<p>Also <b>note</b>, that <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> provides the following member functions in order to allow read of the selected fields. </p><ul>
<li><a class="el" href="classcomms_1_1MessageBase.html#a1370aa1f188ead8dee2091cffb691c65">comms::MessageBase::doReadFrom()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#af335676e4b4f9667887443aa7c6482ea">comms::MessageBase::doReadUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a46df98c07723fa701f74b1b03c63a508">comms::MessageBase::doReadFromUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#ac0022211e70afa1b915ecd2bd74c9b39">comms::MessageBase::doReadFromAndUpdateLen()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#ac5a04675c280e76ad35a9996fc29274f">comms::MessageBase::doReadUntilAndUpdateLen()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#afce678a197ee7bfc4a4c7493813a4db2">comms::MessageBase::doReadFromUntilAndUpdateLen()</a></li>
</ul>
<h2><a class="anchor" id="page_define_prot_message_base_custom_refresh"></a>
Custom Refresh Functionality</h2>
<p>The default refresh functionality implemented by <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">comms::MessageBase::doRefresh()</a> is to invoke <b>refresh()</b> member function of every field. The function will return <b>true</b> (indicating that at message contents have been updated) if at least one of the fields returns <b>true</b>. Let's take a look again at the definition of <b>Message2</b> mentioned earlier, where the existence of second field (<b>data</b>) depends on the value of the least significant bit in the first field (<b>flags</b>). During read operation the mode of the <b>data</b> is updated after value of the <b>flags</b> is read. However, when preparing the same message for write, there is a chance that message contents are going to be put in invalid state: </p><div class="fragment"><div class="line">Message2&lt;SomeInterface&gt; msg;</div>
<div class="line">msg.field_flags().value() = 0x1;</div>
<div class="line">msg.field_data().field().value() = 10U;</div>
<div class="line">msg.field_data().setMissing(); <span class="comment">// Bug, the field should exist</span></div>
<div class="line">sendMessage(msg);</div>
</div><!-- fragment --><p> If message is sent, the <b>flags</b> will indicate that the <b>data</b> field follows, but it won't be serialised, due to being marked as "missing" by mistake. Please note, that all the "write" functions are marked as <b>const</b> and are not allowed to update the message fields during write operation. It may be useful to have member function that brings message contents into the valid and consistent state. It should be called <b>doRefresh()</b> and return boolean value (<b>true</b> in case the message contents were updated, and <b>false</b> if they remain intact. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(flags, data);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh</a>()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> expectedDataMode = <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2aee0be2678ee90fd327cc186826438e">comms::field::OptionalMode::Missing</a>;</div>
<div class="line">        <span class="keywordflow">if</span> ((field_flags().value() &amp; 0x1) != 0U) {</div>
<div class="line">            expectedDataMode = <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2a8eb028670e972535e8e246be645821">comms::field::OptionalMode::Exists</a>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (field_data().getMode() == expectedDataMode) {</div>
<div class="line">            <span class="comment">// No need to change anything</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        field_data().setMode(expectedDataMode);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> As the result the code preparing message for sending may look like this: </p><div class="fragment"><div class="line">Message2&lt;SomeInterface&gt; msg;</div>
<div class="line">msg.field_flags().value() = 0x1;</div>
<div class="line">msg.field_data().field().value() = 10U;</div>
<div class="line">msg.doRefresh(); <span class="comment">// Bring message contents into a valid state</span></div>
<div class="line">sendMessage(msg);</div>
</div><!-- fragment --><p> In order to support polymorphic refresh functionality when required (see <a class="el" href="page_use_prot.html#page_use_prot_interface_refresh">Keeping Message Contents in a Consistent State</a>), the actual message class implementation must also pass <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> option to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class. Failure to do so <b>may</b> result in missing implementation of <a class="el" href="classcomms_1_1MessageBase.html#a49b9cea8e73c2f592ffd55fd274893ba">comms::MessageBase::refreshImpl()</a>. In this case, the default implementation of <a class="el" href="classcomms_1_1Message.html#af39437bde1292832507e97885fee114f">comms::Message::refreshImpl()</a> will be used instead, always returning <b>false</b> (reporting that message fields weren't updated) without proper execution of refresh functionality. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MyMsgId_Message2&gt;, </div>
<div class="line">        comms::option::def::MsgType&lt;Message2&lt;TMessage&gt; &gt;, </div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message2Fields&gt; ,</div>
<div class="line">        comms::option::def::HasCustomRefresh <span class="comment">// Support polymorphic refresh when needed</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;... <span class="comment">/* options here */</span>&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(flags, data);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">doRead</a>(TIter&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// see implementation above</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh</a>()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// see implementation above</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="page_define_prot_message_base_custom_write"></a>
Custom Write Functionality</h2>
<p>Usually there is no need to provide custom write functionality for the messages in consistent state (see <a class="el" href="page_define_prot.html#page_define_prot_message_base_custom_refresh">Custom Refresh Functionality</a>). The default one implemented by <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">comms::MessageBase::doWrite()</a>, which invokes <b>write()</b> member function of every field, is correct. However, if the need arises it is enough just to provide custom <b>doWrite()</b> member function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>SomeMessage : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(...);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">doWrite</a>(TIter&amp; iter, std::size_t len)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        ... </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>Note</b>, that <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> provides the following member functions in order to allow write of the selected fields. </p><ul>
<li><a class="el" href="classcomms_1_1MessageBase.html#a54e6eb8daaf93a8671d3f8e5e0e32f46">comms::MessageBase::doWriteFrom()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#aa8e6848f65ab796a33517c3d48aa78de">comms::MessageBase::doWriteUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#ae11a7be936db0cdce89540264b295619">comms::MessageBase::doWriteFromUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a3385ab7b850a9d3825860be5b303bd6d">comms::MessageBase::doWriteFromAndUpdateLen()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a15eb223527d8d06a853aaf1b3ec2166d">comms::MessageBase::doWriteUntilAndUpdateLen()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a2281fd57ba4d05ac3cd4e15e9f802934">comms::MessageBase::doWriteFromUntilAndUpdateLen()</a></li>
</ul>
<h2><a class="anchor" id="page_define_prot_message_base_custom_length"></a>
Custom Length Calculation</h2>
<p>Just like with <a class="el" href="page_define_prot.html#page_define_prot_message_base_custom_write">Custom Write Functionality</a> providing custom length calculation is usually not required, but if need arises, just provide your own variant of <b>doLength()</b> member function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>SomeMessage : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::size_t <a class="code" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">doLength</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        ... </div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>Note</b>, that <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> provides the following member functions in order to allow length calculation of the selected fields. </p><ul>
<li><a class="el" href="classcomms_1_1MessageBase.html#a60c05d81adc406833e9ead9e4e2c5d51">comms::MessageBase::doLengthFrom()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a869d6398fd3e1ddb298e37927d3f7c35">comms::MessageBase::doLengthUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a21cd333d3fbdb22b7c5386a545a2870d">comms::MessageBase::doLengthFromUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a1d36b0b3b6eec0319a4d8be725a56c52">comms::MessageBase::doMinLengthFrom()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#afdf42c9d15d9cacb72dba9a4742609be">comms::MessageBase::doMinLengthUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#aa967c1d370f4a40a6cb2f4de2f1f0168">comms::MessageBase::doMinLengthFromUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#ab8579127c444abfb0923116b27c53efc">comms::MessageBase::doMaxLengthFrom()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#ac25a2572c9d2ccc74ef764ead6701608">comms::MessageBase::doMaxLengthUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a3ba7e14c08930d6fd0e7f2a354cecb9a">comms::MessageBase::doMaxLengthFromUntil()</a></li>
</ul>
<h2><a class="anchor" id="page_define_prot_message_base_custom_valid"></a>
Custom Validity Check</h2>
<p>The default implementation of <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">comms::MessageBase::doValid()</a> calls <b>valid()</b> member function of every message field and returns <b>true</b> if all the calls returned <b>true</b>. However, there may be a need to provide extra checks in case specific value of one field may require tighter constrains on the value of another. In order to provide custom validity check, just implement custom <b>doValid()</b> member function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>SomeMessage : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">doValid</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Get type of the base class</span></div>
<div class="line">        <span class="keyword">using</span> Base = <span class="keyword">typename</span> std::decay&lt;decltype(<a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*<span class="keyword">this</span>))&gt;::type;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check that all fields are valid by themselves</span></div>
<div class="line">        <span class="keywordflow">if</span> (!Base::doValid()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ... <span class="comment">// do custom validation logic</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="page_define_prot_message_base_name"></a>
Reporting Message Name</h2>
<p>Some application may require printing (or reporting by other means) human readable name of the message. The <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> cannot automatically generate appropriate function. As the result, the message definition class is expected to define <b>doName()</b> member function with the following signature. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>SomeMessage : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* doName()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Some Message&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> In order to support <a class="el" href="page_use_prot.html#page_use_prot_interface_name">Polymorphic Message Name Retrieval</a> there is a need to pass <a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> option to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> to notify the latter about existence of <b>doName()</b> member function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>SomeMessage : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        ...,</div>
<div class="line">        comms::option::def::HasName</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* doName()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Some Message&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> When <a class="el" href="structcomms_1_1option_1_1def_1_1HasName.html">comms::option::def::HasName</a> is used, the <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b> creates overriding <b>nameImpl()</b> (see <a class="el" href="classcomms_1_1MessageBase.html#a4b6888dd9d8d070ac042a13ac48fc334">comms::MessageBase::nameImpl()</a>), which invokes provided <b>doName()</b> member function.</p>
<h2><a class="anchor" id="page_define_prot_message_version"></a>
Protocol Version Support</h2>
<p>As was described earlier in <a class="el" href="page_define_prot.html#page_define_prot_interface_version">Version in Extra Transport Values</a>, some protocols may include version information in either message transport framing or in one of the messages used to establish a connection. Every field defines <b>setVersion()</b> member function in its public interface. The <a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a> class will automatically call this function for every field before performing its <b>read</b> operation (inside <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">comms::MessageBase::doRead()</a>). However, if <a class="el" href="page_define_prot.html#page_define_prot_message_base_custom_read">Custom Read Functionality</a> is implemented, the latter is expected to call provided <a class="el" href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">comms::MessageBase::doFieldsVersionUpdate()</a> member function explicitly before attempting actual read operations. <b>NOTE</b>, that the <a class="el" href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">comms::MessageBase::doFieldsVersionUpdate()</a> function exists only if <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> has been provided to message interface. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">doRead</a>(TIter&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get type of the base class</span></div>
<div class="line">        <span class="keyword">using</span> Base = <span class="keyword">typename</span> std::decay&lt;decltype(<a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*<span class="keyword">this</span>))&gt;::type;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Update version of the fields</span></div>
<div class="line">        Base::doFieldsVersionUpdate();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Do the actual read</span></div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Similarly, the fields' version needs to be updated in case <a class="el" href="page_define_prot.html#page_define_prot_message_base_custom_refresh">Custom Refresh Functionality</a> is implemented. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">doRefresh</a>()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get type of the base class</span></div>
<div class="line">        <span class="keyword">using</span> Base = <span class="keyword">typename</span> std::decay&lt;decltype(<a class="code" href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a>(*<span class="keyword">this</span>))&gt;::type;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update version of the fields</span></div>
<div class="line">        <span class="keywordtype">bool</span> updated = Base::doFieldsVersionUpdate();</div>
<div class="line"> </div>
<div class="line">        ... <span class="comment">// Custom refresh functionality</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> updated;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="page_define_prot_field_aliases"></a>
Aliases to Field Names</h1>
<p>When the communication protocol evolves and new versions of it are being released, it may happen that some fields get renamed to give them a different or refined meaning. Simple change of the name may result in old client code not being able to compile with new versions of the protocol definition library. To help with such case the <b>COMMS</b> library provides several macros that can generate alias names for renamed fields.</p>
<h2><a class="anchor" id="page_define_prot_field_aliases_messages"></a>
Aliases to Field Names Inside Message Definition</h2>
<p>The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> macro, which is expected to be used after <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> one when new message class is being defined. As an example let's change the <b>value3</b> from the example in the <a class="el" href="page_define_prot.html#page_define_prot_message_base_field_names">Providing Names to the Fields</a> section to be <b>newValue3</b>. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(value1, value2, newValue3);</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(value3, newValue3);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> above generates the following alias type as well as convenience access functions: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(value1, value2, newValue3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Alias to the new type</span></div>
<div class="line">    <span class="keyword">using</span> Field_value3 = Field_newValue3;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access to &quot;newValue3&quot; via &quot;value3&quot; name</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() -&gt; decltype(field_newValue3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newValue3();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to &quot;newValue3&quot; via &quot;value3&quot; name</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() const -&gt; decltype(field_newValue3())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newValue3();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> In this case the old client code that tries to access appropriate field using <b>field_value3()</b> access function will still work after renaming takes place.</p>
<p>Another common case is when some field (usually <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> or <a class="el" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>) has a limited range of possible values and in order to save on some I/O traffic, the developer decides to split the value storage into multiple small parts and make it a <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> instead. In order to keep old client code compiling and working the <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> may be used: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(value1, value2, newValue3);</div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS</a>(value3, newValue3, member1);</div>
<div class="line">};</div>
</div><!-- fragment --><p> The usage of <a class="el" href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">COMMS_MSG_FIELD_ALIAS()</a> above generates the following type and convenience access functions: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = comms::MessageBases&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES</a>(value1, value2, newValue3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Alias to the member field</span></div>
<div class="line">    <span class="keyword">using</span> Field_value3 = <span class="keyword">typename</span> Field_newValue3::Field_member1;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Access to &quot;newValue3.member1&quot; via &quot;value3&quot; name</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() -&gt; decltype(field_newValue3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newValue3().field_member1();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to &quot;newValue3.member1&quot; via &quot;value3&quot; name</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() const -&gt; decltype(field_newValue3().field_member1())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> field_newValue3().field_member1();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="page_define_prot_field_aliases_bundles"></a>
Aliases to Field Names Inside Bundle Fields</h2>
<p>Similar to defining aliases to message fields, <b>COMMS</b> library provides an ability to define aliases within <a class="el" href="classcomms_1_1field_1_1Bundle.html">bundle</a> field definition using <a class="el" href="Field_8h.html#a7adc16bdcc59b3f0a646c106816c9cab">COMMS_FIELD_ALIAS()</a> macro. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyBundle : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(member1, member2, member3);</div>
<div class="line">    <a class="code" href="Field_8h.html#a7adc16bdcc59b3f0a646c106816c9cab">COMMS_FIELD_ALIAS</a>(otherMem1Name, member1);</div>
<div class="line">    <a class="code" href="Field_8h.html#a7adc16bdcc59b3f0a646c106816c9cab">COMMS_FIELD_ALIAS</a>(otherMem2Name, member2);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="page_define_prot_field_aliases_interfaces"></a>
Aliases to Extra Transport Field Names Inside Interface</h2>
<p>The <a class="el" href="page_define_prot.html#page_define_prot_interface">Common Interface Class</a> class definition may have <a class="el" href="page_define_prot.html#page_define_prot_interface_extra_transport">Extra Transport Values</a>. Aliasing between the extra transport fields can be defined using <a class="el" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS()</a> macro. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES</a>(<a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>, flags);</div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">COMMS_MSG_TRANSPORT_FIELD_ALIAS</a>(otherFlagsName, flags);    </div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="page_define_prot_lenth_verification"></a>
Extra Compile Time Checks</h1>
<p>Quite often it is obvious from the protocol specification what minimal length of the serialised message contents is expected to be, and if there are not variable length fields, such as <b>string</b> or <b>list</b>, then maximum serialisation length is also known. It would be wise to slip in compile time checks in message definition as well. There are several static constexpr member functions inherited from <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b> that can be used:</p>
<ul>
<li><a class="el" href="classcomms_1_1MessageBase.html#a6e9b89aab4e8cd2e60095f1d6ac9eb40">comms::MessageBase::doMinLength()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#aff048412f531c1d7294a3a96e34e03c0">comms::MessageBase::doMaxLength()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#aa967c1d370f4a40a6cb2f4de2f1f0168">comms::MessageBase::doMinLengthFromUntil()</a> </li>
<li><a class="el" href="classcomms_1_1MessageBase.html#a3ba7e14c08930d6fd0e7f2a354cecb9a">comms::MessageBase::doMaxLengthFromUntil()</a></li>
</ul>
<p>For example, the implementation of <b>Message2</b> may be updated as below: </p><div class="fragment"><div class="line"><span class="comment">// file Message2.h</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message2 : <span class="keyword">public</span> <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base =  <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    static_assert(Base::doMinLength() == 1U, <span class="stringliteral">&quot;Unexpected min length&quot;</span>);</div>
<div class="line">    static_assert(Base::doMaxLength() == 3U, <span class="stringliteral">&quot;Unexpected max length&quot;</span>);</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="page_define_prot_customisation"></a>
Application Specific Customisation</h1>
<p>As was mentioned in <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a>, there may be a need to provide a way for extra application specific customisation for used fields, especially for fields like lists (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>) or strings (<a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a>). By default they use <b>std::vector</b> and <b>std::string</b> respectively as their inner value storage types. They may be un-applicable to some aplications, especially bare-metal ones. In order to solve such problem the message classes are expected to receive extra template parameters, which will be propagated to fields definition.</p>
<p><b>Recommended Practice</b></p>
<p>It is recommended to have a separate class / struct called <b>DefaultOptions</b> wich defines relevant inner types to be <a class="el" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> (option that does nothing). For example, let's assume that third field in <b>Message1</b> message is a string. Then the <b>DefaultOptions</b> struct may be defined as </p><div class="fragment"><div class="line"><span class="keyword">struct </span>DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field3 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>; <span class="comment">// no extra functionality by default</span></div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that inner structure of <b>DefaultOptions</b> in not important, but it is recommended to resemble the full scope of fields, options for which are being prepared. Then the message definition need to be changed to receive and use extra options struct. </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"><span class="preprocessor">#include &quot;DefaultOptions.h&quot;</span> <span class="comment">// Defines DefaultOptions struct</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">struct </span>Message1Fields</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> field1 = ...;</div>
<div class="line">    <span class="keyword">using</span> field2 = ...</div>
<div class="line">    <span class="keyword">using</span> field3 = </div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            <span class="keyword">typename</span> TOpt::message::Message1Fields::field3 <span class="comment">// Extra option(s) </span></div>
<div class="line">        &gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bunding type</span></div>
<div class="line">    <span class="keyword">using</span> All = </div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            field1,</div>
<div class="line">            field2,</div>
<div class="line">            field3</div>
<div class="line">        &gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of the message itself, described and explained later</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&lt;TOpt&gt;::All&gt;,</div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase, TOpt&gt; &gt; </div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> It gives opportunity to the application to define its own single structure of options for all the messages by extending the provided <b>DefaultOptions</b> and overriding selected number inner types with its own extension options.</p>
<p><b>NOTE</b>, that allowing additional customisation for fields like <b>list</b> (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>) and <b>string</b> (<a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a>) is a <b>must have</b> feature to allow usage of the same protocol definition in bare-metal applications. However, it would be wise to allow extra customisation for <b>all</b> the used fields, even for ones like <b>integral values</b> (<a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>) or <b>enum</b> (<a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>). The client application developer may want to change the default value of some field, maybe even add or change (override) provided ranges of valid values, force failing of read operation on invalid values, etc... <b>NOTE</b>, that when allowing such customisation of fields, make sure that passed options are listed before the default ones </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOpts&gt;</div>
<div class="line"><span class="keyword">using</span> MyField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::uint16_t,</div>
<div class="line">        TExtraOpts..., <span class="comment">// extra options</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;10&gt;</a>, <span class="comment">// default value</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;10, 20&gt;</a> <span class="comment">// default range of valid values</span></div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> This is because earlier used options take priority over ones used later.</p>
<p>Depending on the protocol there may be a need to provide additional customisation for messages themselves. For example, when most messages are bi-directional (which will require both read and write operation for every message) except a only a few, that go only one direction (from client to server or the opposite). In this case the generated code will contain implementation for both polymorphic read (<a class="el" href="classcomms_1_1MessageBase.html#a53bf76bcd33967e6fc543480c1643114">comms::MessageBase::readImpl()</a>) and write (<a class="el" href="classcomms_1_1MessageBase.html#a7b58412054c729f562ed1d99fda27fbf">comms::MessageBase::writeImpl()</a>). For uni-directional messages some of these function may be redundant, which unnecessary increases the binary size. It may become a problem for bare-metal platforms with limited amount of ROM space. The <b>COMMS</b> library provides options that may suppress automatic generation of some virtual functions by the <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b>. The available options are: </p><ul>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoReadImpl.html">comms::option::app::NoReadImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoWriteImpl.html">comms::option::app::NoWriteImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoValidImpl.html">comms::option::app::NoValidImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoLengthImpl.html">comms::option::app::NoLengthImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoDispatchImpl.html">comms::option::app::NoDispatchImpl</a></li>
</ul>
<p>These options should not be used in the definition of protocol messages, but it would be wise to allow the client application use them when necessary. It can easily achieved using <b>DefaultOptions</b> structure described earlier. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> Message1 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">        <span class="keyword">using</span> Message2 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">        ...</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p> Add passing these options to message definition classes: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&lt;TOpt&gt;::All&gt;,</div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase, TOpt&gt; &gt;,</div>
<div class="line">        typename TOpt::message::Message1 <span class="comment">// Extra options </span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><h1><a class="anchor" id="page_define_prot_transport_framing"></a>
Transport Framing Definition</h1>
<p>In addition to definition of the messages and their contents, every communication protocol must ensure that the message is successfully delivered over the I/O link to the other side and recognised (based on its ID). The serialised message payload must be wrapped in some kind of transport framing prior to being sent and unwrapped on the other side when received. The <a class="el" href="page_prot_stack_tutorial.html">Protocol Stack Definition Tutorial</a> page contains detailed information on how define such a frame and make it usable to the client application. Note, that the same protocol may be used over multiple I/O link, every one of which may require different framing. There is no limit on amount of different frames that may be defined. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacecomms_html_a0f13fefc26f742c9d1b8715264a116de"><div class="ttname"><a href="namespacecomms.html#a0f13fefc26f742c9d1b8715264a116de">comms::toMessageBase</a></div><div class="ttdeci">MessageBase&lt; TMessage, TOptions... &gt; &amp; toMessageBase(MessageBase&lt; TMessage, TOptions... &gt; &amp;msg)</div><div class="ttdoc">Upcast type of the message object to comms::MessageBase in order to have access to its internal types...</div><div class="ttdef"><b>Definition:</b> MessageBase.h:776</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a45782845d1f24fc957efe1a41fdf32c4"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">comms::MessageBase::doRead</a></div><div class="ttdeci">ErrorStatus doRead(TIter &amp;iter, std::size_t size)</div><div class="ttdoc">Default implementation of read functionality.</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a79e5ec00e39ff64c5f9208813f270468"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">comms::MessageBase::doWrite</a></div><div class="ttdeci">ErrorStatus doWrite(TIter &amp;iter, std::size_t size) const</div><div class="ttdoc">Default implementation of write functionality.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a6da7116040cb3e35912aa4b82a2a66b1"><div class="ttname"><a href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">comms::Message::transportFields</a></div><div class="ttdeci">TransportFields &amp; transportFields()</div><div class="ttdoc">Get access to extra transport fields.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a00912bb201d47afbb0c3e51fff95b338"><div class="ttname"><a href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_NAMES</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_NAMES(...)</div><div class="ttdoc">Provide names for extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:707</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Optional_html"><div class="ttname"><a href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a></div><div class="ttdoc">Adaptor class to any other field, that makes the field optional.</div><div class="ttdef"><b>Definition:</b> Optional.h:44</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_a6bfb15414c84bb8644f05ffa20198515"><div class="ttname"><a href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">comms::option::ReadIterator</a></div><div class="ttdeci">comms::option::app::ReadIterator&lt; TIter &gt; ReadIterator</div><div class="ttdoc">Same as comms::option::app::ReadIterator.</div><div class="ttdef"><b>Definition:</b> options.h:1873</div></div>
<div class="ttc" id="anamespacecomms_1_1field_html_ab1a00acfb597ac892cc9d5a73740ad9ea2aee0be2678ee90fd327cc186826438e"><div class="ttname"><a href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2aee0be2678ee90fd327cc186826438e">comms::field::OptionalMode::Missing</a></div><div class="ttdeci">@ Missing</div><div class="ttdoc">Field doesn't exist.</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a25cd34ed5b338241067433c45d7345ac"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">comms::MessageBase::COMMS_MSG_FIELDS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_FIELDS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to message fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:811</div></div>
<div class="ttc" id="aprotocols_8h_html"><div class="ttname"><a href="protocols_8h.html">protocols.h</a></div></div>
<div class="ttc" id="aField_8h_html_af74198f06b52d3f58c92e795b2ff7129"><div class="ttname"><a href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a></div><div class="ttdeci">#define COMMS_FIELD_MEMBERS_NAMES(...)</div><div class="ttdoc">Provide names for member fields of composite fields, such as comms::field::Bundle or comms::field::Bi...</div><div class="ttdef"><b>Definition:</b> Field.h:372</div></div>
<div class="ttc" id="anamespacecomms_1_1option_1_1def_html_a606d8afcd788b9c39088709e9be2f546"><div class="ttname"><a href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a></div><div class="ttdeci">Endian&lt; comms::traits::endian::Big &gt; BigEndian</div><div class="ttdoc">Alias option to Endian specifying Big endian.</div><div class="ttdef"><b>Definition:</b> options.h:177</div></div>
<div class="ttc" id="aMessageBase_8h_html"><div class="ttname"><a href="MessageBase_8h.html">MessageBase.h</a></div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a6d36881b8fea2fa53cc8e17a1e82df27"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">comms::MessageBase::doLength</a></div><div class="ttdeci">std::size_t doLength() const</div><div class="ttdoc">Default implementation of length calculation functionality.</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_aa2401dbc73075e26591fa9459745678f"><div class="ttname"><a href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">comms::option::VersionType</a></div><div class="ttdeci">comms::option::def::VersionType&lt; T &gt; VersionType</div><div class="ttdoc">Same as comms::option::def::VersionType.</div><div class="ttdef"><b>Definition:</b> options.h:1835</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_afcb3077fb16f36d4710effc4d61a1330"><div class="ttname"><a href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">comms::MessageBase::doValid</a></div><div class="ttdeci">bool doValid() const</div><div class="ttdoc">Default implementation of validity check functionality.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_adfa416afa2a8a77af9c46b42d3034f3e"><div class="ttname"><a href="classcomms_1_1Message.html#adfa416afa2a8a77af9c46b42d3034f3e">comms::Message::COMMS_MSG_TRANSPORT_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for extra member transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:836</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition:</b> ErrorStatus.h:17</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html"><div class="ttname"><a href="classcomms_1_1MessageBase.html">comms::MessageBase</a></div><div class="ttdoc">Base class for all the custom protocol messages.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:79</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1MsgType_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1MsgType.html">comms::option::def::MsgType</a></div><div class="ttdoc">Option used to specify actual type of the message.</div><div class="ttdef"><b>Definition:</b> options.h:202</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1StaticNumIdImpl_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1StaticNumIdImpl.html">comms::option::def::StaticNumIdImpl</a></div><div class="ttdoc">Option used to specify numeric ID of the message.</div><div class="ttdef"><b>Definition:</b> options.h:193</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_a7cab23e160841f8b640b5afeccd8b664"><div class="ttname"><a href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::EmptyOption</a></div><div class="ttdeci">comms::option::app::EmptyOption EmptyOption</div><div class="ttdoc">Same as comms::option::app::EmptyOption.</div><div class="ttdef"><b>Definition:</b> options.h:1869</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a5ad5c5b59d08590aba3b1e97f4e8149c"><div class="ttname"><a href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">comms::Message::version</a></div><div class="ttdeci">VersionType &amp; version()</div><div class="ttdoc">Access to version information.</div></div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition:</b> Field.h:32</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_ada784673f02d483a88fcf0c451cb72bd"><div class="ttname"><a href="classcomms_1_1Message.html#ada784673f02d483a88fcf0c451cb72bd">comms::Message::COMMS_MSG_TRANSPORT_FIELDS_ACCESS</a></div><div class="ttdeci">#define COMMS_MSG_TRANSPORT_FIELDS_ACCESS(...)</div><div class="ttdoc">Add convenience access enum and functions to extra transport fields.</div><div class="ttdef"><b>Definition:</b> Message.h:566</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdoc">Used to indicate successful outcome of the operation.</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a43c008e2ba360d9dd4917a1c9f80bd38"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a43c008e2ba360d9dd4917a1c9f80bd38">comms::MessageBase::COMMS_MSG_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_MSG_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias types and access member functions for other member fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:1081</div></div>
<div class="ttc" id="aGenericHandler_8h_html"><div class="ttname"><a href="GenericHandler_8h.html">GenericHandler.h</a></div></div>
<div class="ttc" id="aMsgFactory_8h_html"><div class="ttname"><a href="MsgFactory_8h.html">MsgFactory.h</a></div></div>
<div class="ttc" id="anamespacecomms_html_a124576497d233cf87eb7432190e6c9fe"><div class="ttname"><a href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">comms::version</a></div><div class="ttdeci">constexpr unsigned version()</div><div class="ttdoc">Version of the COMMS library as single numeric value.</div><div class="ttdef"><b>Definition:</b> version.h:64</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html"><div class="ttname"><a href="classcomms_1_1Message.html">comms::Message</a></div><div class="ttdoc">Main interface class for all the messages.</div><div class="ttdef"><b>Definition:</b> Message.h:79</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_af4b8bc4b6db684d0006d2c6c70b1e891"><div class="ttname"><a href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields</a></div><div class="ttdeci">AllFields &amp; fields()</div><div class="ttdoc">Get an access to the fields of the message.</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ContentsValidator_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a></div><div class="ttdoc">Option that specifies custom validation class.</div><div class="ttdef"><b>Definition:</b> options.h:654</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a></div><div class="ttdoc">Bitmask value field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:101</div></div>
<div class="ttc" id="afields_8h_html"><div class="ttname"><a href="fields_8h.html">fields.h</a></div></div>
<div class="ttc" id="aunits_8h_html"><div class="ttname"><a href="units_8h.html">units.h</a></div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FixedLength_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a></div><div class="ttdoc">Option used to specify number of bytes that is used for field serialisation.</div><div class="ttdef"><b>Definition:</b> options.h:275</div></div>
<div class="ttc" id="aField_8h_html_a7adc16bdcc59b3f0a646c106816c9cab"><div class="ttname"><a href="Field_8h.html#a7adc16bdcc59b3f0a646c106816c9cab">COMMS_FIELD_ALIAS</a></div><div class="ttdeci">#define COMMS_FIELD_ALIAS(f_,...)</div><div class="ttdoc">Generate convinience alias access member functions for other member fields.</div><div class="ttdef"><b>Definition:</b> Field.h:382</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1DefaultValueInitialiser_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a></div><div class="ttdoc">Option that specifies default initialisation class.</div><div class="ttdef"><b>Definition:</b> options.h:610</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a2feb6d8948de99eef4213a234625d3ec"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">comms::MessageBase::doRefresh</a></div><div class="ttdeci">bool doRefresh() const</div><div class="ttdoc">Default implementation of refreshing functionality.</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bundle_html"><div class="ttname"><a href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a></div><div class="ttdoc">Bundles multiple fields into a single field.</div><div class="ttdef"><b>Definition:</b> Bundle.h:75</div></div>
<div class="ttc" id="acomms_8h_html"><div class="ttname"><a href="comms_8h.html">comms.h</a></div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ValidNumValueRange_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a></div><div class="ttdoc">Provide range of valid numeric values.</div><div class="ttdef"><b>Definition:</b> options.h:1040</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1String_html"><div class="ttname"><a href="classcomms_1_1field_1_1String.html">comms::field::String</a></div><div class="ttdoc">Field that represents a string.</div><div class="ttdef"><b>Definition:</b> String.h:160</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1MsgIdType_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a></div><div class="ttdoc">Option used to specify type of the ID.</div><div class="ttdef"><b>Definition:</b> options.h:187</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FieldsImpl_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FieldsImpl.html">comms::option::def::FieldsImpl</a></div><div class="ttdoc">Option used to specify fields of the message and force implementation of default read,...</div><div class="ttdef"><b>Definition:</b> options.h:229</div></div>
<div class="ttc" id="anamespacecomms_1_1field_html_ab1a00acfb597ac892cc9d5a73740ad9ea2a8eb028670e972535e8e246be645821"><div class="ttname"><a href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2a8eb028670e972535e8e246be645821">comms::field::OptionalMode::Exists</a></div><div class="ttdeci">@ Exists</div><div class="ttdoc">Field must exist.</div></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html_a2c70987da383935a4cf0ceb5228f497a"><div class="ttname"><a href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">comms::MessageBase::COMMS_MSG_FIELDS_NAMES</a></div><div class="ttdeci">#define COMMS_MSG_FIELDS_NAMES(...)</div><div class="ttdoc">Provide names for message fields.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:963</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a></div><div class="ttdoc">Field that represent integral value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:72</div></div>
<div class="ttc" id="aMessage_8h_html"><div class="ttname"><a href="Message_8h.html">Message.h</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
