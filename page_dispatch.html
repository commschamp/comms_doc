<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: Advanced Guide to Message Dispatching</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Advanced Guide to Message Dispatching </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#page_dispatch_message_object">Dispatch of the Message Object</a><ul><li class="level2"><a href="#page_dispatch_message_object_polymorphic">Polymorphic</a></li>
<li class="level2"><a href="#page_dispatch_message_object_static_bin_search">Static Binary Search</a></li>
<li class="level2"><a href="#page_dispatch_message_object_linear_switch">Linear Switch</a></li>
<li class="level2"><a href="#page_dispatch_message_object_default">Default Way to Dispatch</a></li>
</ul>
</li>
<li class="level1"><a href="#page_dispatch_message_type">Dispatch of the Message Type</a><ul><li class="level2"><a href="#page_dispatch_message_type_polymorphic">Polymorphic</a></li>
<li class="level2"><a href="#page_dispatch_message_type_static_bin_search">Static Binary Search</a></li>
<li class="level2"><a href="#page_dispatch_message_type_linear_switch">Linear Switch</a></li>
<li class="level2"><a href="#page_dispatch_message_type_default">Default Way to Dispatch</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The <a class="el" href="page_use_prot.html#page_use_prot_handling">Message Handling</a> section of the <a class="el" href="page_use_prot.html">How to Use Defined Custom Protocol</a> page describes a basic way to dispatch message object (held by a pointer to the main interface class) to its handling function. The described approach requires support for <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>. However, since version <b>v1.1</b> the <b>COMMS</b> library supports other multiple ways to dispatch a message even if its interface doesn't define polymorphic <b>dispatch()</b> member function.</p>
<h1><a class="anchor" id="page_dispatch_message_object"></a>
Dispatch of the Message Object</h1>
<p>The handler for the message object is expected to look exactly the same as described in <a class="el" href="page_use_prot.html#page_use_prot_handling">Message Handling</a>, i.e. to define <b>handle()</b> member function for every actual message type it intends to handle, <b>handle()</b> member function for the interface type for the ones it doesn't, and define <b>RetType</b> type to specify return type of the handling functions in case it's not <b>void</b>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Return type of all the handle() functions</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">bool</span> RetType;</div><div class="line"></div><div class="line">    <span class="comment">// All messages to handle properly</span></div><div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg) {...}</div><div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg) {...}</div><div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message3&lt;MyMessage&gt;&amp; msg) {...}</div><div class="line">    ...</div><div class="line">    <span class="comment">// All other (don&#39;t care) messages</span></div><div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::MyMessage&amp; msg) {...}</div><div class="line">};</div></div><!-- fragment --><p> There are several different implemented ways to dispatch a message object, held by a pointer to its interface class, to its appropriate handling function. </p><ul>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_object_polymorphic">Polymorphic</a> </li>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_object_static_bin_search">Static Binary Search</a> </li>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_object_linear_switch">Linear Switch</a></li>
</ul>
<p>Every way has its advantages and disadvantages, please read on and choose one that suites your needs. There are some definition commonly used for all the examples below.</p>
<p>All the mentioned below dispatch functions are defined in <b><a class="el" href="dispatch_8h.html">comms/dispatch.h</a></b> header. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dispatch_8h.html">comms/dispatch.h</a>&quot;</span></div></div><!-- fragment --><p>The used name for the common interface class (see <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a>) is going to be <b>MyMessage</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div></div><!-- fragment --><p>The message types that need to be supported are bundled in <b>std::tuple</b> and named <b>AllMessages</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message3&lt;MyMessage&gt;,</div><div class="line">        ...</div><div class="line">    &gt;;</div></div><!-- fragment --><p> Also let's assume that numeric ID of <b>Message1</b> is <b>1</b>, of <b>Message2</b> is <b>2</b>, of <b>Message90</b> is <b>90</b>, and so on...</p>
<h2><a class="anchor" id="page_dispatch_message_object_polymorphic"></a>
Polymorphic</h2>
<p>The <b>polymorphic</b> dispatch of the message object can look like this </p><div class="fragment"><div class="line"><span class="comment">// Numeric ID of the message object</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = ...</div><div class="line"></div><div class="line"><span class="comment">// Message object itself held by a pointer to MyMessage interface class</span></div><div class="line">MsgPtr msg = ...</div><div class="line"></div><div class="line"><span class="comment">// Handler object</span></div><div class="line">MyHandler handler;</div><div class="line"></div><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(id, *msg, handler);</div></div><!-- fragment --><p> At first, the <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a> function will check (at <b>compile time</b>) whether the message object can be dispatched to the handler <b>directly</b>, i.e. the <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a> is supported in the interface and the used <em>handler</em> is of a suitable type. If this is the case, the dispatch will be performed using the following call </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> msg.dispath(handler);</div></div><!-- fragment --><p> In case the direct dispatch is not possible, the <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a> function will analyze the provided tuple of message types (<b>AllMessages</b>) at <b>compile time</b> and generate appropriate global static dispatch tables (initialized before call to <b>main()</b>).</p>
<p>In case the numeric ID are sequential and unique with no more than 10% of the gaps (the ID of the last message is not greater than number of message types in the provided tuple multiplied by 1.1), the generated dispatch tables and logic provide O(1) runtime complexity to dispatch message object into appropriate handler.</p>
<p>The generated table is just an array of pointers to a dispatch method class equivalent to the code below </p><div class="fragment"><div class="line"><span class="keyword">struct </span>DispatchMethod</div><div class="line">{</div><div class="line">    <span class="keyword">virtual</span> RetType dispatch(MyMessage&amp; msg, MyHandler&amp; handler) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Dispatch registry</span></div><div class="line">std::array&lt;const DispatchMethod*, MaxId + 1&gt; DispatchRegistry;</div></div><!-- fragment --><p> Every pointer to the array is to a global instantiation of the class below for every type in the provided tuple. </p><div class="fragment"><div class="line">&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div><div class="line"><span class="keyword">struct </span>DispatchMethodImpl : <span class="keyword">public</span> DispatchMethod</div><div class="line">{</div><div class="line">    <span class="keyword">virtual</span> RetType dispatch(MyMessage&amp; msg, MyHandler&amp; handler)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> handler.handle(static_cast&lt;TMessage&amp;&gt;(msg));</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The code inside the <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a> function will use the message ID as an index to access the registry array and invoke the virtual <b>dispatch()</b> method. In case the accessed cell is empty, the downcasting to the right message type won't occur and <b>handle()</b> message for the interface of the handler object will be invoked.</p>
<p>In case the IDs of the message types in the provided tuple are too sparse, The registry array will be packed (no holes inside) and binary search using <b>std::lower_bound</b> algorithm is going to be performed. In this case the <b>DispatchMethod</b> class will also report an ID of the message it is responsible to handle via virtual function. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>DispatchMethod</div><div class="line">{</div><div class="line">    <span class="keyword">virtual</span> MsgIdParamType getId() <span class="keyword">const</span> = 0;</div><div class="line">    <span class="keyword">virtual</span> RetType dispatch(MyMessage&amp; msg, MyHandler&amp; handler) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line">&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div><div class="line"><span class="keyword">struct </span>DispatchMethodImpl : <span class="keyword">public</span> DispatchMethod</div><div class="line">{</div><div class="line">    <span class="keyword">virtual</span> MsgIdParamType getId()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> TMessage::doGetId();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> RetType dispatch(MyMessage&amp; msg, MyHandler&amp; handler)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> handler.handle(static_cast&lt;TMessage&amp;&gt;(msg);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that the performed binary search will invoke O(log(n)) times the virtual <b>getId()</b> member function to find the appropriate dispatch method and then invoke virtual <b>dispatch()</b> one to downcast the message type and invoke appropriate <b>handle()</b> member function of the handler.</p>
<p>There can also be a case when some message has multiple forms, that implemented as different message classes, but which share the same ID. For example </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;, <span class="comment">// Has ID 1</span></div><div class="line">        Message2&lt;MyMessage&gt;, <span class="comment">// Has ID 2</span></div><div class="line">        Message90_1&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">        Message90_2&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">    &gt;;</div></div><!-- fragment --><p> To support such case, the <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a> function is overloaded with new <b>index</b> parameter (which is index (or offset) starting from the first type in the tuple with the requested ID) to allow selection to what type to downcast </p><div class="fragment"><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(90, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(90, 0, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(90, 1, msg, handler); <span class="comment">// Invokes handle(Message90_2&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(90, 2, msg, handler); <span class="comment">// Out of range - invokes handle(MyMessage&amp;)</span></div></div><!-- fragment --><p>There is also an overload to <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a>, which doesn't receive any numeric message ID </p><div class="fragment"><div class="line">comms::dispatchMsgPolymorphic&lt;AllMessages&gt;(msg, handler);</div></div><!-- fragment --><p> Such call checks (at compile time) whether the message interface provides polymorphic dispatch (see <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>). If this is the case, then it is used to dispatch the message to the handler. If not, then the message interface definition (<b>MyMessage</b>) must provide <a class="el" href="page_use_prot.html#page_use_prot_interface_id_retrieve">Polymorphic Retrieval of Message ID</a> to be able to retrieve ID of the message object.</p>
<p><b>SUMMARY:</b> The runtime complexity of <b>polymorphic</b> dispatch can be O(1) in case the numeric IDs of the supported message types in the provided tuple are <b>NOT</b> too sparse (no more than 10% holes). If this is not the case the runtime complexity is O(log(n)) with multiple virtual function calls to retrieve the ID of the dispatching method. Also the downside of the <b>polymorphic</b> dispatch is an amount of various v-tables the compiler will have to generate, which can significantly increase the code size. It can be a problem for various embedded systems with limited ROM.</p>
<h2><a class="anchor" id="page_dispatch_message_object_static_bin_search"></a>
Static Binary Search</h2>
<p>The <b>static binary search</b> dispatch of the message object can look like this </p><div class="fragment"><div class="line"><span class="comment">// Numeric ID of the message object</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = ...</div><div class="line"></div><div class="line"><span class="comment">// Message object itself held by a pointer to MyMessage interface class</span></div><div class="line">MsgPtr msg = ...</div><div class="line"></div><div class="line"><span class="comment">// Handler object</span></div><div class="line">MyHandler handler;</div><div class="line"></div><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(id, *msg, handler);</div></div><!-- fragment --><p> The <a class="el" href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">comms::dispatchMsgStaticBinSearch()</a> function generates the code equivalent to having the following folded if statements where <b>N</b> is number of message types </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keywordtype">id</span> &lt; id_of_elem(N/2)) {</div><div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &lt; id_of_elem(N/4)) {</div><div class="line">        ...</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt; id_of_elem(N/4)) {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">return</span> handler.handle(static_cast&lt;...&gt;(msg)); <span class="comment">// cast to appropriate type</span></div><div class="line">    }</div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt; id_of_elem(N/2)) {</div><div class="line">    <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &lt; id_of_elem(3N/4)) {</div><div class="line">        ...</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt; id_of_elem(3N/4)) {</div><div class="line">        ...</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">return</span> handler.handle(static_cast&lt;...&gt;(msg)); <span class="comment">// cast to appropriate type</span></div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> handler.handle(static_cast&lt;...&gt;(msg)); <span class="comment">// cast to appropriate type</span></div><div class="line">}</div></div><!-- fragment --><p> The runtime complexity of such code is always O(log(n)) and there are no extra v-tables and virtual functions involved.</p>
<p>In case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is provided (similar to described earlier <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a>). </p><div class="fragment"><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(90, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(90, 0, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(90, 1, msg, handler); <span class="comment">// Invokes handle(Message90_2&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(90, 2, msg, handler); <span class="comment">// Out of range - invokes handle(MyMessage&amp;)</span></div></div><!-- fragment --><p>There is also an overload to <a class="el" href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">comms::dispatchMsgStaticBinSearch()</a>, which doesn't receive any numeric message ID </p><div class="fragment"><div class="line">comms::dispatchMsgStaticBinSearch&lt;AllMessages&gt;(msg, handler);</div></div><!-- fragment --><p> Such call requires the message interface definition (<b>MyMessage</b>) to provide <a class="el" href="page_use_prot.html#page_use_prot_interface_id_retrieve">Polymorphic Retrieval of Message ID</a> to be able to retrieve ID of the message object.</p>
<p><b>SUMMARY:</b> The runtime complexity of the <b>static binary search</b> dispatch is always O(log(n)) regardless of how sparse or compact are IDs of the message types in the provided tuple. There are also no v-tables generated by the compiler.</p>
<h2><a class="anchor" id="page_dispatch_message_object_linear_switch"></a>
Linear Switch</h2>
<p>The <b>linear switch</b> dispatch of the message object can look like this </p><div class="fragment"><div class="line"><span class="comment">// Numeric ID of the message object</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = ...</div><div class="line"></div><div class="line"><span class="comment">// Message object itself held by a pointer to MyMessage interface class</span></div><div class="line">MsgPtr msg = ...</div><div class="line"></div><div class="line"><span class="comment">// Handler object</span></div><div class="line">MyHandler handler;</div><div class="line"></div><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(id, *msg, handler);</div></div><!-- fragment --><p> The <a class="el" href="namespacecomms.html#ad73708f2fe7ad6c62b9294106dd44fe5">comms::dispatchMsgLinearSwitch()</a> function generates the code equivalent to having the following folded switch statements. </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (<span class="keywordtype">id</span>) {</div><div class="line">    <span class="keywordflow">case</span> id_of_elem(0):</div><div class="line">        return handler.handle(static_cast&lt;...&gt;(msg)); <span class="comment">// cast to appropriate type</span></div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>) {</div><div class="line">            <span class="keywordflow">case</span> id_of_elem(1):</div><div class="line">                return handler.handle(static_cast&lt;...&gt;(msg)); <span class="comment">// cast to appropriate type         </span></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">                ...</div><div class="line">        };</div><div class="line">};</div></div><!-- fragment --><p> The runtime complexity of depends on the compiler being used. It has been noticed that <b>clang</b> starting from v3.9 generates efficient dispatch table with O(1) complexity when binary code is optimized for speed (<b>-O2</b> ). Other main compilers, such as <b>gcc</b> and <b>MSVC</b> generate sequential comparison statements with O(n) runtime complexity.</p>
<p>In case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is provided (similar to described earlier <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a>, and <a class="el" href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">comms::dispatchMsgStaticBinSearch()</a>). </p><div class="fragment"><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(90, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(90, 0, msg, handler); <span class="comment">// Invokes handle(Message90_1&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(90, 1, msg, handler); <span class="comment">// Invokes handle(Message90_2&lt;MyMessage&gt;&amp;)</span></div><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(90, 2, msg, handler); <span class="comment">// Out of range - invokes handle(MyMessage&amp;)</span></div></div><!-- fragment --><p> There is also an overload to <a class="el" href="namespacecomms.html#ad73708f2fe7ad6c62b9294106dd44fe5">comms::dispatchMsgLinearSwitch()</a>, which doesn't receive any numeric message ID </p><div class="fragment"><div class="line">comms::dispatchMsgLinearSwitch&lt;AllMessages&gt;(msg, handler);</div></div><!-- fragment --><p> Such call requires the message interface definition (<b>MyMessage</b>) to provide <a class="el" href="page_use_prot.html#page_use_prot_interface_id_retrieve">Polymorphic Retrieval of Message ID</a> to be able to retrieve ID of the message object.</p>
<p><b>SUMMARY:</b> The usage of <b>linear switch</b> dispatch is there for real "stuntmen". If you are using <b>clang</b> compiler, able and willing to analyze generated binary code, and require optimal performance, then consider using <b>linear switch</b> dispatch. For all other cases its usage is not recommended.</p>
<h2><a class="anchor" id="page_dispatch_message_object_default"></a>
Default Way to Dispatch</h2>
<p>The <b>COMMS</b> library also provides a default way to dispatch message object without specifying type of the dispatch and allowing the library to choose the best one (see <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a>). </p><div class="fragment"><div class="line"><span class="comment">// Numeric ID of the message object</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = ...</div><div class="line"></div><div class="line"><span class="comment">// Message object itself held by a pointer to MyMessage interface class</span></div><div class="line">MsgPtr msg = ...</div><div class="line"></div><div class="line"><span class="comment">// Handler object</span></div><div class="line">MyHandler handler;</div><div class="line"></div><div class="line">comms::dispatchMsg&lt;AllMessages&gt;(id, *msg, handler);</div></div><!-- fragment --><p> In such case the <b>COMMS</b> library will check whether the direct invocation over <b>dispatch()</b> member function exposed by the message interface class is possible (see <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>) or the condition of O(1) <b>polymorphic</b> dispatch tables holds true (no more than 10% holes in the used IDs) and use <b>polymorphic</b> dispatch in this case. Otherwise <b>static binary search</b> one will be used.</p>
<p>In case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is provided similar to other dispatch methods described above. </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages1 = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message3&lt;MyMessage&gt;</div><div class="line">    &gt;;</div><div class="line">comms::dispatchMsg&lt;AllMessages1&gt;(1, msg, handler); <span class="comment">// Equivalent to using comms::dispatchMsgPolymorphic()</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> AllMessages2 = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message90_1&lt;MyMessage&gt;</div><div class="line">    &gt;;</div><div class="line">comms::dispatchMsg&lt;AllMessages2&gt;(1, msg, handler); <span class="comment">// Equivalent to using comms::dispatchMsgStaticBinSearch()</span></div></div><!-- fragment --><p> To verify what dispatch policy is being used the <b>COMMS</b> library provides <b>compile time</b> inquiry functions <a class="el" href="namespacecomms.html#a0616720714175c82e10a6725d62393a5">comms::dispatchMsgIsPolymorphic()</a> and <a class="el" href="namespacecomms.html#a61c7f05f508ffaa6e3de6c7249c7f607">comms::dispatchMsgIsStaticBinSearch()</a> for that purpose. </p><div class="fragment"><div class="line">static_assert(comms::dispatchMsgIsPolymorphic&lt;AllMessages1, MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line">static_assert(!comms::dispatchMsgIsStaticBinSearch&lt;AllMessages1, MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line"></div><div class="line">static_assert(!comms::dispatchMsgIsPolymorphic&lt;AllMessages2, MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line">static_assert(comms::dispatchMsgIsStaticBinSearch&lt;AllMessages2, MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div></div><!-- fragment --><p> In case <b>MyMessage</b> interface class defines <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a> functionality, the "polymorphic" dispatch method will always be chosen. </p><div class="fragment"><div class="line">static_assert(comms::dispatchMsgIsPolymorphic&lt;AllMessages1, MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div></div><!-- fragment --><p> There is a <a class="el" href="namespacecomms.html#a0c2c64f47246460f460f2b7c7d3031df">dispatchMsgIsDirect()</a> compile time check that can be used to verify that the direct dispatch actually being used: </p><div class="fragment"><div class="line">static_assert(comms::dispatchMsgIsDirect&lt;MyMessage, MyHandler&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="page_dispatch_message_type"></a>
Dispatch of the Message Type</h1>
<p>In some occasions there is a need to know the exact message type given the numeric ID without having any message object present for dispatching. The classic example would be the creation of message object itself given the ID (that's what <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a> class does). To support such cases the <b>COMMS</b> library provides the same 3 types of dispatching the given ID to its appropriate type. </p><ul>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_type_polymorphic">Polymorphic</a> </li>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_type_static_bin_search">Static Binary Search</a> </li>
<li><a class="el" href="page_dispatch.html#page_dispatch_message_type_linear_switch">Linear Switch</a></li>
</ul>
<p>For type dispatching the handler object is expected to look a bit different. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div><div class="line">    <span class="keywordtype">void</span> handle() {...}</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that the actual type is passed to the <b>handle()</b> member function as a template parameter. If some types require special handling function, please use template specialization, like in the example below. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div><div class="line"><span class="keyword">struct </span>MyHandlerHelper</div><div class="line">{</div><div class="line">    <span class="comment">// Generic handling function</span></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> handle() {...}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>MyHandlerHelper&lt;my_protocol::Message1&lt;MyMessage&gt; &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Special handling function for my_protocol::Message1&lt;MyMessage&gt;</span></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> handle() {...}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">struct </span>MyHandlerHelper&lt;my_protocol::Message2&lt;MyMessage&gt; &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Special handling function for my_protocol::Message2&lt;MyMessage&gt;</span></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> handle() {...}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyHandler</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div><div class="line">    <span class="keywordtype">void</span> handle()</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> MyHandlerHelper&lt;TMessage&gt;::handle();</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Similar to <a class="el" href="page_dispatch.html#page_dispatch_message_object">Dispatch of the Message Object</a> all the mentioned below dispatch functions are defined in <b><a class="el" href="dispatch_8h.html">comms/dispatch.h</a></b> header. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dispatch_8h.html">comms/dispatch.h</a>&quot;</span></div></div><!-- fragment --><p>The message types that need to be supported are bundled in <b>std::tuple</b> and named <b>AllMessages</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message3&lt;MyMessage&gt;,</div><div class="line">        ...</div><div class="line">    &gt;;</div></div><!-- fragment --><p> All the type <b>dispatchMsgType*</b>() methods described below return <b>bool</b> which in case of being <b>true</b> indicates that the type was successfully found and appropriate <b>handle()</b> member function of the handler object being called. The return of <b>false</b> indicates that the appropriate type hasn't been provided in <b>AllMessages</b> tuple.</p>
<h2><a class="anchor" id="page_dispatch_message_type_polymorphic"></a>
Polymorphic</h2>
<p>Just like with <a class="el" href="page_dispatch.html#page_dispatch_message_object_polymorphic">Polymorphic</a> dispatch of the message object, <b>polymorphic</b> dispatch of the message type generates similar dispatch tables with virtual functions for O(1) or O(log(n)) runtime complexity depending on how sparse the IDs in the provided tuple are. </p><div class="fragment"><div class="line">MyHandler handler;</div><div class="line"><span class="keywordtype">bool</span> typeFound = dispatchMsgTypePolymorphic&lt;AllMessages&gt;(id, handler);</div></div><!-- fragment --><p> Please see <a class="el" href="namespacecomms.html#a59f40a3a8b3c14678fa6335a36539b03">comms::dispatchMsgTypePolymorphic()</a> for reference.</p>
<p>Please note, that in case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is also provided. </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;, <span class="comment">// Has ID 1</span></div><div class="line">        Message2&lt;MyMessage&gt;, <span class="comment">// Has ID 2</span></div><div class="line">        Message90_1&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">        Message90_2&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(1, handler); <span class="comment">// returns true</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(1, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(1, 1, handler); <span class="comment">// returns false</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(90, handler); <span class="comment">// returns true, handles Message90_1&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(90, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(90, 1, handler); <span class="comment">// returns true, handles Message90_2&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypePolymorphic&lt;AllMessages&gt;(90, 2, handler); <span class="comment">// returns false</span></div></div><!-- fragment --><h2><a class="anchor" id="page_dispatch_message_type_static_bin_search"></a>
Static Binary Search</h2>
<p>Similar to <a class="el" href="page_dispatch.html#page_dispatch_message_object_static_bin_search">Static Binary Search</a> dispatch of the message object, <b>static binary search</b> dispatch of the message type generates code equivalent to mentioned folded <b>if</b> statements with O(log(n)) runtime complexity. </p><div class="fragment"><div class="line">MyHandler handler;</div><div class="line"><span class="keywordtype">bool</span> typeFound = dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(id, handler);</div></div><!-- fragment --><p> Please see <a class="el" href="namespacecomms.html#af051115c21a00a6502177712cf2e63cb">comms::dispatchMsgTypeStaticBinSearch()</a> for reference.</p>
<p>Please note, that in case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is also provided. </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;, <span class="comment">// Has ID 1</span></div><div class="line">        Message2&lt;MyMessage&gt;, <span class="comment">// Has ID 2</span></div><div class="line">        Message90_1&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">        Message90_2&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(1, handler); <span class="comment">// returns true</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(1, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(1, 1, handler); <span class="comment">// returns false</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(90, handler); <span class="comment">// returns true, handles Message90_1&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(90, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(90, 1, handler); <span class="comment">// returns true, handles Message90_2&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypeStaticBinSearch&lt;AllMessages&gt;(90, 2, handler); <span class="comment">// returns false</span></div></div><!-- fragment --><h2><a class="anchor" id="page_dispatch_message_type_linear_switch"></a>
Linear Switch</h2>
<p>Similar to <a class="el" href="page_dispatch.html#page_dispatch_message_object_linear_switch">Linear Switch</a> dispatch of the message object, <b>linear switch</b> dispatch of the message type generates code equivalent to mentioned folded <b>switch</b> statements with O(1) runtime complexity when compiled with <b>clang</b> compiler <b>v3.9</b> and above, and O(n) runtime complexity for other major compilers. </p><div class="fragment"><div class="line">MyHandler handler;</div><div class="line"><span class="keywordtype">bool</span> typeFound = dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(id, handler);</div></div><!-- fragment --><p> Please see <a class="el" href="namespacecomms.html#a5ca49c981c039de029515c9f7398cef4">comms::dispatchMsgTypeLinearSwitch()</a> for reference.</p>
<p>Please note, that in case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is also provided. </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;, <span class="comment">// Has ID 1</span></div><div class="line">        Message2&lt;MyMessage&gt;, <span class="comment">// Has ID 2</span></div><div class="line">        Message90_1&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">        Message90_2&lt;MyMessage&gt;, <span class="comment">// Has ID 90</span></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(1, handler); <span class="comment">// returns true</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(1, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(1, 1, handler); <span class="comment">// returns false</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(90, handler); <span class="comment">// returns true, handles Message90_1&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(90, 0, handler); <span class="comment">// returns true, same as above</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(90, 1, handler); <span class="comment">// returns true, handles Message90_2&lt;MyMessage&gt;</span></div><div class="line">dispatchMsgTypeLinearSwitch&lt;AllMessages&gt;(90, 2, handler); <span class="comment">// returns false</span></div></div><!-- fragment --><h2><a class="anchor" id="page_dispatch_message_type_default"></a>
Default Way to Dispatch</h2>
<p>The <b>COMMS</b> library also provides a default way to dispatch message type without specifying type of the dispatch and allowing the library to choose the best one (see <a class="el" href="namespacecomms.html#ae6afbd722340e3bf0d18054bdab484cd">comms::dispatchMsgType()</a>). </p><div class="fragment"><div class="line"><span class="comment">// Numeric ID of the message object</span></div><div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = ...</div><div class="line"></div><div class="line"><span class="comment">// Handler object</span></div><div class="line">MyHandler handler;</div><div class="line"></div><div class="line">comms::dispatchMsgType&lt;AllMessages&gt;(id, handler);</div></div><!-- fragment --><p> In such case the <b>COMMS</b> library will check whether the condition of O(1) <b>polymorphic</b> dispatch tables holds true (no more than 10% holes in the used IDs) and use <b>polymorphic</b> dispatch in this case. Otherwise <b>static binary search</b> one will be used.</p>
<p>In case there are distinct message types with the same numeric ID (multiple forms of the same message), the overloaded function with extra <b>index</b> parameter is provided similar to other dispatch methods described above. </p><div class="fragment"><div class="line"><span class="keyword">using</span> AllMessages1 = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message3&lt;MyMessage&gt;</div><div class="line">    &gt;;</div><div class="line">comms::dispatchMsgType&lt;AllMessages1&gt;(1, handler); <span class="comment">// Equivalent to using comms::dispatchMsgTypePolymorphic()</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> AllMessages2 = </div><div class="line">    std::tuple&lt;</div><div class="line">        Message1&lt;MyMessage&gt;,</div><div class="line">        Message2&lt;MyMessage&gt;,</div><div class="line">        Message90_1&lt;MyMessage&gt;</div><div class="line">    &gt;;</div><div class="line">comms::dispatchMsgType&lt;AllMessages2&gt;(1, msg, handler); <span class="comment">// Equivalent to using comms::dispatchMsgTypeStaticBinSearch()</span></div></div><!-- fragment --><p>Just like with message object dispatching the same <b>compile time</b> <a class="el" href="namespacecomms.html#a7ba1e1002f4c6c0868d4d13c2f427bc2">comms::dispatchMsgTypeIsPolymorphic()</a> and <a class="el" href="namespacecomms.html#a9219e19e1a89e42dfbaf2f7769b32dfa">comms::dispatchMsgTypeIsStaticBinSearch()</a> inquiry functions can be used to verify the dispatch policy for types being used. </p><div class="fragment"><div class="line">static_assert(comms::dispatchMsgTypeIsPolymorphic&lt;AllMessages1&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line">static_assert(!comms::dispatchMsgTypeIsStaticBinSearch&lt;AllMessages1&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line"></div><div class="line">static_assert(!comms::dispatchMsgTypeIsPolymorphic&lt;AllMessages2&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div><div class="line">static_assert(comms::dispatchMsgTypeIsStaticBinSearch&lt;AllMessages2&gt;(), <span class="stringliteral">&quot;Unexpected dispatch type&quot;</span>);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 17 2019 07:39:39 for COMMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
