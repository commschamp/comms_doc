<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: Fields Definition Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Fields Definition Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_field_tutorial_int_value">Integral Value Fields</a><ul><li class="level2"><a href="#sec_field_tutorial_int_value_fixed_length">Modifying Serialisation Length</a></li>
<li class="level2"><a href="#sec_field_tutorial_int_value_var_length">Variable Serialisation Length</a></li>
<li class="level2"><a href="#sec_field_tutorial_int_value_ser_offset">Serialisation Offset</a></li>
<li class="level2"><a href="#sec_field_tutorial_int_value_scaling">Scaling Value</a></li>
<li class="level2"><a href="#sec_field_tutorial_int_value_units">Value Units</a></li>
<li class="level2"><a href="#sec_field_tutorial_int_value_other">Other Options</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_field_tutorial_enum_value">Enum Value Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_bitmask_value">Bitmask Value Fields</a><ul><li class="level2"><a href="#sec_field_tutorial_bitmask_value_reserved">Reserved Bits</a></li>
<li class="level2"><a href="#sec_field_tutorial_bitmask_value_names">Bit Names</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_field_tutorial_bitfield">Bitfield Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_bundle">Bundle Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_array_list">Array List Fields</a><ul><li class="level2"><a href="#sec_field_tutorial_array_list_size_prefix">Prefixing with Size Information</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_elem_length_prefix">Element Serialisation Length Prefix</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_detached_size_prefix">Detached Size Information</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_force_element_size">Forcing Element Serialisation Length</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_term_suffix">Terminating Sequence with Suffix</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_fixed_size">Fixed Size Sequences</a></li>
<li class="level2"><a href="#sec_field_tutorial_array_list_storage">Value Storage</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_field_tutorial_string">String Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_fp_value">Floating Point Value Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_optional">Optional Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_variant">Variant Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_common_options">Common Options or Modifications for the Fields</a><ul><li class="level2"><a href="#sec_field_tutorial_common_options_default_value">Default Value for Default Construction</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_read">Custom Read Functionality</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_validation">Custom Value Validation Logic</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_refresh">Custom Refresh Functionality</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_write">Custom Write Functionality</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_version">Custom Version Update Functionality</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_fail_invalid">Fail on Invalid Value</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_ignore_invalid">Ignore Invalid Value</a></li>
<li class="level2"><a href="#sec_field_tutorial_common_options_empty_ser">Empty Serialisation</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_field_tutorial_extension">Allowing Further Use of Options</a></li>
<li class="level1"><a href="#sec_field_tutorial_custom_fields">Custom Fields</a></li>
<li class="level1"><a href="#sec_field_tutorial_other_fields">Other Fields</a></li>
</ul>
</div>
<div class="textblock"><p>Fields are abstractions around value storage primitives and/or objects, such as integral values, floating point values, strings, arrays, etc.. Every <b>field</b> class is defined in <a class="el" href="namespacecomms_1_1field.html">comms::field</a> namespace and exposes predefined interface in order to make template meta-programming as easy as possible. As an example let's take a look at <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> class which is used to define integral value field. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TOptions&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> : <span class="keyword">public</span> TBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Define inner storage type</span></div><div class="line">    <span class="keyword">using</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a> = T;</div><div class="line"></div><div class="line">    <span class="comment">// Type used for version update</span></div><div class="line">    <span class="keyword">using</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a2d7ef75e242cb73bf12a274f6387c942">VersionType</a> = <span class="keyword">typename</span> <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">TBase::VersionType</a>;</div><div class="line">    </div><div class="line">    <span class="comment">// Get access to the stored value</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a>&amp; <a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>() { <span class="keywordflow">return</span> m_value; }</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a>&amp; <a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_value; }</div><div class="line"></div><div class="line">    <span class="comment">// Read</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(TIter&amp; iter, std::size_t len) {...}</div><div class="line"></div><div class="line">    <span class="comment">// Write</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#acde94491d8bec35eebd751d8e598224f">write</a>(TIter&amp; iter, std::size_t len)<span class="keyword"> const </span>{...}</div><div class="line"></div><div class="line">    <span class="comment">// Serialisation length</span></div><div class="line">    std::size_t <a class="code" href="classcomms_1_1field_1_1IntValue.html#a822ea1aa868e545c08f258183d0e389b">length</a>()<span class="keyword"> const </span>{...}</div><div class="line"></div><div class="line">    <span class="comment">// Validity of the value</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a4591523e8f580ce0e34b6c50a15e1f84">valid</a>()<span class="keyword"> const </span>{...}</div><div class="line"></div><div class="line">    <span class="comment">// Bring field&#39;s contents into a consistent state</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#aed219921ab7ccd3876c4cda32b53fc29">refresh</a>() {...}</div><div class="line"></div><div class="line">    <span class="comment">// Update protocol version</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a3228149b9c2ceab35747147479b6cedd">setVersion</a>(<a class="code" href="classcomms_1_1field_1_1IntValue.html#a2d7ef75e242cb73bf12a274f6387c942">VersionType</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>) {...}</div><div class="line"></div><div class="line">    <span class="comment">// Compile time check whether the field&#39;s contents may change as the</span></div><div class="line">    <span class="comment">// result of protocol version update</span></div><div class="line">    <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#ae72c73696c921a3a1eb085a1b15d49c6">isVersionDependent</a>() {...};</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a> m_value;</div><div class="line">}</div></div><!-- fragment --><p> The main things to note are that every field definition class: </p><ul>
<li>receives its base class as the first template parameter. It is expected to be a variant of <a class="el" href="classcomms_1_1Field.html">comms::Field</a> with <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> option to specify the serialisation endian. </li>
<li>exhibits some default behaviour which can be modified by passing various options from <a class="el" href="namespacecomms_1_1option.html">comms::option</a> namespace as additional template parameters. All the available options are described below in this tutorial. </li>
<li>defines <b>ValueType</b> inner value storage type and provides <b>value()</b> member functions to access the stored value. </li>
<li>provides <b>read()</b> and <b>write()</b> member functions to read and write the inner value given the iterator used for reading / writing and available length of the buffer. </li>
<li>has <b>length()</b> member function to report how many bytes are required to serialise currently stored value. </li>
<li>provides <b>valid()</b> member function to check whether the stored value is valid (within expected range of values). </li>
<li>has <b>refresh()</b> member function to bring its contents to consistent / valid state when required. </li>
<li>has <b>setVersion()</b> member function to notify field object that the the protocol version has changed.</li>
</ul>
<p>Also note that all the member function are NON-virtual, i.e. the field abstractions do not have polymorphic behaviour.</p>
<p>The available fields abstractions are: </p><ul>
<li><a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value">Integral Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_enum_value">Enum Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bitmask_value">Bitmask Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bitfield">Bitfield Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bundle">Bundle Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list">Array List Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_string">String Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1FloatValue.html">comms::field::FloatValue</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_fp_value">Floating Point Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_optional">Optional Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> - used to define <a class="el" href="page_field_tutorial.html#sec_field_tutorial_variant">Variant Fields</a></li>
</ul>
<h1><a class="anchor" id="sec_field_tutorial_int_value"></a>
Integral Value Fields</h1>
<p>Integral values are abstracted by <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a> class, which receives at least two template parameters. The first one is a base class, from which the <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a> will inherit. It must be a variant of <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">comms::Field</a>, with the option specifying endian used for data serialisation. The second template parameter is a basic integral type that is used to store the field's value.<br />
For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyIntField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::int16_t&gt;</a>;</div></div><!-- fragment --><p> The example above defines a field that uses <b>std::int16_t</b> type to store its value. The value can be accessed using <b>value()</b> member function: </p><div class="fragment"><div class="line">MyIntField intField;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Default value: &quot;</span> &lt;&lt; intField.value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// prints 0</span></div><div class="line">intField.value() = 5;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Updated value: &quot;</span> &lt;&lt; intField.value() &lt;&lt; std::endl; <span class="comment">// prints 5</span></div></div><!-- fragment --><p> When such field is serialised, 2 bytes (<b>sizeof(std::int16_t)</b>) are written to the output buffer, most significant first and less significant second (because <b>MyFieldBase</b> base class was defined using <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546" title="Alias option to Endian specifying Big endian. ">comms::option::def::BigEndian</a> option).</p>
<h2><a class="anchor" id="sec_field_tutorial_int_value_fixed_length"></a>
Modifying Serialisation Length</h2>
<p>Sometimes protocol specification tries to reduce amount of data transferred over I/O link. It may define serialisation length of the field that differs from standard length of basic integral types, such as <b>std::int8_t</b>, <b>std::uint8_t</b>, <b>std::int16_t</b>, <b>std::uint16_t</b>, <b>std::int32_t</b>, <b>std::uint32_t</b>, ... For example, some field may only have values between 0 and 10,0000,000, which may be encoded using only 3 bytes, and that's what the protocol specifies. The storage type for such value is going to be <b>std::uint32_t</b>, but there is a need to limit serialisation length for it. The COMMS library provides <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html" title="Option used to specify number of bytes that is used for field serialisation. ">comms::option::def::FixedLength</a> option, that can be used for this purpose. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyIntField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint32_t, comms::option::def::FixedLength&lt;3&gt;</a> &gt;;</div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_int_value_var_length"></a>
Variable Serialisation Length</h2>
<p>There are protocols, that try to reduce amount of traffic over I/O link by using variable length when serialising numeric value. Usually it is <a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Base-128</a> encoding, where the most significant bit in the byte indicates whether it is the last byte in the numeric encoding or the next one also needs to be taken into account. The COMMS library provides <a class="el" href="structcomms_1_1option_1_1def_1_1VarLength.html" title="Option used to specify that field may have variable serialisation length. ">comms::option::def::VarLength</a> option that can be used with <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a> and modifies the behaviour of the latter to expose the required read()/write()/length() behaviour: </p><div class="fragment"><div class="line"><span class="comment">// Variable length encoding, encoding takes at least 1 byte and at most 4 bytes. </span></div><div class="line"><span class="keyword">using</span> MyIntField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint32_t, comms::option::def::VarLength&lt;1, 4&gt;</a> &gt;;</div></div><!-- fragment --><p> The field's base class (<b>MyFieldBase</b>) contains endian information which is used to determine which part of the value is serialised first.</p>
<h2><a class="anchor" id="sec_field_tutorial_int_value_ser_offset"></a>
Serialisation Offset</h2>
<p>There are cases when there is a need to add/subtract some predefined offset to/from the value of the field when serialisation takes place. Good example of such case would be serialising a "current year" value. Most protocols now specify it as an offset from year 2000 or later and serialised as a single byte, i.e. to specify year 2015 is to write value 15. However it may be inconvenient to manually adjust serialised/deserialised value by predefined offset 2000. To help with such case option <a class="el" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html" title="Option to specify numeric value serialisation offset. ">comms::option::def::NumValueSerOffset</a> can be used. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> YearField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::int16_t, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength&lt;1&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a>&lt;-2000&gt;</div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t SerData[] = { 15 }; <span class="comment">// Pretend serialisation data</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::size_t SerDataLen = std::extent&lt;decltype(SerData)&gt;::value; </div><div class="line"></div><div class="line">YearField year;</div><div class="line"><span class="keyword">auto</span>* readIter = &amp;SerData[0];</div><div class="line"><span class="keyword">auto</span> es = year.read(readIter, SerDataLen); <span class="comment">// Read year information</span></div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No failure is expected</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; year.value() &lt;&lt; std::endl; <span class="comment">// Prints 2015;</span></div><div class="line"></div><div class="line"><span class="comment">// Modify year value:</span></div><div class="line">year.value() = 2016;</div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outData; <span class="comment">// Pretend output buffer</span></div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outData);</div><div class="line">es = year.write(writeIter, outData.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No failure is expected</span></div><div class="line"></div><div class="line">assert(outData.size() == 1U); <span class="comment">// Only 1 byte is expected to be pushed to outData,</span></div><div class="line">                              <span class="comment">// due to using comms::option::def::FixedLength&lt;1&gt; option.</span></div><div class="line">assert(outData[0] == 16); <span class="comment">// The value equal to &quot;year.value() - 2000&quot; is expected to be written.  </span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_int_value_scaling"></a>
Scaling Value</h2>
<p>Sometimes systems operate with floating point numbers. Let's say to handle the distance between two points on the map in meters. However, when communicating this information over the I/O link, the developers often scale the floating point value up in order to send such value as integer. For example, the distance is communicated in millimeters (when calculated and handled in meters). The definition of such field may look like: </p><div class="fragment"><div class="line"><span class="keyword">using</span> DistanceField =</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::uint16_t, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio&lt;1, 1000&gt;</a> </div><div class="line">    &gt;;</div></div><!-- fragment --><p> The <a class="el" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html" title="Option to specify scaling ratio. ">comms::option::def::ScalingRatio</a> option allows scaling of serialised value (distance in mm) to handling value (distance in m) and vice versa: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InData[] = {0x3, 0xe8}; <span class="comment">// Pretend input buffer, encoded 1000</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::size_t InDataSize = std::extent&lt;decltype(InData)&gt;::value;</div><div class="line"></div><div class="line">DistanceField dist;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InData[0];;</div><div class="line"><span class="keyword">auto</span> es = dist.read(readIter, InDataSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in mm: &quot;</span> &lt;&lt; dist.value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// Prints 1000</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in m: &quot;</span>  &lt;&lt; dist.getScaled&lt;<span class="keywordtype">float</span>&gt;() &lt;&lt; std::endl; <span class="comment">// Prints 1.0</span></div><div class="line"></div><div class="line">dist.setScaled(2.3);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New distance in mm: &quot;</span> &lt;&lt; dist.value() &lt;&lt; std::endl; <span class="comment">// Prints 2300</span></div></div><!-- fragment --><p>The scaling may work in the opposite direction of increasing the number. For example, the field contains number of <b>tens</b> of millimeters between two points. It would be convenient to be able to convert it to proper millimeters number. As the result the field can be defined as: </p><div class="fragment"><div class="line"><span class="keyword">using</span> OtherDistanceField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::uint16_t, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio&lt;10, 1&gt;</a> </div><div class="line">    &gt;;</div></div><!-- fragment --><p> The <a class="el" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio</a> option allows scaling of serialised value (distance in tens of mm) to handling value (distance in mm) and vice verse: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InData[] = {0x0, 0xf}; <span class="comment">// Pretend input buffer, encoded 15</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::size_t InDataSize = std::extent&lt;decltype(InData)&gt;::value;</div><div class="line"></div><div class="line">OtherDistanceField dist;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InData[0];;</div><div class="line"><span class="keyword">auto</span> es = dist.read(readIter, InDataSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in tens of mm: &quot;</span> &lt;&lt; dist.value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// Prints 15</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in mm: &quot;</span>  &lt;&lt; dist.getScaled&lt;unisnged&gt;() &lt;&lt; std::endl; <span class="comment">// Prints 150</span></div><div class="line"></div><div class="line">dist.setScaled(500);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New distance in tens of mm: &quot;</span> &lt;&lt; dist.value() &lt;&lt; std::endl; <span class="comment">// Prints 50</span></div></div><!-- fragment --><p>Methods <a class="el" href="classcomms_1_1field_1_1IntValue.html#aab70162b392a06982b66c9417a7f8ea7" title="Scales value according to ratio specified in provided comms::option::def::ScalingRatio option...">comms::field::IntValue::getScaled</a> and <a class="el" href="classcomms_1_1field_1_1IntValue.html#a1df02ae1e08b356662b2364a9e5d8e27" title="Opposite operation to getScaled(). ">comms::field::IntValue::setScaled</a> take into account scaling ratio provided (with <a class="el" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio</a> option) to the <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a> field. If such option wasn't used <b>comms::option::def::ScalingRatio&lt;1, 1&gt;</b> is assumed.</p>
<h2><a class="anchor" id="sec_field_tutorial_int_value_units"></a>
Value Units</h2>
<p>In addition to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_scaling">Scaling Value</a>, the <b>COMMS</b> library provides an ability to specify field's value units and perform conversion between units of the same type. Let's get back to the same example of defining distance between two point, but instead of providing scaling ratio directly, the type of the units is specified. </p><div class="fragment"><div class="line"><span class="keyword">using</span> DistanceField =</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::uint16_t, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1Units.html">comms::option::def::UnitsMillimeters</a></div><div class="line">    &gt;;</div></div><!-- fragment --><p> The <a class="el" href="namespacecomms_1_1option_1_1def.html#a2f7505443427630657678e7a762122f4">comms::option::def::UnitsMillimeters</a> option specifies that field contains distance in millimeters, which allows <b>COMMS</b> library provide proper conversion to other distance units when necessary: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InData[] = {0x3, 0xe8}; <span class="comment">// Pretend input buffer, encoded 1000</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::size_t InDataSize = std::extent&lt;decltype(InData)&gt;::value;</div><div class="line"></div><div class="line">DistanceField dist;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InData[0];;</div><div class="line"><span class="keyword">auto</span> es = dist.read(readIter, InDataSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Original value: &quot;</span> &lt;&lt; dist.value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// Prints 1000</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in mm: &quot;</span>  &lt;&lt; comms::units::getMillimeters&lt;unsigned&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 1000</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in cm: &quot;</span>  &lt;&lt; comms::units::getCentimeters&lt;float&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 100.0</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in m: &quot;</span>  &lt;&lt; comms::units::getMeters&lt;float&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 1.0</span></div><div class="line"></div><div class="line"><a class="code" href="namespacecomms_1_1units.html#a7d899779a1bf68f1fbea5290e33c8e6c">comms::units::setCentimeters</a>(dist, 5.5f);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New value: &quot;</span> &lt;&lt; dist.value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// Prints 55</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New distance in mm: &quot;</span>  &lt;&lt; comms::units::getMillimeters&lt;unsigned&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 55</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New distance in cm: &quot;</span>  &lt;&lt; comms::units::getCentimeters&lt;float&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 5.5</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New distance in m: &quot;</span>  &lt;&lt; comms::units::getMeters&lt;float&gt;(dist) &lt;&lt; std::endl; <span class="comment">// Prints 0.055</span></div></div><!-- fragment --><p>In the examples above the "units" specification may replace the "scaling" information. However, there are cases when it they may complement each other. For example, the field contains "latitude" information in <b>degrees</b> but multiplied by 10'000'000 to make integral value out of floating point. </p><div class="fragment"><div class="line"><span class="keyword">using</span> LatField =</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::int32_t,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio&lt;1, 10000000&gt;</a>, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1Units.html">comms::option::def::UnitsDegrees</a></div><div class="line">    &gt;;</div></div><!-- fragment --><p> The <b>COMMS</b> library uses the scaling ratio as well as units information to be able to convert the stored value between degrees and radians when needed. </p><div class="fragment"><div class="line">LatField lat(123456789); <span class="comment">// Encoded latitude of 12.3456789</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Raw value: &quot;</span> &lt;&lt; lat.value() &lt;&lt; std::endl; <span class="comment">// Prints 123456789</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Lat in degrees: &quot;</span> &lt;&lt; comms::units::getDegrees&lt;double&gt;(lat) &lt;&lt; std::endl; <span class="comment">// Prints 12.3456789</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Lat in radians: &quot;</span> &lt;&lt; comms::units::getRadians&lt;float&gt;(lat) &lt;&lt; std::endl; <span class="comment">// 0.21547274519</span></div><div class="line"></div><div class="line"><a class="code" href="namespacecomms_1_1units.html#ab433e16321003a7a46e99b45fe267495">comms::units::setDegrees</a>(lat, 22.33);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New raw value: &quot;</span> &lt;&lt; lat.value() &lt;&lt; std::endl; <span class="comment">// Prints 223300000</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New degrees value: &quot;</span> &lt;&lt; comms::units::getDegrees&lt;double&gt;(lat) &lt;&lt; std::endl; <span class="comment">// Prints 22.33</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;New radians value: &quot;</span> &lt;&lt; comms::units::getRadians&lt;double&gt;(lat) &lt;&lt; std::endl; <span class="comment">// Prints 0.38973202</span></div><div class="line"></div><div class="line"><a class="code" href="namespacecomms_1_1units.html#acd1c9f9ef4617013341f204c1b473f8c">comms::units::setRadians</a>(lat, 1.04719);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Updated raw value: &quot;</span> &lt;&lt; lat.value() &lt;&lt; std::endl; <span class="comment">// Prints 600000000</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Updated degrees value: &quot;</span> &lt;&lt; comms::units::getDegrees&lt;double&gt;(lat) &lt;&lt; std::endl; <span class="comment">// Prints 60</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Updated radians value: &quot;</span> &lt;&lt; comms::units::getRadians&lt;double&gt;(lat) &lt;&lt; std::endl; <span class="comment">// Prints 1.04719</span></div></div><!-- fragment --><p> The <b>COMMS</b> library provides mulitple <b>options</b> to specify the units of the field's value: </p><ul>
<li><b>Time:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ad04b14a19f21bf5fd04806d40651d8cf">comms::option::def::UnitsNanoseconds</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ace3d11ccc8806c6ad6698fae4eebef49">comms::option::def::UnitsMicroseconds</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a300573e54806a71d34dee5a4f86d470e">comms::option::def::UnitsMilliseconds</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#afd07bdbc61c817cc37079601c240ca3b">comms::option::def::UnitsSeconds</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a0d8b37c8d9de44ef75c247a623e5b74d">comms::option::def::UnitsMinutes</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a31cd2d418453381edca4503d79d87390">comms::option::def::UnitsDays</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a2905e3b93c65b4cb1acc8b909ce9ccea">comms::option::def::UnitsWeeks</a> </li>
</ul>
</li>
<li><b>Distance:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a6952cbd3a486dc94c3092026abfd00f4">comms::option::def::UnitsNanometers</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a06f751e0d713d383b9f5c74202434087">comms::option::def::UnitsMicrometers</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a2f7505443427630657678e7a762122f4">comms::option::def::UnitsMillimeters</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ad1cefa1d4f171efe322ce10ffac47949">comms::option::def::UnitsCentimeters</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ab14a41478bb6b3b2cd074872c54c7db2">comms::option::def::UnitsMeters</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a38fcc7a943b3e409b03079ee22bc7361">comms::option::def::UnitsKilometers</a> </li>
</ul>
</li>
<li><b>Speed:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a6a021521486fa26bee6d261164ee864a">comms::option::def::UnitsNanometersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a435797fea7e3f714bf4f54458d5f92e1">comms::option::def::UnitsMicrometersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a317eb26407c4b9fc3d5e10acac8ff99c">comms::option::def::UnitsMillimetersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a56ae9cca2d2a6fed99feb9350fff30e1">comms::option::def::UnitsCentimetersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#af0e3f1477a133ae480d13a0bfc5ce3cd">comms::option::def::UnitsMetersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a03caf060495e5d0e63479bb86ad3aa49">comms::option::def::UnitsKilometersPerSecond</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a1dcc8cf6e446be26da524f12ee137a12">comms::option::def::UnitsKilometersPerHour</a> </li>
</ul>
</li>
<li><b>Frequency:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a8c3324fa9146916a8933b372ce1b695b">comms::option::def::UnitsHertz</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a6466057870b0f1aaa74042d5dbf6b233">comms::option::def::UnitsKilohertz</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a087dc79137d49fad3b46d6b2169d29c6">comms::option::def::UnitsMegahertz</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a2f4cb9d0376919e5041bc915d24e9d8e">comms::option::def::UnitsGigahertz</a> </li>
</ul>
</li>
<li><b>Angle:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a583961628c07ad1584b618c60d6c3f7c">comms::option::def::UnitsDegrees</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a8869e9215a042c2aa4c121f758a9ba31">comms::option::def::UnitsRadians</a> </li>
</ul>
</li>
<li><b>Electrical</b> <b>Current:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a26c1a7f05b82cae1e589f961074eb6ba">comms::option::def::UnitsNanoamps</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#aa8dd179941546fc63aebe24fa38647f7">comms::option::def::UnitsMicroamps</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#addec33169db95fef54e24bf184f1f460">comms::option::def::UnitsMilliamps</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a771aac26b959ab08046472f80d03749b">comms::option::def::UnitsAmps</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ab5bb78675a5449103627dd59dcfff69f">comms::option::def::UnitsKiloamps</a> </li>
</ul>
</li>
<li><b>Electrical</b> <b>Voltage:</b> <ul>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a582bc738e45917f1024442db9223f3d9">comms::option::def::UnitsNanovolts</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#ab8c964bf0eceb09ada45c6c0f04628dd">comms::option::def::UnitsMicrovolts</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#aa28e7151853cb38f80992c6acc0d1233">comms::option::def::UnitsMillivolts</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a754e907ff8553b6715d1183b53c337d1">comms::option::def::UnitsVolts</a></li>
<li><a class="el" href="namespacecomms_1_1option_1_1def.html#a582ca674f67c67574faff6d222e50df9">comms::option::def::UnitsKilovolts</a></li>
</ul>
</li>
</ul>
<p>All the units conversion functions reside in <a class="el" href="namespacecomms_1_1units.html" title="Namespace containing units conversion operations. ">comms::units</a> namespace. <b>NOTE</b>, that conversion can be applied only between the units of the same type. The units compitability check is performed at compile time and the compilation will fail on attempt to set/get incompatible value, such as setting/getting "seconds" to/from the field specified as containing millimeters.</p>
<p>The whole units conversion functionality can be useful in a client code, that requires usage of particular unit types in its internal calculations. It can use conversion functions without any need to know scaling ratio and/or actual units of the field, the <b>COMMS</b> library will do all the necessary math calculation to provide the requested value.</p>
<h2><a class="anchor" id="sec_field_tutorial_int_value_other"></a>
Other Options</h2>
<p>There multiple common options that are applicable to all the fields, <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a> included. Please refer to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options">Common Options or Modifications for the Fields</a> for more details.</p>
<h1><a class="anchor" id="sec_field_tutorial_enum_value"></a>
Enum Value Fields</h1>
<p>Sometimes it is more convenient to operate with enum types instead of integral values. For example, the custom protocol message carries information of how to configure some external serial port, and one of the values is the baud rate. In order not to impose too much overhead on I/O link, the protocol developers decided to use single byte to indicate one standard baud rate: </p><table class="doxtable">
<tr>
<th align="center">Baud Rate </th><th align="center">Serialisation Value  </th></tr>
<tr>
<td align="center">9600 </td><td align="center">0 </td></tr>
<tr>
<td align="center">14400 </td><td align="center">1 </td></tr>
<tr>
<td align="center">19200 </td><td align="center">2 </td></tr>
<tr>
<td align="center">28800 </td><td align="center">3 </td></tr>
<tr>
<td align="center">38400 </td><td align="center">4 </td></tr>
<tr>
<td align="center">57600 </td><td align="center">5 </td></tr>
<tr>
<td align="center">115200 </td><td align="center">6 </td></tr>
</table>
<p>It would be more convenient to define enum type to operate with, instead of using raw numbers. </p><div class="fragment"><div class="line"><span class="keyword">enum</span> Baud : std::uint8_t <span class="comment">// The underlying type should be explicitly specified</span></div><div class="line">{</div><div class="line">    Baud_9600,</div><div class="line">    Baud_14400,</div><div class="line">    Baud_19200,</div><div class="line">    Baud_28800,</div><div class="line">    Baud_38400,</div><div class="line">    Baud_57600,</div><div class="line">    Baud_115200</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> BaudField = <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase, Baud&gt;</a>;</div><div class="line"></div><div class="line">BaudField baud;</div><div class="line">...</div><div class="line">baud.<a class="code" href="classcomms_1_1field_1_1EnumValue.html#aaec757fe97245e63319eea6248c9865c">value</a>() = Baud_115200; <span class="comment">// Set the value.</span></div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outData; <span class="comment">// Pretend output buffer</span></div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outData);</div><div class="line"><span class="keyword">auto</span> es = baud.write(writeIter, outData.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outData.size() == 1); <span class="comment">// Single byte output is expected</span></div><div class="line">assert(outData[0] == 6U); <span class="comment">// Value 6 is expected to be written</span></div></div><!-- fragment --><p> <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a> is very similar to <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>. The main difference is using enum instead of integral type as a second template parameter. The default serialisation length is determined by the underlying type of the enum. That't why it is important to explicitly specify the underlying type of the enum when defining it, and not leave this to the compiler.</p>
<p>The <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a> field supports almost all the options that can be used with <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>: <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_fixed_length">Modifying Serialisation Length</a>, <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_var_length">Variable Serialisation Length</a>, <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_ser_offset">Serialisation Offset</a>, as well as <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options">Common Options or Modifications for the Fields</a>.</p>
<h1><a class="anchor" id="sec_field_tutorial_bitmask_value"></a>
Bitmask Value Fields</h1>
<p>Quite often messages in communication protocol use some kind of flags, where single bit has a independent meaning. It is more convenient to treat such flags as bitmasks rather than integral values. <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a> provides a convenient interface to handle such bitmasks. </p><div class="fragment"><div class="line"><span class="keyword">using</span> BitmaskField = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase&gt;</a>;</div></div><!-- fragment --><p> By default the underlying storage type of the <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a> is <b>unsigned</b>, which makes the default serialisation length to be <b>sizeof(unsigned)</b>. The modification of the underlying storage type as well as serialisation length can be done using <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html" title="Option used to specify number of bytes that is used for field serialisation. ">comms::option::def::FixedLength</a> option (see <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_fixed_length">Modifying Serialisation Length</a>). The underlying type will always be some unsigned integral type. If the serialisation length is specified to be 1 byte, the underlying storage type is <b>std::uint8_t</b>, if the serialisation length is 2 bytes, the underlying storage type is <b>std::uint16_t</b>, if the serialisation length is 3 or 4 bytes, the underlying storage type is <b>std::uin32_t</b>, etc... </p><div class="fragment"><div class="line"><span class="keyword">using</span> BitmaskField_1byte = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt;</a> &gt;;</div><div class="line">static_assert(std::is_same&lt;BitmaskField_1byte::ValueType, std::uint8_t&gt;::value, <span class="stringliteral">&quot;std::uint8_t type is expected&quot;</span>);</div><div class="line">assert(BitmaskField_1byte().length() == 1U);</div><div class="line"></div><div class="line"><span class="keyword">using</span> BitmaskField_2bytes = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;2&gt;</a> &gt;;</div><div class="line">static_assert(std::is_same&lt;BitmaskField_2bytes::ValueType, std::uint16_t&gt;::value, <span class="stringliteral">&quot;std::uint16_t type is expected&quot;</span>);</div><div class="line">assert(BitmaskField_2bytes().length() == 2U);</div><div class="line"></div><div class="line"><span class="keyword">using</span> BitmaskField_3bytes = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;3&gt;</a> &gt;;</div><div class="line">static_assert(std::is_same&lt;BitmaskField_3bytes::ValueType, std::uint32_t&gt;::value, <span class="stringliteral">&quot;std::uint32_t type is expected&quot;</span>);</div><div class="line">assert(BitmaskField_2bytes().length() == 3U);</div><div class="line"></div><div class="line"><span class="keyword">using</span> BitmaskField_4bytes = <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;4&gt;</a> &gt;;</div><div class="line">static_assert(std::is_same&lt;BitmaskField_4bytes::ValueType, std::uint32_t&gt;::value, <span class="stringliteral">&quot;std::uint32_t type is expected&quot;</span>);</div><div class="line">assert(BitmaskField_2bytes().length() == 4U);</div></div><!-- fragment --><p> All the <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options">Common Options or Modifications for the Fields</a> can also be used with <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a>.</p>
<h2><a class="anchor" id="sec_field_tutorial_bitmask_value_reserved"></a>
Reserved Bits</h2>
<p>Quite often the bitmask fields contain reserved bits, which must preserve some values (usually 0). The <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a> fields support usage of <a class="el" href="namespacecomms_1_1option_1_1def.html#ab250f5104df4cfe83741d63e6db70505">comms::option::def::BitmaskReservedBits</a> alias option. The template parameters of the option specify mask for reserved bits as well as their expected values. The check for the reserved bits values is performed inside <b><a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d" title="Default validity check. ">comms::field::BitmaskValue::valid()</a></b> member function. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyBitmask = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt;</a> <span class="comment">// Second bit is reserved and must be 0</span></div><div class="line">    &gt;;</div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_bitmask_value_names"></a>
Bit Names</h2>
<p>Quite often there is a need to provide names for the bits in the <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a> field. It is possible to define it as external independent enum. However, it may be convenient to define it as internal type. It is possible to do by inheriting from appropriate <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a> type and use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee" title="Provide names for bits in comms::field::BitmaskValue field. ">COMMS_BITMASK_BITS()</a> macro to define names for bits. For example </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; <span class="comment">// Second bit is reserved and must be 0</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, third=2, fourth, fifth, sixth, seventh, eighth);</div><div class="line">}</div></div><!-- fragment --><p> is equivalent to defining: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; </div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">enum</span> BitIdx</div><div class="line">    {</div><div class="line">        BitIdx_first,</div><div class="line">        BitIdx_third=2,</div><div class="line">        BitIdx_fourth,</div><div class="line">        BitIdx_fifth,</div><div class="line">        BitIdx_sixth,</div><div class="line">        BitIdx_seventh,</div><div class="line">        BitIdx_eighth,</div><div class="line">        BitIdx_numOfValues,</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <b>NOTE</b>, that provided names have found their way to <b>BitIdx</b> enum type, and got prefixed with <b>BitIdx_</b>. This indices may be used with <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819" title="Get bit value. ">comms::field::BitmaskValue::getBitValue()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea" title="Set bit value. ">comms::field::BitmaskValue::setBitValue()</a> member functions.</p>
<p>Also note, that there is automatically generated <b>BitIdx_numOfValues</b> value to indicate end of the names list.</p>
<p>Due to the fact that the provided bit names may have <b>=val</b> suffixes, it excludes the ability to generate proper access functions for the named bits. However, the <b>COMMS</b> library also provides <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> macro, which can be used in addition to <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> one to generate the convenience functions. For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; <span class="comment">// Second bit is reserved and must be 0</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, third=2, fourth, fifth, sixth, seventh, eighth);</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(first, third, fourth, fifth, sixth, seventh, eighth);</div><div class="line">}</div></div><!-- fragment --><p> is equivalent to defining: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; </div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">enum</span> BitIdx {...}</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> getBitValue_first()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a>(BitIdx_first); }</div><div class="line">    <span class="keywordtype">void</span> setBitValue_first(<span class="keywordtype">bool</span> val) { <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a>(BitIdx_first, val); }</div><div class="line">    <span class="keywordtype">bool</span> getBitValue_third()<span class="keyword"> const </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> setBitValue_third(<span class="keywordtype">bool</span> val) { ... }</div><div class="line">    <span class="keywordtype">bool</span> getBitValue_fourth()<span class="keyword"> const </span>{ ... }</div><div class="line">    <span class="keywordtype">void</span> setBitValue_fourth(<span class="keywordtype">bool</span> val) { ... }</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> In case the bit names definition is sequential starting with index 0 and going up without and gaps, i.e. no <b>=val</b> suffixes are used, the usage of two separate <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> macros, can be unified into one <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0xf0, 0&gt; <span class="comment">// 4 MSBs are reserved</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(first, second, third, fourth);</div><div class="line">}</div></div><!-- fragment --><p> <b style="color:red">WARNING:</b> Some compilers, such as <b>clang</b> or earlier versions of <b>gcc</b> (v4.9 and earlier) may have problems compiling the <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a> macros even though they contain valid C++11 code. If the compilation failure happens and the bitmask definition class is <b>NOT</b> a template one (like in the example above), then try to substitute the used macros with <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3df004ba882635103d9e409c932412a1">COMMS_BITMASK_BITS_ACCESS_NOTEMPLATE()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE()</a> respectively. For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0xf0, 0&gt; <span class="comment">// 4 MSBs are reserved</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0008a7140153cb20e0ff6cd03be5dba3">COMMS_BITMASK_BITS_SEQ_NOTEMPLATE</a>(first, second, third, fourth);</div><div class="line">}</div></div><!-- fragment --><p> However, when the defined bitmask class is a template, then the inner definition of <b>Base</b> type, which specifies the exact type of the base class, is required. For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div><div class="line"><span class="keyword">class </span>MyBitmask : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        comms::option::def::BitmaskReservedBits&lt;0xf0, 0&gt;, <span class="comment">// 4 MSBs are reserved</span></div><div class="line">        TExtraOptions...</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Duplicate base class type</span></div><div class="line">    <span class="keyword">using</span> Base = </div><div class="line">        <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">            MyFieldBase, </div><div class="line">            comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::BitmaskReservedBits&lt;0xf0, 0&gt;</a>, <span class="comment">// 4 MSBs are reserved</span></div><div class="line">            TExtraOptions...</div><div class="line">        &gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(first, second, third, fourth);</div><div class="line">}</div></div><!-- fragment --><p> The same goes for <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b" title="Generate access functions for bits in comms::field::BitmaskValue field. ">COMMS_BITMASK_BITS_ACCESS()</a> macro.</p>
<p><b>NOTE</b>, that <b>COMMS</b> library also defines <b>COMMS_MUST_DEFINE_BASE</b> in case the base class definition is needed (going to be used). If the developed application is going to be multi-platform and compiled with various compilers (some of which may warn about unused private type) it is possible to use the defined symbol to add / remove the definition of the <b>Base</b> member type. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div><div class="line"><span class="keyword">class </span>MyBitmask : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef COMMS_MUST_DEFINE_BASE</span></div><div class="line">    <span class="keyword">using</span> Base = ...;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ</a>(first, second, third, fourth);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sec_field_tutorial_bitfield"></a>
Bitfield Fields</h1>
<p>Many communication protocols try to pack multiple independent values into a one or several bytes to save traffic on I/O link. For example, to encode baud rate from example in <a class="el" href="page_field_tutorial.html#sec_field_tutorial_enum_value">Enum Value Fields</a> section, only 3 bits are needed (values [0 - 6]). The serial port configuration may also require parity information, which may have only "None", "Even", and "Odd" values: </p><table class="doxtable">
<tr>
<th align="center">Parity </th><th align="center">Serialisation Value  </th></tr>
<tr>
<td align="center">None </td><td align="center">0 </td></tr>
<tr>
<td align="center">Odd </td><td align="center">1 </td></tr>
<tr>
<td align="center">Even </td><td align="center">2 </td></tr>
</table>
<div class="fragment"><div class="line"><span class="keyword">enum</span> Parity : std::uint8_t</div><div class="line">{</div><div class="line">    Parity_None,</div><div class="line">    Parity_Odd,</div><div class="line">    Parity_Even</div><div class="line">};</div></div><!-- fragment --><p> To encode parity value only 2 bits are needed. Together with the baud mentioned earlier, these two values will consume only 5 bits. Let's also use the remaining 3 bits to complete a single byte as some kind of flags.</p>
<table class="doxtable">
<tr>
<th align="center">Value </th><th align="center">Number of bits  </th></tr>
<tr>
<td align="center">Baud </td><td align="center">3 </td></tr>
<tr>
<td align="center">Parity </td><td align="center">2 </td></tr>
<tr>
<td align="center">Flags </td><td align="center">3 </td></tr>
</table>
<p>These value must be accessed and treated as independent values. However, they must be bundled into a single byte when serialisation happens. The COMMS library provides <a class="el" href="classcomms_1_1field_1_1Bitfield.html" title="Bitfield field. ">comms::field::Bitfield</a> field for this purpose. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> SerialConfigField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::tuple&lt;</div><div class="line">            <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase, Baud, comms::option::def::FixedBitLength&lt;3&gt;</a> &gt;,</div><div class="line">            <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase, Parity, comms::option::def::FixedBitLength&lt;2&gt;</a> &gt;,</div><div class="line">            <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedBitLength&lt;3&gt;</a> &gt;</div><div class="line">        &gt;</div><div class="line">    &gt;;</div></div><!-- fragment --><p> Please pay attention to the following details: </p><ul>
<li>The bitfield members are bundled in <a href="http://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> and passed as the second template parameter. </li>
<li>The serialisation length of every bitfield member is specified in bits using <a class="el" href="structcomms_1_1option_1_1def_1_1FixedBitLength.html">comms::option::def::FixedBitLength</a> (note difference to <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a> that specifies length in bytes). </li>
<li>The summary of all the "bit" lengths of all the members must be divisible by 8, i.e. to be packed in any number of bytes without leaving a single bit undefined. </li>
<li>The member of the bitfield may be any numeric field (<a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>, <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a>, and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a>), that support <a class="el" href="structcomms_1_1option_1_1def_1_1FixedBitLength.html">comms::option::def::FixedBitLength</a> option.</li>
</ul>
<p>Every member of the bitfield may use all the supported options. The <a class="el" href="classcomms_1_1field_1_1Bitfield.html" title="Bitfield field. ">comms::field::Bitfield</a> itself may receive only options listed in its class description.</p>
<p>To get an access to the member fields use <b>value()</b> member function: </p><div class="fragment"><div class="line">SerialConfigField serialConfigField;</div><div class="line">...</div><div class="line">auto&amp; members = serialConfigField.value(); <span class="comment">// Reference to the stored tuple of field members</span></div><div class="line"><span class="keyword">auto</span>&amp; buadField = std::get&lt;0&gt;(members); <span class="comment">// Reference to the baud field;</span></div><div class="line"><span class="keyword">auto</span>&amp; parityField = std::get&lt;1&gt;(members); <span class="comment">// Reference to the parity field;</span></div><div class="line"><span class="keyword">auto</span>&amp; flagsField = std::get&lt;2&gt;(members); <span class="comment">// Reference to the flags field</span></div><div class="line"></div><div class="line">baudField.value() = Baud_115200; <span class="comment">// =6</span></div><div class="line">parityField.value() = Parity_Even; <span class="comment">// =2</span></div><div class="line">flagsField.value() = 0x2;</div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outData; <span class="comment">// Pretend output buffer</span></div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outData);</div><div class="line"><span class="keyword">auto</span> es = baud.write(writeIter, outData.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outData.size() == 1); <span class="comment">// Single byte output is expected</span></div><div class="line">assert(outData[0] == 0x56); <span class="comment">// Binary value split to 3-2-3 bits: 010|10|110</span></div></div><!-- fragment --><p>It would be convenient to access the member fields by name, rather than by index with <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">std::get</a>. It can be achieved by using <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129" title="Provide names for member fields of composite fields, such as comms::field::Bundle or comms::field::Bi...">COMMS_FIELD_MEMBERS_NAMES()</a> macro inside field definition class. </p><div class="fragment"><div class="line"><span class="keyword">class </span>SerialConfigField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div><div class="line">    <span class="comment">// the requirement of @ref COMMS_FIELD_MEMBERS_NAMES() macro</span></div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(baud, parity, flags);</div><div class="line">}</div></div><!-- fragment --><p> It is equivalent to having the following enum, types and functions defined: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SerialConfigField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Access indices for member fields</span></div><div class="line">    <span class="keyword">enum</span> FieldIdx {</div><div class="line">        FieldIdx_baud,</div><div class="line">        FieldIdx_parity,</div><div class="line">        FieldIdx_flags,</div><div class="line">        FieldIdx_numOfValues</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;baud&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_baud() -&gt; decltype(std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to const &quot;baud&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_baud() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_baud&gt;(value()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;parity&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_parity() -&gt; decltype(std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to const &quot;parity&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_parity() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_parity&gt;(value()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to &quot;flags&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_flags() -&gt; decltype(std::get&lt;FieldIdx_flags&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_flags&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Accessor to const &quot;flags&quot; field</span></div><div class="line">    <span class="keyword">auto</span> field_flags() const -&gt; decltype(<a class="code" href="namespacestd.html">std</a>::get&lt;FieldIdx_flags&gt;(value()))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_flags&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Redefinition of the members fields types:</span></div><div class="line">    <span class="keyword">using</span> Field_baud = ...;</div><div class="line">    <span class="keyword">using</span> Field_parity = ...;</div><div class="line">    <span class="keyword">using</span> Field_flags = ...;</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that provided names <b>baud</b>, <b>parity</b>, and <b>flags</b>, have found their way to the following definitions: </p><ul>
<li><b>FieldIdx</b> enum. The names are prefixed with <b>FieldIdx_</b>. The <b>FieldIdx_nameOfValues</b> value is automatically added at the end. </li>
<li>Accessor functions prefixed with <b>field_</b> </li>
<li>Types of member fields prefixed with <b>Field_*</b> </li>
</ul>
<p>As the result, the fields can be accessed using multiple ways: For example using <b>FieldIdx</b> enum </p><div class="fragment"><div class="line">SerialConfigField field;</div><div class="line"><span class="keyword">auto</span>&amp; members = field.value(); <span class="comment">// get access to the std::tuple of member fields</span></div><div class="line"><span class="keyword">auto</span>&amp; baudField = std::get&lt;SerialConfigField::FieldIdx_baud&gt;(members);</div><div class="line"><span class="keyword">auto</span>&amp; parityField = std::get&lt;SerialConfigField::FieldIdx_parity&gt;(members);</div><div class="line"><span class="keyword">auto</span>&amp; flagsField = std::get&lt;SerialConfigField::FieldIdx_flags&gt;(members);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> baud = baudField.value();</div><div class="line"><span class="keyword">auto</span> parity = parityField.value();</div><div class="line"><span class="keyword">auto</span> flags = flagsField.value();</div></div><!-- fragment --><p> or using accessor functions: </p><div class="fragment"><div class="line">SerialConfigField field;</div><div class="line"><span class="keyword">auto</span> baud = field.field_baud().value();</div><div class="line"><span class="keyword">auto</span> parity = field.field_parity().value();</div><div class="line"><span class="keyword">auto</span> flags = field.flags.value();</div></div><!-- fragment --><p> <b>SIDE NOTE:</b> In addition to <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> macro there is <a class="el" href="Field_8h.html#a96226a2c000a3145a48ce074b6a7f847">COMMS_FIELD_MEMBERS_ACCESS()</a> one. It is very similar to <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> but does <b>NOT</b> (re)define the inner <b>Field_*</b> types. It also does not require (except for <b>clang</b>) having base class to be (re)defined as inner <b>Base</b> type. </p><div class="fragment"><div class="line"><span class="keyword">class </span>SerialConfigField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#a96226a2c000a3145a48ce074b6a7f847">COMMS_FIELD_MEMBERS_ACCESS</a>(baud, parity, flags);</div><div class="line">}</div></div><!-- fragment --><p> In fact <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> is implemented as the wrapper around <a class="el" href="Field_8h.html#a96226a2c000a3145a48ce074b6a7f847">COMMS_FIELD_MEMBERS_ACCESS()</a>.</p>
<h1><a class="anchor" id="sec_field_tutorial_bundle"></a>
Bundle Fields</h1>
<p>There are cases when multiple independent fields need to be bundled into a single field and expose the required interface of reading, writing, calculating length, checking field's contents validity, and bringing field's value into a consistent state. It may be required when a message contains sequence (see <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list">Array List Fields</a>) of such bundles/structs. The COMMS library provides <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field. ">comms::field::Bundle</a> field for this purpose. It is quite similar to <a class="el" href="classcomms_1_1field_1_1Bitfield.html" title="Bitfield field. ">comms::field::Bitfield</a> described earlier. The difference is that every member field doesn't specify any length in bits, just bytes. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> SomeEnum : std::uint8_t</div><div class="line">{</div><div class="line">    SomeEnum_Value1,</div><div class="line">    SomeEnum_Value2,</div><div class="line">    SomeEnum_Value3,</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyBundle =</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::int16_t&gt;</a> <span class="comment">// 2 bytes int value</span></div><div class="line">            <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue&lt;MyFieldBase, SomeEnum&gt;</a>, <span class="comment">// 1 byte enum value</span></div><div class="line">            <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt;</a> &gt; <span class="comment">// 1 byte bitmask</span></div><div class="line">        &gt;</div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyBundle bundleField;</div><div class="line">...</div><div class="line">auto&amp; members = bundleField.value(); <span class="comment">// Reference to the stored tuple of field members</span></div><div class="line"><span class="keyword">auto</span>&amp; intValueField = std::get&lt;0&gt;(members);</div><div class="line"><span class="keyword">auto</span>&amp; enumValueField = std::get&lt;1&gt;(members);</div><div class="line"><span class="keyword">auto</span>&amp; bitmaskValueField = std::get&lt;2&gt;(members);</div><div class="line"></div><div class="line">intValueField.value() = ...; <span class="comment">// access the value of IntValue member field.</span></div><div class="line">enumValueField.value() = ...; <span class="comment">// access the value of EnumValue member field.</span></div><div class="line">bitmaskValueField.value() = ...; <span class="comment">// access the value of BitmaskValue member field.</span></div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outData; <span class="comment">// Pretend output buffer</span></div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outData);</div><div class="line"><span class="keyword">auto</span> es = baud.write(writeIter, outData.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outData.size() == 4); <span class="comment">// Expected 2 bytes for IntValue, 1 byte for EnumValue and 1 byte for BitmaskValue</span></div></div><!-- fragment --><p> The default behaviour of <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field. ">comms::field::Bundle</a> may be extended with options. Please refer to the class documentation for the list of supported options.</p>
<p>Just like with the <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bitfield">Bitfield Fields</a>, the names to the member fields can be provided by using <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> or <a class="el" href="Field_8h.html#a96226a2c000a3145a48ce074b6a7f847">COMMS_FIELD_MEMBERS_ACCESS()</a> macro. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyBundle : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type is</span></div><div class="line">    <span class="comment">// required by COMMS_FIELD_MEMBERS_NAMES() macro. </span></div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(member1, member2, member3);</div><div class="line">};</div></div><!-- fragment --><p> It will create similar enum and convenience access functions, just like described in previous <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bitfield">Bitfield Fields</a> section.</p>
<p>Some <b>bundle</b> fields in some protocols may contain a field, which holds a <b>remaining serialization length</b> of the following member fields in the bundle. The <b>COMMS</b> library has a built-in support for such cases, it requires usage of <a class="el" href="structcomms_1_1option_1_1def_1_1RemLengthMemberField.html">comms::option::def::RemLengthMemberField</a> option to specify index of such field. For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div><div class="line"><span class="keyword">class </span>MyBundle : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            comms::field::IntValue&lt;FieldBase, std::uint8_t&gt;, <span class="comment">// remaing length info</span></div><div class="line">            SomeField1, </div><div class="line">            SomeField2, </div><div class="line">            SomeField3</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::RemLengthMemberField&lt;0&gt;, <span class="comment">// Index of the remaining length field is 0</span></div><div class="line">        TExtraOptions...</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = ...;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(length, f1, f2, f3);</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="sec_field_tutorial_array_list"></a>
Array List Fields</h1>
<p>Some communication protocols may define messages that transmit sequence of similar fields and/or raw data buffers. To make it easier to handle, the COMMS library provides <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> field which provide a required interface to properly handle such sequences of data. It supports a sequence of raw bytes </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MySimpleList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::uint8_t</div><div class="line">    &gt;;</div></div><!-- fragment --><p> as well as using sequence of any fields defined in <a class="el" href="namespacecomms_1_1field.html" title="Namespace that contains definitions of all message fields. ">comms::field</a> namespace </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyComplexList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        MyBundle&lt;&gt; <span class="comment">// Complex bundle field, defined in previous section </span></div><div class="line">    &gt;;</div></div><!-- fragment --><p> By default the read operation on <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> continues as long as there is data left in input buffer, and write operation serialises all the data stored in internal vector. These default behaviours can be changed using options described below.</p>
<h2><a class="anchor" id="sec_field_tutorial_array_list_size_prefix"></a>
Prefixing with Size Information</h2>
<p>Very often variable size sequences of raw bytes or other fields get prefixed with size information. The default behaviour of the <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> is to read until the end of the buffer. Having sequence prefixed with number of elements to follow, allows earlier termination of the read operation, and allows having other independent fields to be appended after the sequence. The <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> class supports <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a> option that allows to specify type of the size field (usually a variant of <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>) to be serialised before the contents of <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> being serialised. For example, the serialised raw bytes sequence is prefixed with 2 bytes of size information: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> SizePrefixField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::uint8_t,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix&lt;SizePrefixField&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x0, 0x3, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line">MyList myList;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"><span class="keyword">auto</span> es = myList.<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a>(readIter, InputBufferSize); </div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(myList.value().size() == 3U); <span class="comment">// Reading only 3 elements</span></div><div class="line">assert((myList.value())[0] == 0xa); <span class="comment">// First element</span></div><div class="line">assert((myList.value())[1] == 0xb); <span class="comment">// Second element </span></div><div class="line">assert((myList.value())[2] == 0xc); <span class="comment">// Third element</span></div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 5); <span class="comment">// Expected to consume 2 first bytes of the size + ,</span></div><div class="line">                                                       <span class="comment">// number of elements size specified (=3). Overall 5 bytes consumed </span></div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outputBuffer;</div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outputBuffer);</div><div class="line">es = myList.write(writeIter, outputBuffer.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(outputBuffer.size() == 5U); <span class="comment">// Expected to write 5 bytes, 2 bytes for size, and 3 for elements.</span></div><div class="line">assert(std::equal(outputBuffer.begin(), outputBuffer.end(), std::begin(InputBuffer)); <span class="comment">// The output must be equal to</span></div></div><!-- fragment --><p>Some protocols prefix the sequence with <b>serialisation length</b> rather than <b>number of elements to follow</b>. In this case the <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSerLengthFieldPrefix.html">comms::option::def::SequenceSerLengthFieldPrefix</a> option needs to be used instead of <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>.</p>
<h2><a class="anchor" id="sec_field_tutorial_array_list_elem_length_prefix"></a>
Element Serialisation Length Prefix</h2>
<p>Also some protocols, for easier exchange of lists between nodes that use different versions of the same protocol, may require prefixing <b>every element</b> of the list with its serialisation length. In this case <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix</a> option may be used. For example, the list of bundles prefixed with 2 bytes specifying number of elements to follow, and with every element prefixed with its serialisation length using variable length base-128 encoding may look like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> SizePrefixField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div><div class="line"><span class="keyword">using</span> ElemLengthPrefixField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::uint32_t,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1VarLength.html">comms::option::def::VarLength&lt;1, 4&gt;</a> <span class="comment">// variable length encoding up to 4 bytes</span></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        MyBundle, <span class="comment">// some bundle of fields</span></div><div class="line">        comms::option::def::SequenceSizeFieldPrefix&lt;SizePrefixField&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceElemSerLengthFieldPrefix.html">comms::option::def::SequenceElemSerLengthFieldPrefix&lt;ElemLengthPrefixField&gt;</a></div><div class="line">    &gt;;</div></div><!-- fragment --><p> When every element of the list is of fixed size, i.e. has the same serialisation length, it becomes redundant to prefix <b>every</b> element with its length. Instead, only first element can be prefixed with one, and all others may reuse the same information. To achieve such behaviour <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix</a> should be used instead. For example, the list of <b>fixed length</b> bundles prefixed with 1 byte specifying number of elements to follow, and with first element prefixed with 1 byte containing its serialisation length may look like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> SizePrefixField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a>;</div><div class="line"><span class="keyword">using</span> ElemLengthPrefixField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">            MyFieldBase,</div><div class="line">            std::tuple&lt;</div><div class="line">                <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>,</div><div class="line">                <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a></div><div class="line">            &gt;</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::SequenceSizeFieldPrefix&lt;SizePrefixField&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceElemFixedSerLengthFieldPrefix.html">comms::option::def::SequenceElemFixedSerLengthFieldPrefix&lt;ElemLengthPrefixField&gt;</a></div><div class="line">    &gt;;</div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_array_list_detached_size_prefix"></a>
Detached Size Information</h2>
<p>There may be cases when size information is detached from the sequence itself, i.e. there are other fields between the size field and the sequence itself. For example, the protocol specifies the following: </p><table class="doxtable">
<tr>
<th align="center">Byte Offset </th><th align="center">Length </th><th align="center">Description  </th></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td><td align="center">Number of elements in sequence </td></tr>
<tr>
<td align="center">1 </td><td align="center">1 </td><td align="center">Some flags bitmask </td></tr>
<tr>
<td align="center">2 </td><td align="center">2 * N </td><td align="center">Sequence of 2 byte integral values </td></tr>
</table>
<p>In this case the option <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a> can NOT be used. In fact the size information is not a part of the sequence any more, it must be a separate independent field. When this field is successfully read, its value must be forced upon the sequence somehow before the read operation of the sequence takes place. To help with such forcing, <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a> option was introduced. When this option used, the <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a94688b8f24a97e863dbfd6b537410c43" title="Force number of elements that must be read in the next read() invocation. ">comms::field::ArrayList::forceReadElemCount</a> member function of the field may be used to force number of elements that follow. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> SeqSizeField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;;</div><div class="line"><span class="keyword">using</span> BitmaskField = comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt;;</div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceSizeForcingEnabled.html">comms::option::def::SequenceSizeForcingEnabled</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x3, 0xff, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"><span class="keyword">auto</span> remSize = InputBufferSize;</div><div class="line"></div><div class="line">SeqSizeField sizeField;</div><div class="line"><span class="keyword">auto</span> es = sizeField.<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a>(readIter, remSize); </div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(sizeField.value() == 3U); <span class="comment">// First byte should be read;</span></div><div class="line"></div><div class="line">remSize -= sizeField.length();</div><div class="line">BitmaskField bitmask;</div><div class="line">es = bitmask.read(readIter, remSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(bitmask.value() == 0xff); <span class="comment">// Second byte should be read;</span></div><div class="line"></div><div class="line">remSize -= bitmask.length();</div><div class="line">MyList myList;</div><div class="line">myList.forceReadElemCount(sizeField.value()); <span class="comment">// Force number of elements to read</span></div><div class="line">es = myList.read(readIter, remSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(myList.value().size() == 3U); <span class="comment">// Reading only 3 elements</span></div><div class="line">assert((myList.value())[0] == 0xa); <span class="comment">// First element</span></div><div class="line">assert((myList.value())[1] == 0xb); <span class="comment">// Second element </span></div><div class="line">assert((myList.value())[2] == 0xc); <span class="comment">// Third element</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_array_list_force_element_size"></a>
Forcing Element Serialisation Length</h2>
<p>In addition to prefixing variable length lists with amount of elements to follow, some protocols may also prefix them with serialisation length of the <b>single element</b>. Such technique is usually used to maintain data exchange compatibility with earlier versions of the protocol, which may be used on the other side of the communication link. The <b>COMMS</b> library allows forcing the serialisation length of a single element when such information becomes available. It is similar to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list_detached_size_prefix">Detached Size Information</a>. The option <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceElemLengthForcingEnabled.html">comms::option::def::SequenceElemLengthForcingEnabled</a> needs to be used when defining the field type, and <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a9cc0795d98464b2825ff25815a68f3fb">comms::field::ArrayList::forceReadElemLength()</a> and <a class="el" href="classcomms_1_1field_1_1ArrayList.html#a1c8e803cfa8f3d995d1e1816df59c93b">comms::field::ArrayList::clearReadElemLengthForcing()</a> functions to set/clear the forcing information. </p><div class="fragment"><div class="line"><span class="comment">// Common base class for all the fields</span></div><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"></div><div class="line"><span class="comment">// Field used to serialise serialisation length of a single element in the list</span></div><div class="line"><span class="keyword">using</span> ElemLengthPrefixField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Field used to serialise number of elements in the list</span></div><div class="line"><span class="keyword">using</span> SizePrefixField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt; <span class="comment">// 3 bytes integers</span></div><div class="line">            MyFieldBas, </div><div class="line">            std::uint32_t, </div><div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength&lt;3&gt;</a> &gt;,</div><div class="line">        comms::option::def::SequenceSizeFieldPrefix&lt;SizePrefixField&gt;, <span class="comment">// 1 byte prefix</span></div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceElemLengthForcingEnabled.html">comms::option::def::SequenceElemLengthForcingEnabled</a> <span class="comment">// enable forcing of the element length</span></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x4, <span class="comment">// single element serialisation length</span></div><div class="line">    0x2, <span class="comment">// number of elements in the list,</span></div><div class="line">    0xa, 0xa, 0xa, 0x0, <span class="comment">// first element + padding </span></div><div class="line">    0xb, 0xb, 0xb, 0x0 <span class="comment">// second element + padding</span></div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line">ElemLengthPrefixField lengthPrefix;</div><div class="line">MyList myList;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"><span class="keyword">auto</span> es = lengthPrefix(readIter, InputBufferSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(lengthPrefix.value() == 4U);</div><div class="line"></div><div class="line">myList.forceReadElemLength(lengthPrefix.value()); <span class="comment">// force serialisation length of the single element</span></div><div class="line"><span class="keyword">auto</span> es = myList.read(readIter, InputBufferSize - lengthPrefix.length()); </div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(myList.value().size() == 2U); <span class="comment">// Reading only 2 elements</span></div><div class="line">assert((myList.value())[0] == 0x0a0a0a); <span class="comment">// First element</span></div><div class="line">assert((myList.value())[1] == 0x0b0b0b); <span class="comment">// Second element </span></div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 10); <span class="comment">// Expected to consume in the</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_array_list_term_suffix"></a>
Terminating Sequence with Suffix</h2>
<p>Sometimes there is no information about size of the sequence up front. It may be terminating using some kind of special value. For example, the sequence of raw bytes is terminated by the value of 0. Such termination is achieved by using <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a> option. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> TermField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;; <span class="comment">// Default value is 0.</span></div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix&lt;TermField&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x1, 0x2, 0x3, 0x4, 0x0, 0xa, 0xb, 0xc</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"></div><div class="line">MyList myList;</div><div class="line">es = myList.<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a>(readIter, InputBufferSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(myList.value().size() == 4U); <span class="comment">// Reading only 4 elements, terminating 0 is not included</span></div><div class="line">assert((myList.value())[0] == 0x1); <span class="comment">// First element</span></div><div class="line">assert((myList.value())[1] == 0x2); <span class="comment">// Second element </span></div><div class="line">assert((myList.value())[2] == 0x3); <span class="comment">// Third element</span></div><div class="line">assert((myList.value())[4] == 0x4); <span class="comment">// Fourth element</span></div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 5); <span class="comment">// Expected to consume all bytes including termination one </span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_array_list_fixed_size"></a>
Fixed Size Sequences</h2>
<p>In many cases the size of the sequence is defined in the protocol without any prefix or suffix to define the length of the sequence. To define such sequence <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option should be used. Below is example of how to define sequence of four unsigned 16 bit integer values. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyList = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;4&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x0, 0x1, 0x0, 0x2, 0x0, 0x3, 0x0, 0x4, 0xa, 0xb, 0xc</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"></div><div class="line">MyList myList;</div><div class="line">es = myList.<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a>(readIter, InputBufferSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">assert(myList.value().size() == 4U); <span class="comment">// Reading only 4 elements</span></div><div class="line">assert((myList.value())[0] == 0x1); <span class="comment">// First element</span></div><div class="line">assert((myList.value())[1] == 0x2); <span class="comment">// Second element </span></div><div class="line">assert((myList.value())[2] == 0x3); <span class="comment">// Third element</span></div><div class="line">assert((myList.value())[4] == 0x4); <span class="comment">// Fourth element</span></div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 8); <span class="comment">// Consumed only 4 element (2 bytes each) </span></div></div><!-- fragment --><p> <b>NOTE</b>, that <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html" title="Option used to define exact number of elements in the collection field. ">comms::option::def::SequenceFixedSize</a> option insures existence of the right number of elements "on the wire", but doesn't influence number of elements in the newly created list field: </p><div class="fragment"><div class="line">MyList myList;</div><div class="line"><span class="keyword">auto</span>&amp; storageVector = myList.value();</div><div class="line">assert(storageVector.empty());</div></div><!-- fragment --><p> Also nothing prevents from having too many values in the storage vector, but only specified number of the elements will be serialised: </p><div class="fragment"><div class="line">myList.push_back(0x1); <span class="comment">// will be serialised</span></div><div class="line">myList.push_back(0x2); <span class="comment">// will be serialised</span></div><div class="line">myList.push_back(0x3); <span class="comment">// will be serialised</span></div><div class="line">myList.push_back(0x4); <span class="comment">// will be serialised</span></div><div class="line">myList.push_back(0x5); <span class="comment">// WON&#39;T be serialised</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_array_list_storage"></a>
Value Storage</h2>
<p>By default, the internal data is stored using <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector</a>. </p><div class="fragment"><div class="line">MySimpleList simpleList; <span class="comment">// defined above</span></div><div class="line"><span class="keyword">auto</span>&amp; simpleListStorage = simpleList.value(); <span class="comment">// reference to std::vector&lt;std::uint8_t&gt;;</span></div><div class="line"></div><div class="line">MyComplexList complexList; <span class="comment">// defined above</span></div><div class="line"><span class="keyword">auto</span>&amp; complexListStorage = complexList.value(); <span class="comment">// reference to std::vector&lt;MyBundle&gt;;</span></div></div><!-- fragment --><p> This behaviour can be modified using extra options such as <a class="el" href="structcomms_1_1option_1_1app_1_1CustomStorageType.html">comms::option::app::CustomStorageType</a>, <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a>, <a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a>, or <a class="el" href="structcomms_1_1option_1_1app_1_1SequenceFixedSizeUseFixedSizeStorage.html">comms::option::app::SequenceFixedSizeUseFixedSizeStorage</a>. <b>HOWEVER</b>, these options do not influence the way how list fields are being serialised, they influence the way how list value has been stored. As the result, they should <b>NOT</b> be used in protocol definition. Instead, provide a way to to the actual application to modify the default storage by passing extra options. For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div><div class="line"><span class="keyword">using</span> MyList = <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;..., TExtraOptions...&gt;;</div></div><!-- fragment --><p>All the <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options">Common Options or Modifications for the Fields</a> are also applicable to <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> field.</p>
<h1><a class="anchor" id="sec_field_tutorial_string"></a>
String Fields</h1>
<p>Many protocols have to transfer strings. They are defined using <a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a> field. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyString = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String&lt;MyFieldBase&gt;</a>;</div></div><!-- fragment --><p> It is very similar to <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a> it terms of value storage, read/write operations, and supported options. By default the value is stored as <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </p><div class="fragment"><div class="line">MyString myStr;</div><div class="line"><span class="keyword">auto</span>&amp; myStrStorage = myStr.value(); <span class="comment">// Reference to std::string.</span></div></div><!-- fragment --><p> Just like described in <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list_storage">Value Storage</a> section above the same options can be used to modify the storage type of the <a class="el" href="classcomms_1_1field_1_1String.html" title="Field that represents a string. ">comms::field::String</a> field, but should <b>NOT</b> be used in protocol definition, but instead there should be an ability to provide extra options. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOptions&gt;</div><div class="line"><span class="keyword">using</span> MyString = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;MyFieldBase, TExtraOptions...&gt;;</div></div><!-- fragment --><p>Prefixing string with single byte of the size information will look like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> SizePrefixField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;;</div><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::SequenceSizeFieldPrefix&lt;SizePrefixField&gt; </div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyString myStr;</div><div class="line">myStr.<a class="code" href="classcomms_1_1field_1_1String.html#a0e002dfe8e35a45a480a108c91bb5d46">value</a>() = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outputBuf;</div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outputBuf);</div><div class="line"><span class="keyword">auto</span> es = myStr.write(writeIter, outputBuf.max_size());</div><div class="line">assert(es = <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outputBuf.size() == 6U); <span class="comment">// 1 byte of size, followed by 5 characters of &quot;hello&quot; string</span></div><div class="line">assert(outputBuf[0] == 5U); <span class="comment">// size info</span></div><div class="line">assert(outputBuf[1] == <span class="charliteral">&#39;h&#39;</span>);</div><div class="line">assert(outputBuf[2] == <span class="charliteral">&#39;e&#39;</span>);</div><div class="line">assert(outputBuf[3] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[4] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[5] == <span class="charliteral">&#39;o&#39;</span>);</div></div><!-- fragment --><p> See also <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list_size_prefix">Prefixing with Size Information</a>.</p>
<p>Encoding of zero termination strings without size prefix can be defined like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> ZeroTermField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;; <span class="comment">// default value is 0</span></div><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix&lt;ZeroTermField&gt;</a> </div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyString myStr;</div><div class="line">myStr.value() = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outputBuf;</div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outputBuf);</div><div class="line"><span class="keyword">auto</span> es = myStr.write(writeIter, outputBuf.max_size());</div><div class="line">assert(es = <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outputBuf.size() == 6U); <span class="comment">// 5 characters of &quot;hello&quot; string followed by zero termination suffix</span></div><div class="line">assert(outputBuf[0] == <span class="charliteral">&#39;h&#39;</span>);</div><div class="line">assert(outputBuf[1] == <span class="charliteral">&#39;e&#39;</span>);</div><div class="line">assert(outputBuf[2] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[3] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[4] == <span class="charliteral">&#39;o&#39;</span>);</div><div class="line">assert(outputBuf[5] == 0U);</div></div><!-- fragment --><p> See also <a class="el" href="page_field_tutorial.html#sec_field_tutorial_array_list_term_suffix">Terminating Sequence with Suffix</a>.</p>
<p>Another string example is to have zero terminated string, the serialisation of which occupies exactly 32 bytes, i.e. the string may have up to 31 non-zero characters. If string is too short, the serialisation data is padded by zeros until full length of 32 characters is produced. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> ZeroTermField = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;; <span class="comment">// default value is 0</span></div><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;31&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix&lt;ZeroTermField&gt;</a> </div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyString myStr;</div><div class="line">myStr.value() = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outputBuf;</div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outputBuf);</div><div class="line"><span class="keyword">auto</span> es = myStr.write(writeIter, outputBuf.max_size());</div><div class="line">assert(es = <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected</span></div><div class="line">assert(outputBuf.size() == 32); <span class="comment">// 5 characters of &quot;hello&quot; string followed by zero padding</span></div><div class="line">assert(outputBuf[0] == <span class="charliteral">&#39;h&#39;</span>);</div><div class="line">assert(outputBuf[1] == <span class="charliteral">&#39;e&#39;</span>);</div><div class="line">assert(outputBuf[2] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[3] == <span class="charliteral">&#39;l&#39;</span>);</div><div class="line">assert(outputBuf[4] == <span class="charliteral">&#39;o&#39;</span>);</div><div class="line">assert(outputBuf[5] == 0U);</div><div class="line">...</div><div class="line">assert(outputBuf[31] == 0U);  </div></div><!-- fragment --><p> <b>NOTE</b>, that the example above uses <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a> option, rather than <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a>. The options slightly differ. The "termination" one (<a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTerminationFieldSuffix.html">comms::option::def::SequenceTerminationFieldSuffix</a>) forces the field to stop reading when termination value is encountered, while "trailing" one (<a class="el" href="structcomms_1_1option_1_1def_1_1SequenceTrailingFieldSuffix.html">comms::option::def::SequenceTrailingFieldSuffix</a>) doesn't check what it reads, the reading size must be limited by other means (<a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> in the example above). When the read is complete, it just consumes the termination character. Both options, however, force the termination character to be appended at the end during write operation. <br />
<b>Also note</b>, that size limit is specified (using <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a>) to be 31. One more byte is added by the "trailing" suffix to complete to 32 bytes.</p>
<p>Just like with <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>, it is possible to use static storage for fixed size strings: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        ..., </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;16&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1SequenceFixedSizeUseFixedSizeStorage.html">comms::option::app::SequenceFixedSizeUseFixedSizeStorage</a> </div><div class="line">    &gt;;</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        ..., </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;16&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage&lt;16&gt;</a> </div><div class="line">    &gt;;</div></div><!-- fragment --><p> HOWEVER, the <a class="el" href="namespacecomms_1_1option_1_1app.html">app</a> options should be used in protocol definition, only in application customization.</p>
<h1><a class="anchor" id="sec_field_tutorial_fp_value"></a>
Floating Point Value Fields</h1>
<p>Floating point value fields (<a class="el" href="classcomms_1_1field_1_1FloatValue.html" title="Field that represent floating point value. ">comms::field::FloatValue</a>) are very similar to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value">Integral Value Fields</a>, but use <b>float</b> or <b>double</b> as its internal storage type. They abstract the IEEE 754 floating point values, which are serialised "as is" with either big or little endian encoding. The floating point value fields also support <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_units">Value Units</a> conversions.</p>
<h1><a class="anchor" id="sec_field_tutorial_optional"></a>
Optional Fields</h1>
<p>Some protocols may define optional fields, which may exist or be missing based on information recorded in other fields. For example there is a "flags" bitmask field which specifies whether the following field exists or missing. The optional field may also be tentative, i.e. if there is enough data in the input buffer it exists, and missing otherwise. The COMMS library provides <a class="el" href="classcomms_1_1field_1_1Optional.html" title="Adaptor class to any other field, that makes the field optional. ">comms::field::Optional</a> which is a mere wrapper around other fields and provides an ability to set the optional state of the field. Let's do the example of the int32 field existence based on bit 0 in processing bitmask: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> FlagsField = comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt;;</div><div class="line"><span class="keyword">using</span> OptField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div><div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::int32_t&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">FlagsField flags;</div><div class="line">OptField optField;</div><div class="line"></div><div class="line"><span class="comment">// Common read function for multiple buffers</span></div><div class="line"><span class="keyword">auto</span> readFunc = </div><div class="line">    [&amp;flags, &amp;optField](<span class="keyword">const</span> std::uint8_t*&amp; iter, std::size_t len)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> es = flags.<a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(iter, len);</div><div class="line">        assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line"></div><div class="line">        optField.setMissing();</div><div class="line">        <span class="keywordflow">if</span> ((flags.value() &amp; 0x1) != 0) {</div><div class="line">            optField.setExists();</div><div class="line">        }</div><div class="line"></div><div class="line">        es = optField.read(iter, len - flags.length());</div><div class="line">        assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No error is expected;</span></div><div class="line">    };</div><div class="line">        </div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer1[] = {</div><div class="line">    0x1, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBuffer1Size = std::extent&lt;decltype(InputBuffer1)&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">auto</span>* readIter = &amp;InputBuffer1[0];</div><div class="line">readFunc(readIter, InputBuffer1Size);</div><div class="line">assert(std::distance(&amp;InputBuffer1[0], readIter) == 5); <span class="comment">// Expected to read 1 byte of flags and</span></div><div class="line">                                                        <span class="comment">// 4 bytes of int32_t int value, because</span></div><div class="line">                                                        <span class="comment">// bit 0 in flags is set.</span></div><div class="line">assert(optField.field().value() == 0x0a0b0c0d); <span class="comment">// value is expected to be updated;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer2[] = {</div><div class="line">    0x0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBuffer2Size = std::extent&lt;decltype(InputBuffer2)&gt;::value;</div><div class="line"></div><div class="line">optField.field().<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a8736df64b0c249d26313d2d711069774">value</a>() = 0;</div><div class="line">readIter = &amp;InputBuffer2[0];</div><div class="line">readFunc(readIter, InputBuffer2Size);</div><div class="line">assert(std::distance(&amp;InputBuffer2[0], readIter) == 1); <span class="comment">// Expected to read only 1 byte of flags </span></div><div class="line">                                                        <span class="comment">// skipping read of int32_t int value, because</span></div><div class="line">                                                        <span class="comment">// bit 0 in flags is cleared.</span></div><div class="line">assert(optField.field().value() == 0); <span class="comment">// value is expected NOT to be updated;</span></div></div><!-- fragment --><p> Note, that default mode for the optional field is "tentative", which is updated after read operation: </p><div class="fragment"><div class="line">OptField optField1;</div><div class="line">assert(optField1.getMode() == <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9eaa556234919c177c5759fa36a2040bafa">comms::field::OptionalMode::Tentative</a>); <span class="comment">// Default mode is tentative</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InputBuffer[] = {</div><div class="line">    0x11, 0x22, 0x33, 0x44</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InputBufferSize = std::extent&lt;decltype(InputBuffer)&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">auto</span>* readIter = &amp;InputBuffer[0];</div><div class="line"><span class="keyword">auto</span> es = optField1.<a class="code" href="classcomms_1_1field_1_1ArrayList.html#a4233253138dfdb176deaf65102b50246">read</a>(readIter, InputBufferSize);</div><div class="line">assert(es = <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>);</div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 4); <span class="comment">// Expected to read 4 bytes of int32_t int value</span></div><div class="line">assert(optField1.getMode() == <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2a8eb028670e972535e8e246be645821">comms::field::OptionalMode::Exists</a>); <span class="comment">// Mode is changed</span></div><div class="line"></div><div class="line">OptField optField2;</div><div class="line">assert(optField2.getMode() == <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9eaa556234919c177c5759fa36a2040bafa">comms::field::OptionalMode::Tentative</a>); <span class="comment">// Default mode is tentative</span></div><div class="line">readIter = &amp;InputBuffer[0];</div><div class="line">es = optField2.read(readIter, 0); <span class="comment">// Note 0 as a buffer size</span></div><div class="line">assert(es = <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>);</div><div class="line">assert(std::distance(&amp;InputBuffer[0], readIter) == 0); <span class="comment">// Expected not to read anything</span></div><div class="line">assert(optField2.getMode() == <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2aee0be2678ee90fd327cc186826438e">comms::field::OptionalMode::Missing</a>); <span class="comment">// Mode is changed</span></div></div><!-- fragment --><p> It is easy to change the default mode of the <a class="el" href="classcomms_1_1field_1_1Optional.html" title="Adaptor class to any other field, that makes the field optional. ">comms::field::Optional</a> field by providing <a class="el" href="namespacecomms_1_1option_1_1def.html#ad1cfde1700238bbeb3f0ba8fcb08fcb6">comms::option::def::DefaultOptionalMode</a> option with selected default mode or <a class="el" href="namespacecomms_1_1option_1_1def.html#a6ec725d747184d01b7afe266f53740de">comms::option::def::MissingByDefault</a> / <a class="el" href="namespacecomms_1_1option_1_1def.html#adcd3a25551f74636157bfff761d4e39f">comms::option::def::ExistsByDefault</a> aliases. </p><div class="fragment"><div class="line"><span class="keyword">using</span> OptField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div><div class="line">        comms::field::IntValue&lt;MyFieldBase, std::int32_t&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::MissingByDefault</a> <span class="comment">// Set default mode to be &quot;missing&quot;</span></div><div class="line">    &gt;;</div></div><!-- fragment --><p> Some protocols may include version information either in transport framing or in one of the messages. Such info may specify whether a specific field exists or not. Such fields need to be wrapped in <a class="el" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a> field, which receives <a class="el" href="structcomms_1_1option_1_1def_1_1ExistsBetweenVersions.html">comms::option::def::ExistsBetweenVersions</a> option to specify the numeric versions of the protocol between which the field exists. </p><div class="fragment"><div class="line"><span class="keyword">using</span> OptField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div><div class="line">        comms::field::IntValue&lt;MyFieldBase, std::int32_t&gt;,</div><div class="line">        <a class="code" href="namespacecomms_1_1option_1_1def.html#a6ec725d747184d01b7afe266f53740de">comms::option::def::MissingByDefault</a>, <span class="comment">// Set default mode to be &quot;missing&quot;</span></div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ExistsBetweenVersions.html">comms::option::def::ExistsBetweenVersions&lt;1, 5&gt;</a></div><div class="line">    &gt;;</div></div><!-- fragment --><p> If the field has been introduced in one of the version, but hasn't been removed yet, it is possible to use <a class="el" href="namespacecomms_1_1option_1_1def.html#a3e3576aceaec1b01a812d906afc451f6">comms::option::def::ExistsSinceVersion</a> alias to <a class="el" href="structcomms_1_1option_1_1def_1_1ExistsBetweenVersions.html">comms::option::def::ExistsBetweenVersions</a>. Or the opposite, if the field has been introduced in the first version, but deprecated and removed in the later one, use <a class="el" href="namespacecomms_1_1option_1_1def.html#abc6b55c287bfb992073b1e5cbbe8337b">comms::option::def::ExistsUntilVersion</a> alias.</p>
<p>Usage of such version control option will automatically mark the optional field as <b>existing</b> or <b>missing</b> based on the provided version info in the <b>setVersion()</b> member function.</p>
<h1><a class="anchor" id="sec_field_tutorial_variant"></a>
Variant Fields</h1>
<p>Some protocols may require usage of heterogeneous fields or lists of heterogeneous fields, i.e. the ones that can be of multiple types. Good example would be a list of <b>properties</b>, where every property is a key/value pair or a TLV (type/length/value) triplet. The key (or type) is usually a numeric ID of the property, while value can be any field of any length. As an example for the key/value pairs let's define three value types: </p><ul>
<li>Unsigned integer with length of only 1 byte (<b>Value1</b>) </li>
<li>Unsigned integer with length of 4 bytes (<b>Value2</b>) </li>
<li>String field with 1 byte size prefix (<b>Value3</b>)</li>
</ul>
<p>The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones. ">comms::field::Variant</a> field to allow such heterogeneous fields. Let's implement the described example.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> Value1 = comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;;</div><div class="line"><span class="keyword">using</span> Value2 = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint32_t&gt;</a>;</div><div class="line"><span class="keyword">using</span> Value3 = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>&lt;</div><div class="line">            <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">                MyFieldBase,</div><div class="line">                std::uint8_t</div><div class="line">            &gt;</div><div class="line">        &gt;</div><div class="line">    &gt;;</div></div><!-- fragment --><p> The common key type is easy to represent as enum. </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> KeyId : std::uint8_t</div><div class="line">{</div><div class="line">    Key1,</div><div class="line">    Key2,</div><div class="line">    Key3,</div><div class="line">    NumOfValues</div><div class="line">};</div></div><!-- fragment --><p> And the relevant key fields as a variant of <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a> with only single acceptable value. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;KeyId TId&gt;</div><div class="line"><span class="keyword">using</span> KeyField =</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        KeyId,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;(int)TId&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;(int)TId, (int)TId&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid&lt;&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Key1 = KeyField&lt;KeyId::Key1&gt;;</div><div class="line"><span class="keyword">using</span> Key2 = KeyField&lt;KeyId::Key2&gt;;</div><div class="line"><span class="keyword">using</span> Key3 = KeyField&lt;KeyId::Key3&gt;;</div></div><!-- fragment --><p> Please pay attention to usage of <a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> option and having only single valid value in order to force failure of the <b>read</b> operation when the key doesn't match.</p>
<p>Then the <b>KeyX</b> and its corresponding <b>ValueX</b> need to be bundled together as a single <b>PropertyX</b> field. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</div><div class="line"><span class="keyword">class </span>Property : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            TKey,</div><div class="line">            TValue</div><div class="line">        &gt;</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition if needed</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, value);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Property1 = Property&lt;Key1, Value1&gt;;</div><div class="line"><span class="keyword">using</span> Property2 = Property&lt;Key2, Value2&gt;;</div><div class="line"><span class="keyword">using</span> Property3 = Property&lt;Key3, Value3&gt;;</div></div><!-- fragment --><p> Now we need a single <b>field</b> abstraction, which can be any of the specified above forms. The <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones. ">comms::field::Variant</a> field class provides such an ability. As its second parameter it receives a tuple of supported types. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyVariant : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;Property1, Property2, Property3&gt;</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES</a>(prop1, prop2, prop3);</div><div class="line">};</div></div><!-- fragment --><p> Similar to <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> macro for <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bundle">Bundle Fields</a>, the <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> macro generates the following convenience member enum and functions </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariant : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;</div><div class="line">{</div><div class="line">    <span class="comment">// Enumerator to access fields </span></div><div class="line">    <span class="keyword">enum</span> FieldIdx {</div><div class="line">        FieldIdx_prop1,</div><div class="line">        FieldIdx_prop2,</div><div class="line">        FieldIdx_prop3,</div><div class="line">        FieldIdx_numOfValues</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Initialize internal storage as &quot;prop1&quot;</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div><div class="line">    <span class="keyword">auto</span> initField_prop1(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop1&gt;(std::forward&lt;TArgs&gt;(args)...))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop1&gt;(std::forward&lt;TArgs&gt;(args)...)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop1&quot;</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop1() -&gt; decltype(accessField&lt;FieldIdx_prop1&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop1&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop1&quot; (const variant)</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop1() const -&gt; decltype(accessField&lt;FieldIdx_prop1&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop1&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Initialize internal storage as &quot;prop2&quot;</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div><div class="line">    <span class="keyword">auto</span> initField_prop2(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop2&gt;(std::forward&lt;TArgs&gt;(args)...))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop2&gt;(std::forward&lt;TArgs&gt;(args)...)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop2&quot;</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop2() -&gt; decltype(accessField&lt;FieldIdx_prop2&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop2&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop2&quot; (const variant)</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop2() const -&gt; decltype(accessField&lt;FieldIdx_prop2&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop2&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Initialize internal storage as &quot;prop3&quot;</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div><div class="line">    <span class="keyword">auto</span> initField_prop3(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop3&gt;(std::forward&lt;TArgs&gt;(args)...))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop3&gt;(std::forward&lt;TArgs&gt;(args)...)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop3&quot;</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop3() -&gt; decltype(accessField&lt;FieldIdx_prop3&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop3&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop3&quot; (const variant)</span></div><div class="line">    <span class="keyword">auto</span> accessField_prop3() const -&gt; decltype(accessField&lt;FieldIdx_prop3&gt;())</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop3&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Redefinition of the members fields types:</span></div><div class="line">    <span class="keyword">using</span> Field_prop1 = ...;</div><div class="line">    <span class="keyword">using</span> Field_prop2 = ...;</div><div class="line">    <span class="keyword">using</span> Field_prop3 = ...;</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, that the provided names have propagated into definition of <b>FieldIdx</b> enum, all <b>initField_*</b> and <b>accessField_*</b> functions, as well as inner <b>Field_*</b> types definitions.</p>
<p>Now it is easy to put such <b>Variant</b> field type into the list: </p><div class="fragment"><div class="line"><span class="keyword">using</span> PropertiesList = <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList&lt;MyFieldBase, MyVariant&gt;</a>;</div></div><!-- fragment --><p> In this scenario, read operation on the list will invoke read operation of every <b>MyVariant</b> field, which in turn will try to perform read operation on <b>Property1</b>, <b>Property2</b>, and <b>Property3</b> in the order of their definition inside the provided tuple. The read operation of the <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones. ">comms::field::Variant</a> field type will stop when read operation of any of the contained types reports <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38" title="Used to indicate successful outcome of the operation. ">comms::ErrorStatus::Success</a> as its status. That's why every <b>key</b> field needs to fail its <b>read</b> operation on invalid value.</p>
<p>The extension of the key/value pairs example above to TLV triplets is quite easy. </p><div class="fragment"><div class="line"><span class="comment">// No need for length prefix for strings any more</span></div><div class="line"><span class="keyword">using</span> Value3 = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String&lt;MyFieldBase&gt;</a>;</div><div class="line">...</div><div class="line">template &lt;<span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</div><div class="line"><span class="keyword">class </span>Property : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            TKey,</div><div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;, <span class="comment">// 2 byte value of remaining length</span></div><div class="line">            TValue</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::RemLengthMemberField&lt;1&gt; <span class="comment">// Index of remaining length field is 1</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, length, value);</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> usage of <a class="el" href="structcomms_1_1option_1_1def_1_1RemLengthMemberField.html">comms::option::def::RemLengthMemberField</a> option described earlier in <a class="el" href="page_field_tutorial.html#sec_field_tutorial_bundle">Bundle Fields</a> section. It informs the <b>COMMS</b> library about presence of the <b>length</b> value in the bundle, which will result in proper read length limitation for the value(s) to follow. Also in case the read of the following value(s) does not consume all the reported length, <b>COMMS</b> library will advance the read iterator to consume the remaining bytes resulting in read of the next field to be at correct location.</p>
<p>The <b>length</b> field in example above contains <b>remaining</b> length not including the field itself. Some protocols may include the length of the <b>length</b> field itself. If this is the case, just use <a class="el" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a> option (described in <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_ser_offset">Serialisation Offset</a>) to add extra numeric offset to be added when the field's value is written. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</div><div class="line"><span class="keyword">class </span>Property : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            TKey,</div><div class="line">            comms::field::IntValue&lt;</div><div class="line">                MyFieldBase, </div><div class="line">                std::uint16_t, </div><div class="line">                comms::option::def::NumValueSerOffset&lt;sizeof(std::uint16_t)&gt; </div><div class="line">            &gt;, <span class="comment">// 2 byte value of remaining length</span></div><div class="line">            TValue</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::RemLengthMemberField&lt;1&gt; <span class="comment">// Index of remaining length field is 1</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, length, value);</div><div class="line">};</div></div><!-- fragment --><p><b>RECOMMENDATION:</b> In case of <b>TLV</b> property triplets it is recommended to create a dummy field with non-failing read to allow usage of unknown properties which can be introduced in later versions of the protocol. </p><div class="fragment"><div class="line"><span class="keyword">class </span>UnknownProperty : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;, <span class="comment">// storage of unknown key</span></div><div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;, <span class="comment">// 2 byte value of remaining length</span></div><div class="line">            comms::field::ArrayList&lt;MyFieldBase, std::uint8_t&gt;, <span class="comment">// storage or raw data</span></div><div class="line">        &gt;,</div><div class="line">        comms::option::def::RemLengthMemberField&lt;1&gt; <span class="comment">// Index of remaining length field is 1</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, length, value);</div><div class="line">};</div></div><!-- fragment --><p> And put such property at the end of the supported types tuple for the variant field definition. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariant : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;Property1, Property2, Property3, UnknownProperty&gt;</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    ...</div><div class="line">};</div></div><!-- fragment --><p> The default constructed <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones. ">comms::field::Variant</a> object from the examples above has an "invalid" state, i.e. hasn't been initialized and doesn't contain any valid field. It can be changed by providing <a class="el" href="namespacecomms_1_1option_1_1def.html#a367246a4a2fa2fb908b760644e699c71">comms::option::def::DefaultVariantIndex</a> option. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariant : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;Property1, Property2, Property3&gt;,</div><div class="line">        comms::option::def::DefaultVariantIndex&lt;0&gt; <span class="comment">// Initialise as Prop1</span></div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES</a>(prop1, prop2, prop3);</div><div class="line">};</div></div><!-- fragment --><p> When instantiating such <b>MyVariant</b> object, there is no need to perform initialization (construction) of the contained object. </p><div class="fragment"><div class="line">MyVariant var;</div><div class="line">assert(var.currentFieldValid());</div><div class="line">assert(var.currentField() == 0U); <span class="comment">// Make sure the current index is 0</span></div><div class="line"><span class="keyword">auto</span>&amp; prop1 = var.accessField_prop1(); <span class="comment">// Get access to Property1 interface</span></div><div class="line">...</div></div><!-- fragment --><p> <b>SIDE NOTE:</b> In addition to <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> macro there is <a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS()</a> one. It is very similar to <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> but does <b>NOT</b> (re)define the inner <b>Field_*</b> types. It also does not require (except for <b>clang</b>) having base class to be (re)defined as inner <b>Base</b> type. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyVariant : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS</a>(prop1, prop2, prop3);</div><div class="line">}</div></div><!-- fragment --><p> In fact <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> is implemented as the wrapper around <a class="el" href="classcomms_1_1field_1_1Variant.html#a973a95f2928609a140296b28957b130b">COMMS_VARIANT_MEMBERS_ACCESS()</a>.</p>
<h1><a class="anchor" id="sec_field_tutorial_common_options"></a>
Common Options or Modifications for the Fields</h1>
<p>There are options that suitable only to numeric fields, such as <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>, <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a>, <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a>. <br />
There are options that suitable only for collection fields, such as <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields. ">comms::field::ArrayList</a>, and <a class="el" href="classcomms_1_1field_1_1String.html" title="Field that represents a string. ">comms::field::String</a>.<br />
There are also <b>common</b> options that can be used with all the fields that support options.</p>
<h2><a class="anchor" id="sec_field_tutorial_common_options_default_value"></a>
Default Value for Default Construction</h2>
<p>There may be a case when default construction of the field object should assign some custom value to the field, which differ to the usual defaults, such as assigning 0 to numeric fields or empty string to a string field.</p>
<p>One of the possible ways is to extend the defined field class and set the required value in the constructor. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">struct </span>MyString : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;MyFieldBase&gt;</div><div class="line">{</div><div class="line">    MyString()</div><div class="line">    {</div><div class="line">        <a class="code" href="classcomms_1_1field_1_1String.html#a0e002dfe8e35a45a480a108c91bb5d46">value</a>() = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Another way is to use <a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html" title="Option that specifies default initialisation class. ">comms::option::def::DefaultValueInitialiser</a> option. It receives a template parameter, which has to be a type of initialisation class. It must provide <b>operator()</b> which is responsible to assign a custom value to the field. It is going to be invoked from the default constructor of the field. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Initaliser</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(TField&amp; field)</div><div class="line">    {</div><div class="line">        field.value() = ...; <span class="comment">// Set the default value here</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CustomStringInitaliser</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(TField&amp; field)</div><div class="line">    {</div><div class="line">        field.value() = <span class="stringliteral">&quot;hello&quot;</span></div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyString = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser&lt;CustomStringInitaliser&gt;</a> </div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyString myStr; <span class="comment">// Default construction</span></div><div class="line">assert(myStr.value() == <span class="stringliteral">&quot;hello&quot;</span>); <span class="comment">// Custom default value is expected to be assigned</span></div></div><!-- fragment --><p> <b>NOTE</b> that the used <b>operator()</b> specifies the field type as a template parameter. This is required because the passed reference is to one of the defined field's base classes, which is implementation dependent. Just use the provided <b>value()</b> member function to access the value.</p>
<p>The COMMS library also provides a simpler alias for <a class="el" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a> to set default value for numeric fields. It is <a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605">comms::option::def::DefaultNumValue</a>. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyInt = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        std::uint16_t,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;10&gt;</a> </div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyInt myInt;</div><div class="line">assert(myInt.value() == 10); <span class="comment">// Custom default value is expected to be assigned</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_common_options_read"></a>
Custom Read Functionality</h2>
<p>Every field provides <b>read()</b> member function to perform read of the field's value. Sometimes the default "read" functionality may be incorrect or incomplete. For example, let's define a "bundle" field with two members. The first one is a "bitmask", while the second one is optional 2 byte "int" value. The second member exists only if least significant bit of the "bitmask" is not <b>0</b>. In this case, the provided <b>read()</b> member function won't analyse the value of the read "bitmask" and won't modify "existing"/"missing" mode value of the optional field.</p>
<p>One way to implement custom read functionality is to extend the field definition and override the <b>read()</b> member function: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">class </span>MyBundle : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt;,</div><div class="line">            comms::field::Optional&lt;MyFieldBase, std::uint16_t&gt;</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::HasCustomRead</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Provide convenience access functions    </span></div><div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(mask, value);</div><div class="line">   </div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1Bundle.html#a9e516723465cdd9123ae4cde775e89e4">read</a>(TIter&amp; iter, std::size_t len)</div><div class="line">    {</div><div class="line">        <span class="keyword">using</span> Base = <span class="keyword">typename</span> std::decay&lt;decltype(comms::field::toFieldBase(*this))&gt;::type;</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> es = Base::template readUntilAndUpdateLen&lt;FieldIdx_value&gt;(iter, len);</div><div class="line">        <span class="keywordflow">if</span> (es != <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div><div class="line">            <span class="keywordflow">return</span> es;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (field_mask().getBitValue(0)) {</div><div class="line">            field_value().setExists();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">            field_value().optInt.setMissing();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> Base::template readFrom&lt;FieldIdx_value&gt;(iter, len)</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Please <b>NOTE</b> the following: </p><ul>
<li>Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRead.html">comms::option::def::HasCustomRead</a> option. It notifies other classes about existence of custom <b>read</b> functionality (instead of default one). Other classes may contain some inner logic to perform various optimisations if there is no custom <b>read</b>. Failure to specify this option may result in incorrect behaviour. </li>
<li>If <b>Base</b> type is not specified manually, then it can be obtained using <a class="el" href="namespacecomms_1_1field.html#a9127363faf239beb7a9d44afc5c5665f">comms::field::toFieldBase()</a>. function. </li>
<li>The <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> class has set of member functions for partial reads. Thise operations can be either non-modifying input length parameter (<a class="el" href="classcomms_1_1field_1_1Bundle.html#a1625733923ab6994747cf14f2a350872">comms::field::Bundle::readFrom()</a>, <a class="el" href="classcomms_1_1field_1_1Bundle.html#a1b02b27872db689a00dc875b72fe25b1">comms::field::Bundle::readUntil()</a>, and <a class="el" href="classcomms_1_1field_1_1Bundle.html#adb61a1129588cd0247b889ec0c563be6">comms::field::Bundle::readFromUntil()</a>) or modifying (<a class="el" href="classcomms_1_1field_1_1Bundle.html#add2775508ee526810fcdec29a2c3998d">comms::field::Bundle::readFromAndUpdateLen()</a>, <a class="el" href="classcomms_1_1field_1_1Bundle.html#ad50e91d0694ccebdfb1f727b2463fca9">comms::field::Bundle::readUntilAndUpdateLen()</a>, and <a class="el" href="classcomms_1_1field_1_1Bundle.html#adc64a4a144f9fc7d2b03842eba8ba4ff">comms::field::Bundle::readFromUntilAndUpdateLen()</a>). The latter can be used to automatically reduce remaining length value.</li>
</ul>
<p>Another way is to use <a class="el" href="structcomms_1_1option_1_1def_1_1CustomValueReader.html">comms::option::def::CustomValueReader</a> option. It receives one template parameter, which has to be a type of a custom reader class. Such class must implement <b>operator()</b> with the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyReader</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> operator()(TField&amp; field, TIter&amp; iter, std::size_t len)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        ... <span class="comment">// Do proper read of the field&#39;s value.</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> that the used <b>operator()</b> specifies the field type as a template parameter. This is required because the passed reference is to one of the defined field's base classes, which is implementation dependent. Just use the provided <b>value()</b> member function to access the tuple of member fields.</p>
<h2><a class="anchor" id="sec_field_tutorial_common_options_validation"></a>
Custom Value Validation Logic</h2>
<p>Every field provides <b>valid()</b> member function to validate the internal value. By default, every internal value of the field is considered to be valid, i.e. the <b>valid()</b> function will always return true.</p>
<p>One of the ways to provide custom validation logic is to extend the field definition and implement <b>valid()</b> member function: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">struct </span>MyString : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;MyFieldBase&gt;</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1String.html#a9f2b5171df5684603817cfbb07d0e3d9">valid</a>()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Valid if not empty and starts with &#39;$&#39;</span></div><div class="line">        <span class="keywordflow">return</span> (!<a class="code" href="classcomms_1_1field_1_1String.html#a0e002dfe8e35a45a480a108c91bb5d46">value</a>().empty()) &amp;&amp; (<a class="code" href="classcomms_1_1field_1_1String.html#a0e002dfe8e35a45a480a108c91bb5d46">value</a>()[0] == <span class="charliteral">&#39;$&#39;</span>);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Another way is to use <a class="el" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a> option. It receives one template parameter, which has to be a type of a custom validator class. Such class must implement <b>operator()</b> with the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyValidator</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> TField&amp; field)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span>&amp; value = field.value();</div><div class="line">        <span class="keywordflow">return</span> (... <span class="comment">/* Check value */</span>); <span class="comment">// return true if valid.</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CustomStringValidator</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> TField&amp; field)</div><div class="line">    {</div><div class="line">        <span class="comment">// Valid if not empty and starts with &#39;$&#39;</span></div><div class="line">        <span class="keyword">auto</span>&amp; str = field.value();</div><div class="line">        <span class="keywordflow">return</span> (!str.empty()) &amp;&amp; (str[0] == <span class="charliteral">&#39;$&#39;</span>);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyString = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div><div class="line">    MyFieldBase, </div><div class="line">    <a class="code" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator&lt;CustomStringValidator&gt;</a> </div><div class="line"> &gt;;</div><div class="line"></div><div class="line">MyString myStr; </div><div class="line">assert(!myStr.valid()); <span class="comment">// Default construction creates empty string - invalid</span></div><div class="line"></div><div class="line">myStr.value() = <span class="stringliteral">&quot;$somestring&quot;</span>;</div><div class="line">assert(myStr.valid()); <span class="comment">// Now the string is as expected</span></div></div><!-- fragment --><p> <b>NOTE</b> that the used <b>operator()</b> specifies the field type as a template parameter. This is required because the passed reference is to one of the defined field's base classes, which is implementation dependent. Just use the provided <b>value()</b> member function to access the value.</p>
<p>Quite often the valid values of the numeric fields can be expressed in limited number of ranges: [minValid - maxValid]. The COMMS library provides <a class="el" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a> option (and <a class="el" href="namespacecomms_1_1option_1_1def.html#a8ca4dd158c2eb6e8b58a2640b1e4d04d">comms::option::def::ValidNumValue</a> alias), which can be used multiple times. The field's value is considered to be valid if <b>at least one</b> of the provided ranges contains it. The range validation option can be used only with numeric value fields, such as <a class="el" href="classcomms_1_1field_1_1IntValue.html" title="Field that represent integral value. ">comms::field::IntValue</a>, or <a class="el" href="classcomms_1_1field_1_1EnumValue.html" title="Enumerator value field. ">comms::field::EnumValue</a>. For example: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> SomeEnum : std::uint8_t</div><div class="line">{</div><div class="line">    SomeEnum_Value1 = 1,</div><div class="line">    SomeEnum_Value2,</div><div class="line">    SomeEnum_Value3</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyEnum = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        SomeEnum,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;SomeEnum_Value1&gt;</a>, <span class="comment">// Construct with valid value</span></div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;SomeEnum_Value1, SomeEnum_Value3&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyEnum myEnum;</div><div class="line">assert(myEnum.value() == SomeEnum_Value1);</div><div class="line">assert(myEnum.valid());</div><div class="line"></div><div class="line">myEnum.value() = <span class="keyword">static_cast&lt;</span>SomeEnum<span class="keyword">&gt;</span>(0); <span class="comment">// Assigning invalid value.</span></div><div class="line">assert(!myEnum.valid()); <span class="comment">// The field being invalid must be reported</span></div></div><!-- fragment --><p>Another example could be a single character numeric field with valid values range of [0x20 - 0x7e], as well as value 0. Such field can be defined as: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyChar = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        char,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;0x20, 0x7e&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValue&lt;0&gt;</a></div><div class="line">    &gt;;</div></div><!-- fragment --><p> <b>WARNING:</b> Some older compilers (<b>gcc-4.7</b>) fail to compile valid C++11 code that allows usage of multiple <a class="el" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a> options. If this is the case, please don't pass more than one <a class="el" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a> option.</p>
<p>There is a also a convenience alias to <a class="el" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::ContentsValidator</a> intended for use with bitmasks (<a class="el" href="classcomms_1_1field_1_1BitmaskValue.html" title="Bitmask value field. ">comms::field::BitmaskValue</a>). Many bitmask fields may have one or several reserved bits with predefined values they must contain. The alias option is <a class="el" href="namespacecomms_1_1option_1_1def.html#ab250f5104df4cfe83741d63e6db70505">comms::option::def::BitmaskReservedBits</a>. It receives two template parameters: one for the mask indicating the reserved bits and another for the expected values of these bits.<br />
For example, below is a definition of the 1 byte bitmask field that has two reserved bits, most and least significant. Both of them must be 0. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyFlags = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div><div class="line">        MyFieldBase, </div><div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ContentsValidator.html">comms::option::def::BitmaskReservedBits&lt;0x81, 0&gt;</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line">MyFlags flags;</div><div class="line">assert(myEnum.valid());</div><div class="line">flags.value() |= 0x1; <span class="comment">// set bit 0;</span></div><div class="line">assert(!flags.valid()); <span class="comment">// the field is invalid now.</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_common_options_refresh"></a>
Custom Refresh Functionality</h2>
<p>Every field provides <b>refresh()</b> member function used to bring the field's value into a consistent state. By default this function does nothing and returns <b>false</b>, meaning the field has <b>NOT</b> been updated. For complex fields, such as <a class="el" href="classcomms_1_1field_1_1Bitfield.html" title="Bitfield field. ">comms::field::Bitfield</a> or <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field. ">comms::field::Bundle</a>, the default behaviour is to invoke <b>refresh()</b> member function of each member field and return <b>true</b> if <b>any</b> of the calls returned true.</p>
<p>One way to change such default behaviour is to extend the field definition and implement <b>refresh()</b> member function. Let's take the same example as in <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options_read">Custom Read Functionality</a> section. There is a "bundle" field with two members. The first one is a "bitmask", while the second one is optional 2 byte "int" value. The second member exists only if least significant bit of the "bitmask" is not <b>0</b>. There is a chance of having inconsistent state when the least significant bit in the "bitmask" is set, but the optional "int" field is marked to be "missing". There is a need to provide the custom "refresh" logic that brings the field's contents into a consistent state. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">struct </span>MyBundle : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;</div><div class="line">            comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt;,</div><div class="line">            comms::field::Optional&lt;MyFieldBase, std::uint16_t&gt;</div><div class="line">        &gt;,</div><div class="line">        comms::option::def::HasCustomRead,</div><div class="line">        comms::option::def::HasCustomRefresh</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    ... </div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1Bundle.html#af80c2f4e7c0283dbaf730451757a8ad8">refresh</a>()</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> expectedMode = <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2aee0be2678ee90fd327cc186826438e">comms::field::OptionalMode::Missing</a>;</div><div class="line">        <span class="keywordflow">if</span> (field_mask().getBitValue(0)) {</div><div class="line">            expectedMode = <a class="code" href="namespacecomms_1_1field.html#ab1a00acfb597ac892cc9d5a73740ad9ea2a8eb028670e972535e8e246be645821">comms::field::OptionalMode::Exists</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (field_value().getMode() == expectedMode) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Nothing has been changed</span></div><div class="line">        }</div><div class="line">    </div><div class="line">        field_value().setMode(expectedMode);</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// Field has been updated</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> the usage of <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomRefresh.html">comms::option::def::HasCustomRefresh</a> option. It notifies other classes about existence of custom <b>refresh</b> functionality (instead of default one). Other classes may contain some inner logic to perform various optimisations if there is no custom <b>refresh</b>. Failure to specify this option may result in incorrect behaviour.</p>
<p>Another way is to use <a class="el" href="structcomms_1_1option_1_1def_1_1ContentsRefresher.html" title="Option that specifies custom refreshing class. ">comms::option::def::ContentsRefresher</a> option. It receives one template parameter, which has to be a type of a custom refresher class. Such class must implement <b>operator()</b> with the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyRefresher</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField&gt;</div><div class="line">    <span class="keywordtype">bool</span> operator()(TField&amp; field)</div><div class="line">    {</div><div class="line">        ... <span class="comment">// return true if field was modified, false otherwise</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> that the used <b>operator()</b> specifies the field type as a template parameter. This is required because the passed reference is to one of the defined field's base classes, which is implementation dependent. Just use the provided <b>value()</b> member function to access the value.</p>
<h2><a class="anchor" id="sec_field_tutorial_common_options_write"></a>
Custom Write Functionality</h2>
<p>On some very rare occasions there may be a need to write custom <b>write</b> functionality. It can be achieved by writing custom <b>write()</b> member function </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">struct </span>MyBundle : <span class="keyword">public</span> </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::tuple&lt;...&gt;,</div><div class="line">        comms::option::def::HasCustomWrite</div><div class="line">    &gt;</div><div class="line">{</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1Bundle.html#a70f67eb58a758643e5a3d1ae12429ef5">write</a>(TIter&amp; iter, std::size_t len)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        ...</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b> usage of <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomWrite.html">comms::option::def::HasCustomWrite</a> option. It is required to let prevent field holding <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class from attempting to optimize write operation due to possible incorrect behavior.</p>
<h2><a class="anchor" id="sec_field_tutorial_common_options_version"></a>
Custom Version Update Functionality</h2>
<p>Some protocols may include version information either in the transport framing of every message or in one of the messages used to establish connection. Such info may influence whether some fields exist, as well as modify other aspects of the fields, such as validity ranges.</p>
<p>Every field provides <b>setVersion()</b> member function used to notify it about the version change and <b>isVersionDependent()</b> one to inquire at compile time whether the field contents may change after such notification. For most fields <b>setVersion()</b> function does nothing and returns <b>false</b>, meaning the field has <b>NOT</b> been updated (similar to <a class="el" href="page_field_tutorial.html#sec_field_tutorial_common_options_refresh">Custom Refresh Functionality</a>). For complex fields, such as <a class="el" href="classcomms_1_1field_1_1Bitfield.html" title="Bitfield field. ">comms::field::Bitfield</a> or <a class="el" href="classcomms_1_1field_1_1Bundle.html" title="Bundles multiple fields into a single field. ">comms::field::Bundle</a>, the default behaviour is to invoke <b>setVersion()</b> member function of each member field and return <b>true</b> if <b>any</b> of the calls returned <b>true</b>. For <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> fields, the version information may be stored inside (only if the element's <b>isVersionDependent()</b> member function returns <b>true</b>) and used to notify every new field that is being read during <b>read</b> operation.</p>
<p>Usually, the default version handling provided by the <b>COMMS</b> library is good enough. However, there may be cases when custom operation needs to be performed during version update. For example, there is integral value field with valid values range [0, 5]. There is a need to report field as being invalid for any other numbers for all version up to <b>5</b>. However, since version <b>6</b> the range is extended to [0, 10]. It can be defined as following: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyInt : <span class="keyword">public</span></div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::uint8_t,</div><div class="line">        comms::option::def::ValidNumValueRange&lt;0, 5&gt;,</div><div class="line">        comms::option::def::HasCustomVersionUpdate</div><div class="line">{</div><div class="line">    using Base = comms::field::IntValue&lt;...&gt;; <span class="comment">// Repeat base class definition</span></div><div class="line">public:</div><div class="line">    <span class="comment">// Updated validity check</span></div><div class="line">    bool valid() const</div><div class="line">    {</div><div class="line">        if (Base::valid()) {</div><div class="line">            return true;</div><div class="line">        }</div><div class="line">        </div><div class="line">        if (m_version &lt; 6) {</div><div class="line">            return false;</div><div class="line">        }</div><div class="line"></div><div class="line">        return value() &lt;= 10;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Updated version set</span></div><div class="line">    <span class="comment">// Store version internally for future references</span></div><div class="line">    bool setVersion(VersionType version)</div><div class="line">    {</div><div class="line">        m_version = version;</div><div class="line">        return Base::setVersion(version);</div><div class="line">    }</div><div class="line"></div><div class="line">private:</div><div class="line">    VersionType m_version = 0;</div><div class="line">};</div></div><!-- fragment --><p> <b>NOTE</b>, the usage of <a class="el" href="structcomms_1_1option_1_1def_1_1HasCustomVersionUpdate.html">comms::option::def::HasCustomVersionUpdate</a> option. It marks the defined field as "version dependent" and as the result its <b>isVersionDependent()</b> member function will return <b>true</b>.</p>
<p>Also <b>NOTE</b>, that by default the <b>VersionType</b> inner type is defined to be <b>unsigned</b>. If there is a need to change that, the <a class="el" href="structcomms_1_1option_1_1def_1_1VersionType.html">comms::option::def::VersionType</a> needs to be passed to the definition of the common base class of all the fields: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = </div><div class="line">    <a class="code" href="classcomms_1_1Field.html">comms::Field</a>&lt;</div><div class="line">        <a class="code" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1VersionType.html">comms::option::def::VersionType&lt;unsigned long long&gt;</a></div><div class="line">    &gt;;</div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_common_options_fail_invalid"></a>
Fail on Invalid Value</h2>
<p>Sometimes the protocol specifications may impose a strict rules on disallowing invalid values, such as the message must be dropped when some field has an invalid value. It is easy to implement by forcing <b>read()</b> operation on such field to fail when reading an invalid value is recognised. The COMMS library provides <a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html" title="Option that forces field&#39;s read operation to fail if invalid value is received. ">comms::option::def::FailOnInvalid</a> option to help with such task. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        MyFieldBase,</div><div class="line">        std::uint8_t,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;0, 5&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a></div><div class="line">    &gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InvalidBuf[] = { 0x6 };</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InvalidBufSize = std::extent&lt;decltype(InvalidBuf)&gt;::value;</div><div class="line"></div><div class="line">MyField myField;</div><div class="line"><span class="keyword">auto</span>* readIter = &amp;InvalidBuf[0];</div><div class="line"><span class="keyword">auto</span> es = myField.<a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(readIter, InvalidBufSize);</div><div class="line">assert(es != <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// Read failure is expected</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t ValidBuf[] = { 0x1 };</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> ValidBufSize = std::extent&lt;decltype(ValidBuf)&gt;::value;</div><div class="line"></div><div class="line">readIter = &amp;ValidBuf[0];</div><div class="line">es = myField.<a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(readIter, ValidBufSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// Read operation is expected to be successful now</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_common_options_ignore_invalid"></a>
Ignore Invalid Value</h2>
<p>The COMMS library also provides <a class="el" href="structcomms_1_1option_1_1def_1_1IgnoreInvalid.html">comms::option::def::IgnoreInvalid</a> option. It DOESN'T report failure on read operation when the invalid value is discovered (like <a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> does). Instead the field's internal value remains unchanged, although the read iterator is advanced as if the value is read. For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div><div class="line"><span class="keyword">using</span> MyField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">    MyFieldBase,</div><div class="line">    std::uint8_t,</div><div class="line">    comms::option::def::ValidNumValueRange&lt;0, 5&gt;,</div><div class="line">    <a class="code" href="structcomms_1_1option_1_1def_1_1IgnoreInvalid.html">comms::option::def::IgnoreInvalid</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t InvalidBuf[] = { 0x6 };</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> InvalidBufSize = std::extent&lt;decltype(InvalidBuf)&gt;::value;</div><div class="line"></div><div class="line">MyField myField;</div><div class="line">assert(myField.valid());</div><div class="line">assert(myField.value() == 0U);</div><div class="line"></div><div class="line"><span class="keyword">auto</span>* readIter = &amp;InvalidBuf[0];</div><div class="line"><span class="keyword">auto</span> es = myField.<a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(readIter, InvalidBufSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No failure is expected</span></div><div class="line">assert(myField.value() == 0U); <span class="comment">// Value mustn&#39;t be changed</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::uint8_t ValidBuf[] = { 0x1 };</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> ValidBufSize = std::extent&lt;decltype(ValidBuf)&gt;::value;</div><div class="line"></div><div class="line">readIter = &amp;ValidBuf[0];</div><div class="line">es = myField.<a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(readIter, ValidBufSize);</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No failure is expected</span></div><div class="line">assert(myField.value() == 1U); <span class="comment">// Value is expected to be updated</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_field_tutorial_common_options_empty_ser"></a>
Empty Serialisation</h2>
<p>Some protocols may define some constants which are NOT being sent over I/O link. Sometimes it may be useful to still treat these values as message fields. Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a> (or <a class="el" href="namespacecomms_1_1option_1_1def.html#aa543c05f35a94714da5fe879a1c11e58">comms::option::def::EmptySerialisation</a> for those who prefer British spelling) can be used to achieve such effect. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">    MyFieldBase,</div><div class="line">    std::uint8_t,</div><div class="line">    <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;5, 5&gt;</a>,</div><div class="line">    <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;5&gt;</a>,</div><div class="line">    <a class="code" href="structcomms_1_1option_1_1def_1_1EmptySerialization.html">comms::option::def::EmptySerialization</a></div><div class="line">&gt;;</div><div class="line"></div><div class="line">MyField field;</div><div class="line">assert(field.length() == 0U); <span class="comment">// Not expected to have any serialisation length</span></div><div class="line">assert(field.value() == 5U); <span class="comment">// The value is still accessible;</span></div><div class="line"></div><div class="line">std::vector&lt;std::uint8_t&gt; outBuf;</div><div class="line"><span class="keyword">auto</span> writeIter = std::back_inserter(outBuf);</div><div class="line"><span class="keyword">auto</span> es == field.write(writeIter, outBuf.max_size());</div><div class="line">assert(es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>); <span class="comment">// No failure is expected</span></div><div class="line">assert(outBuf.empty()); <span class="comment">// No data has been written</span></div></div><!-- fragment --><h1><a class="anchor" id="sec_field_tutorial_extension"></a>
Allowing Further Use of Options</h1>
<p>As was mentioned earlier there are options that define how fields are (de)serialised. These options are expected to be used in protocol fields definition. However, there are options that are application specific. They may change the data structures being used for storage, or modify default value and/or valid values. In order to allow such application specific modifications, the defined fields should allow further extension, for example with extra variadic template arguments. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TExtraOpts&gt;</div><div class="line"><span class="keyword">using</span> MyField = </div><div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div><div class="line">        <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>, <span class="comment">// base class of the field</span></div><div class="line">        std::uint16_t,</div><div class="line">        TExtraOpts...,</div><div class="line">        comms::option::def::DefaultNumValue&lt;5&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;5, 1000&gt;</a></div></div><!-- fragment --><p> Please <b>note</b>, that current implementation gives preference to the options defined <b>earlier</b>. That's why <b>TExtraOpts</b>... should be listed before any other options. It will allow setting other default value needed by the application, and/or override the valid values ranges (using <a class="el" href="structcomms_1_1option_1_1def_1_1ValidRangesClear.html">comms::option::def::ValidRangesClear</a>). For example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyUpdatedField = </div><div class="line">    MyField&lt;</div><div class="line">        comms::option::def::DefaultNumValue&lt;10&gt;,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;10, 500&gt;</a>,</div><div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidRangesClear.html">comms::option::def::ValidRangesClear</a></div><div class="line">    &gt;</div></div><!-- fragment --><h1><a class="anchor" id="sec_field_tutorial_custom_fields"></a>
Custom Fields</h1>
<p>There may be a case when communication protocol demands implementation of some intricate field's logic that is not covered by the COMMS library. It is possible to provide custom implementation of the custom field and use it with other components provided by the library as long as it defines the following minimal interface: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyField</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    </div><div class="line">    <span class="comment">// Length required to serialise current value </span></div><div class="line">    std::size_t <a class="code" href="classcomms_1_1field_1_1IntValue.html#a822ea1aa868e545c08f258183d0e389b">length</a>() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Minimal length required to serialise any value this field may contain</span></div><div class="line">    <span class="keyword">static</span> constexpr std::size_t <a class="code" href="classcomms_1_1field_1_1IntValue.html#a93f7f9659b7064638976fc4947032ce7">minLength</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Maximal length required to serialise any value this field may contain.</span></div><div class="line">    <span class="keyword">static</span> constexpr std::size_t <a class="code" href="classcomms_1_1field_1_1IntValue.html#a87d2b938f906c841d7cd633d2f366272">maxLength</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Check validity of the internal value</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a4591523e8f580ce0e34b6c50a15e1f84">valid</a>() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Bring field&#39;s value into the consistent state,</span></div><div class="line">    <span class="comment">// return true if the field&#39;s value has been updated, false otherwise</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#aed219921ab7ccd3876c4cda32b53fc29">refresh</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Read field value from input data sequence, using any type of input iterator</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(TIter&amp; iter, std::size_t size);</div><div class="line"></div><div class="line">    <span class="comment">// Write field value to output data sequence, using any type of output iterator</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#acde94491d8bec35eebd751d8e598224f">write</a>(TIter&amp; iter, std::size_t size) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p> The <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">comms::Field</a> class provides <b>readData()</b> and <b>writeData()</b> protected member functions that serialise data using endian provided as an option to the class. It makes sense to inherit from <a class="el" href="classcomms_1_1Field.html" title="Base class to all the field classes. ">comms::Field</a> with right option and reuse these functions inside: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Field.html">comms::Field</a>&lt;comms::option::def::BigEndian&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> read(TIter&amp; iter, std::size_t size)</div><div class="line">    {</div><div class="line">        ...</div><div class="line">        <span class="keyword">auto</span> val = readData&lt;InternalType&gt;(iter);</div><div class="line">        ...</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div><div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> write(TIter&amp; iter, std::size_t size)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        ...</div><div class="line">        <a class="code" href="classcomms_1_1Field.html#a0bd63c4d88caa3e2c7ec36810f4ef480">writeData</a>(..., iter);</div><div class="line">        ...</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> Also to be consistent with the existing implementation of the fields in the COMMS library it is recommended to provide an accessor functions <b>value()</b> for internal data storage: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyField : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Field.html">comms::Field</a>&lt;comms::option::def::BigEndian&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> ValueType = ...;</div><div class="line"></div><div class="line">    ValueType&amp; value() {...}</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ValueType&amp; value()<span class="keyword"> const </span>{...}</div><div class="line">};</div></div><!-- fragment --><h1><a class="anchor" id="sec_field_tutorial_other_fields"></a>
Other Fields</h1>
<p>With time the COMMS library may grow by adding support for some other built-in fields as well as supporting extra options to the existing fields described in this tutorial. If such new field and/or option is not described in this tutorial, it should be easy enough for the developer to master. Please refer to the documentation of the field and/or option itself. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 18 2020 08:01:03 for COMMS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
