<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: Protocol Stack Definition Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Protocol Stack Definition Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#page_prot_stack_tutorial_intro">Introduction</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_payload">PAYLOAD Layer</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_id">ID Layer</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_size">SIZE Layer</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_checksum">CHECKSUM Layer</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_sync">SYNC Layer</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_transport_value">Extra Transport Values</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_pseudo_transport_value">Pseudo Transport Values</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_summary">Layers Summary</a></li>
<li class="level1"><a href="#page_prot_stack_tutorial_new_layers">Implementing New Layers</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="page_prot_stack_tutorial_intro"></a>
Introduction</h1>
<p>In addition to definition of the messages and their contents, every communication protocol must ensure that the message is successfully delivered over the I/O link to the other side. The serialised message payload must be wrapped in some kind of transport information prior to being sent and unwrapped on the other side when received.</p>
<p>For example, let's define a custom protocol that wraps the message payload in the following way: </p><div class="fragment"><div class="line">SYNC | SIZE | ID | PAYLOAD | CHECKSUM </div>
</div><!-- fragment --><p> where: </p><ul>
<li>SYNC - 2 bytes of synchronisation value to indicate beginning of the message, must be "0xab 0xcd" </li>
<li>SIZE - 2 bytes, length of remaining data including checksum and not including SIZE field itself. </li>
<li>ID - 1 byte, numeric ID of the message. </li>
<li>PAYLOAD - any number of bytes, serialised message data </li>
<li>CHECKSUM - 2 bytes, CRC-CCITT value of all bytes starting (and including) from SIZE field and ending after PAYLOAD field.</li>
</ul>
<p>The processing of the raw bytes received over I/O link involves identifying the fields listed above and stripping them off <b>one by one</b> until the <b>PAYLOAD</b> is reached, where it can be read by the created proper message object (based on read message ID). If one of the elements is not as it is expected to be, the processing should stop.</p>
<p>The sequential processing the the transport information values, and stripping them one by one before proceeding to the next one, may remind of <a href="https://en.wikipedia.org/wiki/OSI_model">OSI Conceptual Model</a>, where a layer serves the layer above it and is served by the layer below it.</p>
<p>The <b>COMMS</b> library defines every such <b>layer</b>, that is handling a single value, as separate class. Every such layer class will use <b>field</b> abstraction (see <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a>) to wrap the value it handles. The layer classes are stacked together by wrapping one another. When combined together they are called <b>Protocol Stack</b>.</p>
<p>The wrapping for the example above will look like this: </p><div class="diagraph">
<img src="dia_protocol_stack.png" />
</div>
<p>When presented as actual stack, it may look like this: </p><div class="diagraph">
<img src="dia_protocol_stack_layers.png" />
</div>
<p>Please note that <b>CHECKSUM</b> layer lays between <b>SYNC</b> and <b>SIZE</b>. This is a bit counter intuitive, because <b>SIZE</b> follows <b>SYNC</b> in the protocol description, while <b>CHECKSUM</b> appears last. The reason for such location of <b>CHECKSUM</b> layer is that it calculates and verifies checksum on the <b>SIZE</b>, <b>ID</b>, and <b>PAYLOAD</b> areas, i.e. it must wrap the all three.</p>
<p>The COMMS library provides multiple classes to define various layers when assembling the full <b>protocol stack</b> of layers. All these classes reside in <a class="el" href="namespacecomms_1_1protocol.html" title="Namespace that contains definition of layers that can be used to wrap message data with transport dat...">comms::protocol</a> namespace. The following sections will cover all the layer classes required to assemble the protocol stack described above.</p>
<h1><a class="anchor" id="page_prot_stack_tutorial_payload"></a>
PAYLOAD Layer</h1>
<p>The top layer, that is responsible to read/write the payload of the message is called <b>PAYLOAD</b>. It is implemented by <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html" title="Message data layer.">comms::protocol::MsgDataLayer</a> class in the COMMS library. </p><div class="fragment"><div class="line"><span class="keyword">using </span>MyMsgData = <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer&lt;&gt;</a>;</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgDataLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a></div><div class="ttdoc">Message data layer.</div><div class="ttdef"><b>Definition</b> MsgDataLayer.h:42</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a> receives a template parameter. In the normal operation, when transport frame fields are not stored anywhere, it is never used. However, there is way to perform <b>read</b> operation while caching transport fields (by using <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html#ad27c6b31381727bc765daf1e36d98029">readFieldsCached()</a>) The payload field is defined to be <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> of raw data (see <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html#ac674e4c28bc8e154ee1801cc39de7f58">comms::protocol::MsgDataLayer::Field</a>). It would be wise to provide a way to supply extra options to choose storage type for this field, when defining protocol stack. As the result the definition becomes: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TPayloadOptions = comms::option::app::EmptyOption&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgData = <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer&lt;TPayloadOptions&gt;</a>;</div>
</div><!-- fragment --><h1><a class="anchor" id="page_prot_stack_tutorial_id"></a>
ID Layer</h1>
<p>The <b>ID</b> layer is responsible to process the ID of the message and based on this ID, create proper message object. The COMMS library implements this functionality in <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> class. It receives <b>at least</b> four template parameters. The first one is a type of the field that can be used to read/write the ID information. The <a class="el" href="page_define_prot.html#page_define_prot_interface">Common Interface Class</a> section described <b>my_protocol::MsgId</b> enum type used to define message IDs, it can be reused to define a field responsible to read / write message ID value </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> MsgId : std::uint8_t {...} <span class="comment">// enum described earlier</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>MyFieldBase = <a class="code hl_class" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>; <span class="comment">// Use big endian for all fields serialisation</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>MsgIdField = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        MsgId <span class="comment">// enum type</span></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition</b> Field.h:33</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1EnumValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a></div><div class="ttdoc">Enumerator value field.</div><div class="ttdef"><b>Definition</b> EnumValue.h:73</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that underlying enum type is defined to be <b>std::uint8_t</b>, which will result in 1 byte serialisation length.</p>
<p>The second parameter is common interface class for all <b>input</b> messages that need to be recognised during <b>read</b> operation. This type will be defined by the application and is expected to be an alias (typedef) or extending class to <b>my_protocol::Message</b> (described in <a class="el" href="page_define_prot.html#page_define_prot_interface">Common Interface Class</a>)</p>
<p>The third parameter is all the types of all the custom messages, that need to be recognised in <b>read</b> operation, bundled in std::tuple. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMessage&gt;</div>
<div class="line"><span class="keyword">using </span>AllMessages =</div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        Message1&lt;TMessage&gt;,</div>
<div class="line">        Message2&lt;TMessage&gt;,</div>
<div class="line">        Message3&lt;TMessage&gt;,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> <b>NOTE</b>, that the interface class (<b>TMessage</b>) passed as the second parameter is expected to be the common base class for all the messages passed as third one.</p>
<p>The fourth template parameter is the upper layer it needs to wrap: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgId = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt;</div>
<div class="line">        MsgIdField, </div>
<div class="line">        TMessage, </div>
<div class="line">        TInputMessages, </div>
<div class="line">        MyMsgData&lt;TPayloadOptions&gt;</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgIdLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a></div><div class="ttdoc">Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...</div><div class="ttdef"><b>Definition</b> MsgIdLayer.h:80</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1EmptyOption_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a></div><div class="ttdoc">No-op option, doesn't have any effect.</div><div class="ttdef"><b>Definition</b> options.h:1250</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that all the input messages are passed as a template parameter with a default value (bundling all the available messages). It will give an opportunity to the application to use only messages it needs.</p>
<p>Also <b>note</b>, input messages in the bundle (<b>TInputMessages</b>) are expected to be defined in order of their numeric IDs. It is allowed to have separate message classes to report the same numeric ID. However, the <b>read</b> operation will try to read all the messages with the found ID one by one <b>in order</b> of their definition until success is reported.</p>
<p>The <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> defines <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a> internal type, which is smart pointer (<b>std::unique_ptr</b>) to the input message interface class (<b>TMessage</b>) provided as second template parameter.</p>
<p>During the normal <b>read</b> operation, the <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> will dynamically allocate the proper message object.</p>
<p>The <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> can also be used in <b>bare metal</b> systems, that do NOT use dynamic memory allocation. In order to prevent this layer from using dynamic memory allocation, the <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option needs to be passed as fifth template parameter to the <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> class. However, an ability to use this option needs to be provided to the application itself only if needed. In order to achive that additional template parameter needs to be used. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgId = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt;</div>
<div class="line">        MsgIdField, </div>
<div class="line">        TMessage, </div>
<div class="line">        TInputMessages, </div>
<div class="line">        MyMsgData&lt;TPayloadOptions&gt;,</div>
<div class="line">        TAllocationOptions</div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> In this case, the <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> will statically allocate internal buffer in its private data members, big enough to hold any message object of any type listed in <b>AllMessages</b> bundle. It means that only one message object can be allocated and used at a time, i.e. the previous object must be deleted prior to new one being allocated. <br  />
Also, the <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html#a3444598e8ae44eaa5b09f11b694a1670">MsgPtr</a> will still be a variant of <b>std::unique_ptr</b>, but with custom deleter (defined by COMMS library itself), which will make sure the proper destruction of the message object and release of the internal buffer for next allocation. In case new allocation is attempted when internal buffer is NOT released, the new message will NOT be allocated and read operation will fail with <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a37b538d9e3266acd66229ede1dcceb70">comms::ErrorStatus::MsgAllocFailure</a> error.</p>
<p>By default, if the received data contains unknown message ID (the message type is not in <b>AllMessages</b> bundle), the <b>read</b> operation returns <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">comms::ErrorStatus::InvalidMsgId</a> and no message object is allocated. However, there are <b>bridge</b> / <b>gateway</b> / <b>firewall</b> type of applications which are interested to decode only limited number of messages, but still forward the received data (sometimes changing the transport wrapping) without actually decoding the contents. In this case the default behaviour cannot be used. The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> message definition which has a single variable length data field (defined using <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> class). The <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a> may also receive <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option specifying type of the GenericMessage. In this case, if the appropriate message type hasn't been found in <b>AllMessages</b> bundle, the appropriate <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> object will be created instead. However, just like with <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a>, this option should be used by the application if needed.</p>
<p>Note, that <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> and <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> options can be used together. In this case the <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> message object will be allocated in the same allocation area. The client application will be able to combine these option together in single tuple and use pass as <b>TAllocationOptions</b> parameter. </p><div class="fragment"><div class="line"><span class="keyword">using </span>MyAllocOptions = </div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage&lt;comms::GenericMessage&lt;MyInterfaceMessage&gt;</a> &gt;,</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1InPlaceAllocation_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a></div><div class="ttdoc">Option that forces &quot;in place&quot; allocation with placement &quot;new&quot; for initialisation, instead of usage of...</div><div class="ttdef"><b>Definition</b> options.h:1323</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1SupportGenericMessage_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a></div><div class="ttdoc">Option used to allow comms::GenericMessage generation inside comms::MsgFactory and/or comms::protocol...</div><div class="ttdef"><b>Definition</b> options.h:1330</div></div>
</div><!-- fragment --><p> When constructed, the <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> creates an array of statically allocated factory methods, which are responsible to allocate right message objects. This array is used as a map of message ID to the factory method. The COMMS library contains inner logic that analyses a tuple of all <b>input</b> message types provided to <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>. If the IDs of the messages are sequential ones starting from a low number such as 0 or 1, and the highest ID value do not significantly exceed the total number of message types in the tuple, then the one-to-one mapping is generated, i.e. to access the right factory method is just accessing the right cell in the mapping array (O(1) time complexity). In all other cases the factory methods are compacted together and binary search is executed to get appropriate factory method having the numeric message ID value (O(log(n))).</p>
<p><b>NOTE</b>, that <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a> doesn't use any dynamic memory allocation to store internal factory methods, that create proper message object given the ID of the message, which makes it possible and safe to use in bare-metal environment without any HEAP.</p>
<p>It may happen that <b><a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html" title="Protocol layer that uses uses message ID field as a prefix to all the subsequent data written by othe...">comms::protocol::MsgIdLayer</a></b> class as-is is not really suitable for implementing message identification and creation of message object when implementing custom protocol. It is possible to implement a new custom layer (see <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_new_layers">Implementing New Layers</a> section below) with the required functionality. However, it is recommended to use <a class="el" href="classcomms_1_1MsgFactory.html">comms::MsgFactory</a> object internally. It will help in creation the proper message object once the ID value is known.</p>
<h1><a class="anchor" id="page_prot_stack_tutorial_size"></a>
SIZE Layer</h1>
<p>The <b>SIZE</b> layer is responsible to process information on the remaining message length, and forward the <b>read/write</b> operations to the upper layer in case it is safe to do so. The COMMS library provides <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> class for that purpose. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>RemSizeField =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::uint16_t, </div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a>&lt;<span class="keyword">sizeof</span>(std::uint16_t)&gt; </div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgSize = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;</div>
<div class="line">        RemSizeField, </div>
<div class="line">        MyMsgId&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a></div><div class="ttdoc">Field that represent integral value.</div><div class="ttdef"><b>Definition</b> IntValue.h:72</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1MsgSizeLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a></div><div class="ttdoc">Protocol layer that uses size field as a prefix to all the subsequent data written by other (next) la...</div><div class="ttdef"><b>Definition</b> MsgSizeLayer.h:75</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1NumValueSerOffset_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a></div><div class="ttdoc">Option to specify numeric value serialisation offset.</div><div class="ttdef"><b>Definition</b> options.h:378</div></div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a> receives <b>at least</b> two template parameters. The first one is the definition of the <b>field</b> (see <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a> for details) that is responsible to read/write the remaining length information. The second template parameter is an upper layer that is being wrapped. The third template parameter is optional default behaviour modification options.<br  />
Please note the usage of <a class="el" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a> option when defining the <b>field</b> type. If it is NOT used, the serialised length value will cover only <b>ID</b> and <b>PAYLOAD</b> (layers it wraps). However, according to the protocol specification, the <b>SIZE</b> value must also include <b>CHECKSUM</b>. Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a> &lt;sizeof(std::uint16_t)&gt; will add 2 (<b>sizeof(std::uint16_t)</b>) when serialising the length of wrapped fields. See also <a class="el" href="page_field_tutorial.html#sec_field_tutorial_int_value_ser_offset">Serialisation Offset</a> for more details.</p>
<h1><a class="anchor" id="page_prot_stack_tutorial_checksum"></a>
CHECKSUM Layer</h1>
<p>The <b>CHECKSUM</b> layer is responsible to calculate and verify the checksum on the data read and/or written by the upper layers it wraps. The COMMS library provides <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">comms::protocol::ChecksumLayer</a> and <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">comms::protocol::ChecksumPrefixLayer</a> for this purpose. They are very similar. The only difference is that <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">comms::protocol::ChecksumLayer</a> appends the checksum value, while <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html" title="Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...">comms::protocol::ChecksumPrefixLayer</a> prepends it. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>ChecksumField = <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyChecksum =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a>&lt;</div>
<div class="line">        ChecksumField,</div>
<div class="line">        <a class="code hl_class" href="classcomms_1_1protocol_1_1checksum_1_1Crc.html">comms::protocol::checksum::Crc_CCITT</a></div>
<div class="line">        MyMsgSize&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ChecksumLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a></div><div class="ttdoc">Protocol layer that is responsible to calculate checksum on the data written by all the wrapped inter...</div><div class="ttdef"><b>Definition</b> ChecksumLayer.h:73</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1checksum_1_1Crc_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1checksum_1_1Crc.html">comms::protocol::checksum::Crc</a></div><div class="ttdoc">Calculate CRC values of all the bytes in the sequence.</div><div class="ttdef"><b>Definition</b> Crc.h:268</div></div>
</div><!-- fragment --><p> The both layer classes receives three template parameters. The first one is a <b>field</b> that is responsible to read/write the checksum value.</p>
<p>The second template parameter is a checksum calculator class which is used to calculate a checksum value. Please refer to the documentation of <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a> or <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a> class for the details on the interface this checksum calculator class must provide. The example above uses <a class="el" href="namespacecomms_1_1protocol_1_1checksum.html#ab1e988797cc1e9dd87f3a5284ef1e3f2">comms::protocol::checksum::Crc_CCITT</a>, which calculates the the standard CRC-CCITT value. All the checksum calculators the COMMS library provides reside in <a class="el" href="namespacecomms_1_1protocol_1_1checksum.html" title="Namespace that contains definition of checksum calculator classes which can be used with comms::proto...">comms::protocol::checksum</a> namespace.</p>
<p>The third template parameter is an upper layer that is being wrapped.</p>
<p>By default both <a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a> and <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a> allow inner (upper) layers to complete their read operation before calculating and verifying checksum on read data. However, there may be protocols that may allow checksum verification before attempting to read message contents. In this case <a class="el" href="structcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead.html">comms::option::def::ChecksumLayerVerifyBeforeRead</a> option may be used as fourth template parameter. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyChecksum =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a>&lt;</div>
<div class="line">        ChecksumField,</div>
<div class="line">        <a class="code hl_class" href="classcomms_1_1protocol_1_1checksum_1_1Crc.html">comms::protocol::checksum::Crc_CCITT</a></div>
<div class="line">        MyMsgSize&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;,</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead.html">comms::option::def::ChecksumLayerVerifyBeforeRead</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ChecksumLayerVerifyBeforeRead.html">comms::option::def::ChecksumLayerVerifyBeforeRead</a></div><div class="ttdoc">Force comms::protocol::ChecksumLayer and comms::protocol::ChecksumPrefixLayer, to verify checksum pri...</div><div class="ttdef"><b>Definition</b> options.h:1082</div></div>
</div><!-- fragment --><h1><a class="anchor" id="page_prot_stack_tutorial_sync"></a>
SYNC Layer</h1>
<p>The <b>SYNC</b> layer is responsible to recognise the synchronisation byte(s) in the input stream as well as write appropriate value when the write operation takes place. The COMMS library provides <a class="el" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html">comms::protocol::SyncPrefixLayer</a> class that helps with this task. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>SyncField =</div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::uint16_t, </div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;0xabcd&gt;</a>,</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValue&lt;0xabcd&gt;</a>,</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a> <span class="comment">// fail read operation if read value is invalid </span></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MySyncPrefix = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html">comms::protocol::SyncPrefixLayer</a>&lt;</div>
<div class="line">        SyncField, </div>
<div class="line">        MyChecksum&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1SyncPrefixLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1SyncPrefixLayer.html">comms::protocol::SyncPrefixLayer</a></div><div class="ttdoc">Protocol layer that uses &quot;sync&quot; field as a prefix to all the subsequent data written by other (next) ...</div><div class="ttdef"><b>Definition</b> SyncPrefixLayer.h:52</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1DefaultValueInitialiser_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a></div><div class="ttdoc">Option that specifies default initialisation class.</div><div class="ttdef"><b>Definition</b> options.h:616</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FailOnInvalid_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a></div><div class="ttdoc">Option that forces field's read operation to fail if invalid value is received.</div><div class="ttdef"><b>Definition</b> options.h:674</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ValidNumValueRange_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a></div><div class="ttdoc">Provide range of valid numeric values.</div><div class="ttdef"><b>Definition</b> options.h:956</div></div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html" title="Protocol layer that uses &quot;sync&quot; field as a prefix to all the subsequent data written by other (next) ...">comms::protocol::SyncPrefixLayer</a> class receives two template parameters. The first one is the type of the <b>field</b>, that is responsible to read/write the synchronisation byte(s). Please note the usage of <a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605">comms::option::def::DefaultNumValue</a> option when defining the <b>field</b> type. It insures that the default constructed field will have the required value. <br  />
The second template parameter is the upper layer being wrapped.</p>
<h1><a class="anchor" id="page_prot_stack_tutorial_transport_value"></a>
Extra Transport Values</h1>
<p>Some protocol may use extra values as part of the transport information. Such values may have an influence on how the message payload is read and/or on how the message object is handled. As an example let's define the following transport wrapping: </p><div class="fragment"><div class="line">SIZE | ID | VERSION | PAYLOAD</div>
</div><!-- fragment --><p> The <b>VERSION</b> value is expected to influence the "read" operation. The message object may have some extra fields, which were introduced in later version of the protocol, and it needs to take into account the provided <b>VERSION</b> info.</p>
<p>The COMMS library provides <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> to handle such fields. <b>HOWEVER</b> it requires extra support from common message interface class. The latter must use <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option in order to define expected interface (please refer to <a class="el" href="page_define_prot.html#page_define_prot_interface_extra_transport">Extra Transport Values</a> for details).</p>
<p>The <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> class receives three template parameters. The first one is the field used to read / write the value. The second parameter is index of the relevant extra transport field in the <a class="el" href="classcomms_1_1Message.html#a1a7c7b92d38774a038fbdedb3e0f99cc">comms::Message::TransportFields</a> tuple. And the third parameter is the next layer.</p>
<p>The whole protocol stack definition may look like this: </p><div class="fragment"><div class="line"><span class="comment">// Base class of all the fields</span></div>
<div class="line"><span class="keyword">using </span>MyFieldBase = <a class="code hl_class" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Field describing protocol version.</span></div>
<div class="line"><span class="keyword">using </span>MyVersionField = <a class="code hl_class" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Payload control layer</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgData = <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer&lt;TPayloadOptions&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Version control layer</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyVersion = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a>&lt;</div>
<div class="line">        MyVersionField, </div>
<div class="line">        TMessage::TransportFieldIdx_version, </div>
<div class="line">        MyMsgData&lt;TPayloadOptions&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Id handling layer</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgId = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>&lt;</div>
<div class="line">        MsgIdField, </div>
<div class="line">        TMessage, </div>
<div class="line">        TInputMessages, </div>
<div class="line">        MyVersion&lt;TMessage, TPayloadOptions&gt;,</div>
<div class="line">        TAllocationOptions</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Size handling layer</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyMsgSize = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>&lt;</div>
<div class="line">        RemSizeField, </div>
<div class="line">        MyMsgId&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1TransportValueLayer_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a></div><div class="ttdoc">Protocol layer that reads a value from transport wrapping and reassigns it to appropriate &quot;extra tran...</div><div class="ttdef"><b>Definition</b> TransportValueLayer.h:79</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that in the example above <b>VERSION</b> layer follows <b>ID</b>. In this case the message object is already created by the <b>ID</b> layer when <b>VERSION</b> one performs its read operation. The latter may update the version information inside the created message object. However, there may be cases when extra transport value precedes ID layer: </p><div class="fragment"><div class="line">SIZE | VERSION | ID | PAYLOAD</div>
</div><!-- fragment --><p> The COMMS library is also capable of handling such case. It contains internal "magic", which forces some layers to complete their read operation and update created message object (if necessary) before the read operation is forwarded to the final (PAYLOAD) layer.</p>
<p>Unfortunatelly there are layers (<a class="el" href="classcomms_1_1protocol_1_1ChecksumLayer.html">comms::protocol::ChecksumLayer</a>, <a class="el" href="classcomms_1_1protocol_1_1ChecksumPrefixLayer.html">comms::protocol::ChecksumPrefixLayer</a>, and <a class="el" href="classcomms_1_1protocol_1_1MsgSizeLayer.html">comms::protocol::MsgSizeLayer</a>), that cannot complete their read operation, without read of the PAYLOAD data being complete as well. As the result these layers do not support being wrapped by <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> and will fail compilation with static assert if such wrapping is attempted.</p>
<h1><a class="anchor" id="page_prot_stack_tutorial_pseudo_transport_value"></a>
Pseudo Transport Values</h1>
<p>Some protocols may report one of the values (such as protocol version) in one of the messages used to establish connection. After that, the reported value may have influence on how other message contents are being read. Handling such case is very similar to <a class="el" href="page_prot_stack_tutorial.html#page_prot_stack_tutorial_transport_value">Extra Transport Values</a>. The only difference is passing <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> option to <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> layer class. It will cause the transport value not actually being (de)serialised during <b>read</b> / <b>write</b> operations. The pseudo field value is going to be stored as private member of <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> and can be accessed (and updated) using <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html#a01bf02c6075be829b53785c8fc019798">pseudoField()</a> member function(s). During the <b>read</b> operation the <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html" title="Protocol layer that reads a value from transport wrapping and reassigns it to appropriate &quot;extra tran...">comms::protocol::TransportValueLayer</a> behaves as if the value stored in this field was actually read. </p><div class="fragment"><div class="line"><span class="comment">// Version control layer</span></div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>MyVersion = </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a>&lt;</div>
<div class="line">        MyVersionField, </div>
<div class="line">        TMessage::TransportFieldIdx_version, </div>
<div class="line">        MyMsgData&lt;TPayloadOptions&gt;,</div>
<div class="line">        <a class="code hl_struct" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1PseudoValue_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a></div><div class="ttdoc">Option for comms::protocol::TransportValueLayer to mark that the handled field is a &quot;pseudo&quot; one,...</div><div class="ttdef"><b>Definition</b> options.h:1152</div></div>
</div><!-- fragment --><h1><a class="anchor" id="page_prot_stack_tutorial_summary"></a>
Layers Summary</h1>
<p>The earlier examples show that layer classes wrap one another, which creates the following picture: </p><div class="diagraph">
<img src="dia_protocol_stack.png" />
</div>
<p>The outermost (or bottom) layer defines a full <b>protocol stack</b>. It should be typedef-ed or extended to avoid any confusion: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">using </span>ProtocolStack = MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; ;</div>
</div><!-- fragment --><p> Every protocol layer provides an ability to access the next one using <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94b66bf54cf3ffa37058ff618bdcf163">nextLayer()</a> member function. It is strongly recommended to generate convenience access functions using COMMS_PROTOCOL_LAYERS_ACCESS() macro. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(payload, <span class="keywordtype">id</span>, size, checksum, sync);</div>
<div class="line">};</div>
</div><!-- fragment --><p> It is equivalent to having the following member function being defined: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Access to PAYLOAD layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_payload();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to PAYLOAD layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_payload() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to ID layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_id();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to ID layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_id() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to SIZE layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_size();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to SIZE layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_size() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to CHECKSUM layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_checksum();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to CHECKSUM layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_checksum() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to SYNC layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_sync();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to SYNC layer</span></div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_sync() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Please note the following: </p><ul>
<li>Every provided name is prefixed with <b>layer_</b>. </li>
<li>The names inside the COMMS_PROTOCOL_LAYERS_ACCESS() macro specify innermost layer first and outermost one last. There is a convenience wrapper macro COMMS_PROTOCOL_LAYERS_ACCESS_OUTER() which allows listing in the opposite order (outermost first and innermost last).</li>
</ul>
<p><b style="color:red">WARNING:</b> Some compilers, such as <b>clang</b> or earlier versions of <b>gcc</b> (v4.9 and earlier) may have problems compiling the COMMS_PROTOCOL_LAYERS_ACCESS() macro even though it contains valid C++11 code. If the compilation failure happens there is a need to define inner <b>Base</b> type which specifies exact type of the protocol stack base class. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>Base = MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(payload, <span class="keywordtype">id</span>, size, checksum, sync);</div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that <b>COMMS</b> library also defines <b>COMMS_MUST_DEFINE_BASE</b> in case the base class definition is needed (going to be used). If the developed application is going to be multi-platform and compiled with various compilers (some of which may warn about unused private type) it is possible to use the defined symbol to add / remove the definition of the <b>Base</b> member type. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef COMMS_MUST_DEFINE_BASE</span></div>
<div class="line">    <span class="keyword">using </span>Base = ...</div>
<div class="line">#endif</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(payload, <span class="keywordtype">id</span>, size, checksum, sync);</div>
<div class="line">};</div>
</div><!-- fragment --><p> Since <b>v5.2</b> the COMMS library defines COMMS_PROTOCOL_LAYERS_NAMES() and COMMS_PROTOCOL_LAYERS_NAMES_OUTER() macros they are similar to the COMMS_PROTOCOL_LAYERS_NAMES() and COMMS_PROTOCOL_LAYERS_NAMES_OUTER() respectively, but also provide aliases to the layer types. However usage of these macros requires inner <b>Base</b> type definition of the base class: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span>ProtocolStack : <span class="keyword">public</span></div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Base type definition is a requirement</span></div>
<div class="line">    <span class="keyword">using </span>Base = MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_NAMES(payload, <span class="keywordtype">id</span>, size, checksum, sync);</div>
<div class="line">};</div>
</div><!-- fragment --><p> It is equivalent to having the following types and member function being defined: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code hl_struct" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span></div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>Layer_payload = ...;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_payload();</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_payload() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Layer_id = ...;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_id();</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_id() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Layer_size = ...;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_size();</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_size() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Layer_checksum = ...;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_checksum();</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_checksum() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Layer_sync = ...;</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_sync();</div>
<div class="line">    <span class="keyword">decltype</span>(<span class="keyword">auto</span>) layer_sync() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="page_prot_stack_tutorial_new_layers"></a>
Implementing New Layers</h1>
<p>Every protocol is unique, and there is a chance that COMMS library doesn't provide all the necessary layer classes required to implement custom logic of the protocol. The COMMS library allows implementation and usage of custom layers as long as it defines the required types and implements required functions.</p>
<p>Some of the available layers support extension of their default functionality. Pleases check the following tutorial pages. In most cases it will be sufficient. </p><ul>
<li><a class="el" href="page_custom_id_layer.html">Defining Custom Message ID Protocol Stack Layer</a> </li>
<li><a class="el" href="page_custom_size_layer.html">Defining Custom Message Size Protocol Stack Layer</a> </li>
<li><a class="el" href="page_custom_transport_value_layer.html">Defining Custom Transport Value Protocol Stack Layer</a> </li>
<li><a class="el" href="page_custom_checksum_layer.html">Defining Custom Checksum Protocol Stack Layer</a> </li>
<li><a class="el" href="page_custom_sync_prefix_layer.html">Defining Custom Sync Prefix Protocol Stack Layer</a></li>
</ul>
<p>In case absolutely new and independent protocol stack layer needs to be implemented, please follow the instructions below.</p>
<p>It is strongly recommended to inherit from <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers.">comms::protocol::ProtocolLayerBase</a> and implement missing functionality </p><div class="fragment"><div class="line"><span class="comment">// Must receive the next layer type as template parameter</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;</div>
<div class="line">        TField, </div>
<div class="line">        TNextLayer,</div>
<div class="line">        MyLayer&lt;TField, TNextLayer&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Implement read</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader&gt;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(</div>
<div class="line">        Field&amp; field,</div>
<div class="line">        TMsg&amp; msg, <span class="comment">// can be either smart pointer (ProtocolStack::MsgPtr) or message object itself</span></div>
<div class="line">        TIter&amp; iter,</div>
<div class="line">        std::size_t size,</div>
<div class="line">        std::size_t* missingSize,</div>
<div class="line">        TNextLayerReader&amp;&amp; nextLayerReader)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read the field&#39;s value</span></div>
<div class="line">        <span class="keyword">auto</span> es = field.<a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read</a>(iter, size);</div>
<div class="line">        <span class="keywordflow">if</span> (es != <a class="code hl_enumvalue" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> es;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ... <span class="comment">// do something with field&#39;s value</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// forward the read to the next layer.</span></div>
<div class="line">        <span class="keywordflow">return</span> nextLayerReader.read(msg, iter, size - field.length(), missingSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement write</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerWriter&gt;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doWrite(</div>
<div class="line">        Field&amp; field,</div>
<div class="line">        <span class="keyword">const</span> TMsg&amp; msg,</div>
<div class="line">        TIter&amp; iter,</div>
<div class="line">        std::size_t size,</div>
<div class="line">        TNextLayerWriter&amp;&amp; nextLayerWriter)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Update field with appropriate value</span></div>
<div class="line">        field.value() = ...;</div>
<div class="line">    </div>
<div class="line">        <span class="comment">// write the field</span></div>
<div class="line">        <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">        <span class="keywordflow">if</span> (es != <a class="code hl_enumvalue" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> es;</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">        <span class="comment">// forward the write to the next layer</span></div>
<div class="line">        <span class="keywordflow">return</span> nextLayerWriter.write(msg, iter, size - field.length());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ProtocolLayerBase_html"><div class="ttname"><a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a></div><div class="ttdoc">Base class for all the middle (non MsgDataLayer) protocol transport layers.</div><div class="ttdef"><b>Definition</b> ProtocolLayerBase.h:61</div></div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ProtocolLayerBase_html_a60d0ea06c68e5b885bf651d7a7b14d1a"><div class="ttname"><a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">comms::protocol::ProtocolLayerBase::read</a></div><div class="ttdeci">comms::ErrorStatus read(TMsg &amp;msg, TIter &amp;iter, std::size_t size, TExtraValues... extraValues)</div><div class="ttdoc">Deserialise message from the input data sequence.</div><div class="ttdef"><b>Definition</b> ProtocolLayerBase.h:213</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition</b> ErrorStatus.h:17</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdoc">Used to indicate successful outcome of the operation.</div></div>
</div><!-- fragment --><p> Note that the third template parameter to the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers.">comms::protocol::ProtocolLayerBase</a> base class is the inheriting class itself.</p>
<p>The <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers.">comms::protocol::ProtocolLayerBase</a> implements <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> member functions which are actual "read" interface, they invoke the <b>doRead()</b> member function implemented the derived layer class, while providing the "nextLayerReader" object to be used to forward the read operation to the next layer. The signature of the <b>nextLayerReader.read()</b> function is the same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a>. <b>NOTE</b>, that <b>msg</b> parameter to the <b>doRead()</b> member function can be either reference to a smart pointer (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>) or a reference to the message object itself (one that extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>). If the message object contents need to be accessed, then it is necessary to know what exactly is passed as <b>msg</b> parameter to the <b>doRead()</b> function. The <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#aff7baefef2232316e08980e680d189ef">isMessageObjRef()</a> member function can be used to help in such task and "tag dispatch idiom" can be used to perform right functionality. </p><div class="fragment"><div class="line"><span class="comment">// Must receive the next layer type as template parameter</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>Base = <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Implement read</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerReader&gt;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(</div>
<div class="line">        Field&amp; field,</div>
<div class="line">        TMsg&amp; msg, <span class="comment">// can be either smart pointer (ProtocolStack::MsgPtr) or message object itself</span></div>
<div class="line">        TIter&amp; iter,</div>
<div class="line">        std::size_t size,</div>
<div class="line">        std::size_t* missingSize,</div>
<div class="line">        TNextLayerReader&amp;&amp; nextLayerReader)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read the field&#39;s value</span></div>
<div class="line">        <span class="keyword">auto</span> es = field.<a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read</a>(iter, size);</div>
<div class="line">        <span class="keywordflow">if</span> (es != <a class="code hl_enumvalue" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> es;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">using </span>Tag = <span class="keyword">typename</span> std::conditional&lt;</div>
<div class="line">            Base::template isMessageObjRef&lt;<span class="keyword">typename</span> std::decay&lt;<span class="keyword">decltype</span>(msg)&gt;::type&gt;(),</div>
<div class="line">            DirectObjectAccessTag,</div>
<div class="line">            SmartPointerTag</div>
<div class="line">        &gt;</div>
<div class="line"> </div>
<div class="line">        doSomething(field, msg, Tag()); <span class="comment">// do something with field&#39;s value</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// forward the read to the next layer.</span></div>
<div class="line">        <span class="keywordflow">return</span> nextLayerReader.read(msg, iter, size - field.length(), missingSize);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>SmartPointerTag {};</div>
<div class="line">    <span class="keyword">struct </span>DirectObjectAccessTag {};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsgPtr&gt;</div>
<div class="line">    <span class="keywordtype">void</span> doSomething(Field&amp; field, TMsgPtr&amp; msgPtr, SmartPointerTag)</div>
<div class="line">    {</div>
<div class="line">        msgPtr-&gt;someFunc(...) <span class="comment">// access message object via pointer</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line">    <span class="keywordtype">void</span> doSomething(Field&amp; field, TMsg&amp; msg, DirectObjectAccessTag)</div>
<div class="line">    {</div>
<div class="line">        msg.someFunc(...); <span class="comment">// access message object directly</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>In similar way <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers.">comms::protocol::ProtocolLayerBase</a> implements <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d">writeFieldsCached()</a> member functions which are actual "write" interface, they invoke the <b>doWrite()</b> member function implemented the derived layer class, while providing the "nextLayerWriter" object to be used to forward the read operation to the next layer. The signature of the <b>nextLayerWriter.write()</b> function is the same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. If the <b>doWrite()</b> function requires modification to the used iterator (moving it back and force), it must determine type of the iterators (using <b>std::iterator_traits</b>). In case the used iterator is <b>output</b> one (not <b>random-access</b>), then such update may be impossible. In this case the <b>doWrite()</b> function is expected to write some dummy value and return <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>. It will indicate to the client application that invocation of <b>update</b> functionality with random access iterator needs to follow the <b>write</b> operation.</p>
<p>The <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html" title="Base class for all the middle (non MsgDataLayer) protocol transport layers.">comms::protocol::ProtocolLayerBase</a> base class defines also "update" interface functions <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a618765cb8b7314e718cbcbbe7c880c6d">updateFieldsCached()</a>, which in the similar way invoke <b>doUpdate()</b>. However, <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a> class provides a default implementation of <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate()</a> member function, which does nothing, just advances the iterator. If there is a need for a custom update functionality, please provide it in you layer class by implementing the custom version of <b>doUpdate()</b> member function. </p><div class="fragment"><div class="line"><span class="comment">// Must receive the next layer type as template parameter</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;</div>
<div class="line">        TField, </div>
<div class="line">        TNextLayer,</div>
<div class="line">        MyLayer&lt;TField, TNextLayer&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate</a>(</div>
<div class="line">        Field&amp; field,</div>
<div class="line">        TIter&amp; iter,</div>
<div class="line">        std::size_t size,</div>
<div class="line">        TNextLayerUpdater&amp;&amp; nextLayerUpdater)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Update field with the new value and rewrite it to the output buffer</span></div>
<div class="line">        field.value() = ...; </div>
<div class="line">        <span class="keyword">auto</span> es = field.write(iter, size);</div>
<div class="line">        <span class="keywordflow">if</span> (es != <a class="code hl_enumvalue" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> es;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// forward the update to the next layer</span></div>
<div class="line">        <span class="keywordflow">return</span> nextLayerUpdater.update(iter, size - field.length());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ProtocolLayerBase_html_a94f23dc39f0adb4fd7ecd0ab2941588f"><div class="ttname"><a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">comms::protocol::ProtocolLayerBase::doUpdate</a></div><div class="ttdeci">comms::ErrorStatus doUpdate(Field &amp;field, TIter &amp;iter, std::size_t size, TNextLayerUpdater &amp;&amp;nextLayerUpdater) const</div><div class="ttdoc">Default implementation of the &quot;update&quot; functaionality.</div><div class="ttdef"><b>Definition</b> ProtocolLayerBase.h:707</div></div>
</div><!-- fragment --><p> The signature of the <b>nextLayerUpdater.update()</b> function is the same as <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a>.</p>
<p>There may be cases when update functionality requires also knowledge about message object being written. In this case there is a need to provide overloaded <b>doUpdate()</b> member function that receives message object as its first parameter. </p><div class="fragment"><div class="line"><span class="comment">// Must receive the next layer type as template parameter</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg, <span class="keyword">typename</span> TIter, <span class="keyword">typename</span> TNextLayerUpdater&gt;</div>
<div class="line">    <a class="code hl_enumeration" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a94f23dc39f0adb4fd7ecd0ab2941588f">doUpdate</a>(</div>
<div class="line">        <span class="keyword">const</span> TMsg&amp; msg,</div>
<div class="line">        Field&amp; field,</div>
<div class="line">        TIter&amp; iter,</div>
<div class="line">        std::size_t size,</div>
<div class="line">        TNextLayerUpdater&amp;&amp; nextLayerUpdater)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>If the new layer being implemented is similar to <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a>, i.e. creates message objects when id of the message is known, then it must also override (hide) the inherited <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">createMsg()</a> and implement its own version: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TField, <span class="keyword">typename</span> TNextLayer&gt;</div>
<div class="line"><span class="keyword">class </span>MyLayer : <span class="keyword">public</span> </div>
<div class="line">    <a class="code hl_class" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html">comms::protocol::ProtocolLayerBase</a>&lt;</div>
<div class="line">        TField, </div>
<div class="line">        TNextLayer,</div>
<div class="line">        MyLayer&lt;TField, TNextLayer&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    MsgPtr <a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">createMsg</a>(MsgIdParamType <span class="keywordtype">id</span>, <span class="keywordtype">unsigned</span> idx = 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> someInternalMsgFactory.<a class="code hl_function" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">createMsg</a>(<span class="keywordtype">id</span>, idx);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1protocol_1_1ProtocolLayerBase_html_a41e188996511ff20f659abad642ea40c"><div class="ttname"><a href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a41e188996511ff20f659abad642ea40c">comms::protocol::ProtocolLayerBase::createMsg</a></div><div class="ttdeci">MsgPtr createMsg(TId &amp;&amp;id, unsigned idx=0)</div><div class="ttdoc">Create message object given the ID.</div><div class="ttdef"><b>Definition</b> ProtocolLayerBase.h:772</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
