<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>COMMS: How to Use Defined Custom Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COMMS
   </div>
   <div id="projectbrief">Template library intended to help with implementation of communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How to Use Defined Custom Protocol </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#page_use_prot_headers">Headers and Libraries</a></li>
<li class="level1"><a href="#page_use_prot_paths">Paths and Namespaces</a></li>
<li class="level1"><a href="#page_use_prot_error_handling">Error Handling</a></li>
<li class="level1"><a href="#page_use_prot_options">Configuration Options</a></li>
<li class="level1"><a href="#page_use_prot_interface">Defining Message Interface Class</a><ul><li class="level2"><a href="#page_use_prot_interface_id_retrieve">Polymorphic Retrieval of Message ID</a></li>
<li class="level2"><a href="#page_use_prot_interface_read">Polymorphic Read of Payload (Deserialisation)</a></li>
<li class="level2"><a href="#page_use_prot_interface_write">Polymorphic Write of Payload (Serialisation)</a></li>
<li class="level2"><a href="#page_use_prot_interface_length">Polymorphic Serialisation Length Retrieval</a></li>
<li class="level2"><a href="#page_use_prot_interface_valid">Polymorphic Validity Check</a></li>
<li class="level2"><a href="#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a></li>
<li class="level2"><a href="#page_use_prot_interface_refresh">Keeping Message Contents in a Consistent State</a></li>
<li class="level2"><a href="#page_use_prot_interface_name">Polymorphic Message Name Retrieval</a></li>
<li class="level2"><a href="#page_use_prot_interface_virt_destructor">Virtual Destructor</a></li>
<li class="level2"><a href="#page_use_prot_interface_summary">Interface Options Summary</a></li>
</ul>
</li>
<li class="level1"><a href="#page_use_prot_messages">Protocol Messages</a></li>
<li class="level1"><a href="#page_use_prot_fields">Message Fields</a><ul><li class="level2"><a href="#page_use_prot_fields_int_value">Integral Value Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_enum_value">Enum Value Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_bitmask_value">Bitmask Value Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_bitfield">Bitfield Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_bundle">Bundle Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_array_list">Array List Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_string">String Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_fp_value">Floating Point Value Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_optional">Optional Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_variant">Variant Fields</a></li>
<li class="level2"><a href="#page_use_prot_fields_customisation">Application Specific Customisation of Fields</a><ul><li class="level3"><a href="#page_use_prot_fields_customisation_seq">Customisation for Lists and Strings</a></li>
<li class="level3"><a href="#page_use_prot_fields_customisation_other">Customisation for Other Fields</a></li>
</ul>
</li>
<li class="level2"><a href="#page_use_prot_fields_value_assign">Field Value Assignment</a></li>
<li class="level2"><a href="#page_use_prot_fields_cast">Cast Between Fields</a></li>
</ul>
</li>
<li class="level1"><a href="#page_use_prot_transport">Transport Framing</a><ul><li class="level2"><a href="#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a></li>
<li class="level2"><a href="#page_use_prot_transport_msg_alloc">Message Object Allocation</a></li>
<li class="level2"><a href="#page_use_prot_transport_generic_msg">Using Generic Message</a></li>
<li class="level2"><a href="#page_use_prot_transport_write">Writing Transport Framing and Message Payload</a></li>
<li class="level2"><a href="#page_use_prot_transport_caching">Access to Processed Stack Fields</a></li>
</ul>
</li>
<li class="level1"><a href="#page_use_prot_handling">Message Handling</a><ul><li class="level2"><a href="#page_use_prot_handling_multi">Having Multiple Handlers</a></li>
<li class="level2"><a href="#page_use_prot_handling_generic">Generic Handler</a></li>
<li class="level2"><a href="#page_use_prot_handling_result">Returning Handling Result</a></li>
</ul>
</li>
<li class="level1"><a href="#page_use_prot_extra_transport">Extra Transport Values</a><ul><li class="level2"><a href="#page_use_prot_extra_transport_version">Built-in Version Support</a></li>
</ul>
</li>
<li class="level1"><a href="#page_use_prot_pseudo_transport">Pseudo Transport Values</a></li>
<li class="level1"><a href="#page_use_prot_msg_customisation">Application Specific Customisation of Messages</a></li>
<li class="level1"><a href="#page_use_prot_msg_extension">Message Interface Extension</a></li>
</ul>
</div>
<div class="textblock"><p>This page is oriented to client application developers. It provides instructions on how to use protocol defininition after it was developed following <a class="el" href="page_define_prot.html">How to Define New Custom Protocol</a> instructions. All the examples below will use <b>my_protocol</b> namespace for classes that are expectected to be already defined by the custom protocol implementation.</p>
<h1><a class="anchor" id="page_use_prot_headers"></a>
Headers and Libraries</h1>
<p>The protocol definition as well as <b>COMMS</b> library are headers-only. The protocol definition should already include all the required headers from the <b>COMMS</b> library. The client application will have to include only relevant headers from the protocol definition.</p>
<h1><a class="anchor" id="page_use_prot_paths"></a>
Paths and Namespaces</h1>
<p>All the classes provided by the <b>COMMS</b> library reside in <a class="el" href="namespacecomms.html">comms</a> namespace and the inner include paths start with "comms/". There may be the case when this library being integrated into existing project that may already define and use its own module (namespace) named <b>comms</b>. In this case it should be possible to rename installation directory (<b>comms</b> to <b>comms2</b>) and to run a script after library installation to replace the following strings with new name: </p><ul>
<li><b>"namespace comms"</b> - replace with "namespace comms2" </li>
<li><b>"comms::"</b> - replace with "comms2::" </li>
<li><b>"comms/"</b> - replace with "comms2/"</li>
</ul>
<h1><a class="anchor" id="page_use_prot_error_handling"></a>
Error Handling</h1>
<p>The <b>COMMS</b> library is intended to be used in embedded systems (including bare metal), which means the library does not use exceptions to report errors. The runtime errors are reported via <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> return values. All pre- and post-conditions are checked using <a class="el" href="Assert_8h.html#a941aec86290602caa61d86b671aea550" title="Generic assert macro.">COMMS_ASSERT()</a> macro. It is, just like regular standard <b>assert()</b>, is compiled in if <b>NDEBUG</b> symbol is not defined. In case the provided condition doesn't hold true, the macro checks whether custom assertion failure behaviour was registered. If yes, the registered custom assertion failure report is invoked, otherwise the standard failure report used by standard <b>assert()</b> macro is used. If COMMS library is used in bare metal environment without standard library, the <b>COMMS_NOSTDLIB</b> symbol should be defined. In this case infinite loop is a default assertion failure report behaviour.</p>
<p>See <a class="el" href="page_assert.html">Custom Assertion Failure Behaviour</a> for details on how to define custom assertion failure behaviour. <br  />
</p>
<h1><a class="anchor" id="page_use_prot_options"></a>
Configuration Options</h1>
<p>The <a class="el" href="page_define_prot.html">Protocol Definition</a> classes are expected to define all the relevant protocol classes in a way that provides an ability to perform end application specific customization, such as choice of specific data types and/or necessary polymorphic interfaces. Such customization is performed by passing various options defined in <a class="el" href="namespacecomms_1_1option_1_1app.html">comms::option::app</a> namespace to the relevant class definitions. The <a class="el" href="namespacecomms_1_1option_1_1def.html">comms::option::def</a> namespace contains all the types and classes relevant for the protocol definition itself. However, they can also be used by the end application if need arises to introduce such modifications.</p>
<h1><a class="anchor" id="page_use_prot_interface"></a>
Defining Message Interface Class</h1>
<p>The protocol definition is expected to define extendable message interface class pinning only serialisation endian and numeric message ID type (most probably enum). </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Used IDs definition</span></div>
<div class="line">    <span class="keyword">enum</span> MsgId : std::uint8_t</div>
<div class="line">    {</div>
<div class="line">        MsgId_Message1,</div>
<div class="line">        MsgId_Message2,</div>
<div class="line">        MsgId_Message3,</div>
<div class="line">        ...</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">using</span> Message = </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a>, <span class="comment">// endian</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType&lt;MsgId&gt;</a>, <span class="comment">// type of message ID</span></div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1Message_html"><div class="ttname"><a href="classcomms_1_1Message.html">comms::Message</a></div><div class="ttdoc">Main interface class for all the messages.</div><div class="ttdef"><b>Definition:</b> Message.h:80</div></div>
<div class="ttc" id="anamespacecomms_1_1option_1_1def_html_a606d8afcd788b9c39088709e9be2f546"><div class="ttname"><a href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a></div><div class="ttdeci">Endian&lt; comms::traits::endian::Big &gt; BigEndian</div><div class="ttdoc">Alias option to Endian specifying Big endian.</div><div class="ttdef"><b>Definition:</b> options.h:177</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1MsgIdType_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a></div><div class="ttdoc">Option used to specify type of the ID.</div><div class="ttdef"><b>Definition:</b> options.h:187</div></div>
</div><!-- fragment --><p> Such interface class is <b>NOT</b> polymorphic, it defines the following inner types </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line">    </div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span> <a class="code" href="classcomms_1_1Message.html">comms::Message</a></div>
<div class="line">    <span class="comment">// comms::Field class with the same endian option. </span></div>
<div class="line">    <span class="comment">// Can (and should) be provided as a base class to all the</span></div>
<div class="line">    <span class="comment">// fields.</span></div>
<div class="line">    typedef <a class="code" href="classcomms_1_1Field.html">comms::Field</a>&lt;...<span class="comment">/* Same endian option*/</span>&gt; Field;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Type of the ID, same as the one passed with comms::option::def::MsgIdType</span></div>
<div class="line">    typedef MsgId <a class="code" href="namespacecomms_1_1option.html#ae116d8be9449c27165351b3f07151284">MsgIdType</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Type of the ID, when it is passed as a parameter and/or returned from the function:</span></div>
<div class="line">    typedef MsgId MsgIdParamType;</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1Field_html"><div class="ttname"><a href="classcomms_1_1Field.html">comms::Field</a></div><div class="ttdoc">Base class to all the field classes.</div><div class="ttdef"><b>Definition:</b> Field.h:33</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_ae116d8be9449c27165351b3f07151284"><div class="ttname"><a href="namespacecomms_1_1option.html#ae116d8be9449c27165351b3f07151284">comms::option::MsgIdType</a></div><div class="ttdeci">comms::option::def::MsgIdType&lt; T &gt; MsgIdType</div><div class="ttdoc">Same as comms::option::def::MsgIdType.</div><div class="ttdef"><b>Definition:</b> options.h:1419</div></div>
</div><!-- fragment --><p> <b>Note</b> the existence of <b>MsgIdType</b> and <b>MsgIdParamType</b>. When the type used for message ID is simple integral one or enum, these types are equal. However, if some other type is used, such as std::string, then <b>MsgIdParamType</b> is a const-reference to <b>MsgIdType</b>.</p>
<p>The message interface class may be extended with multiple options, which automatically add virtual functions, and hence create polymorphic behaviour relevant to the client application.</p>
<p>In general, all the API functions that are being added to the interface (and described below) use <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface</a> idiom: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> someFunction(...)</div>
<div class="line">    {</div>
<div class="line">        ...; <span class="comment">// Pre-conditions check and/or other common operations</span></div>
<div class="line">        someFunctionImpl(...); <span class="comment">// Invocation of polymorphic functionality</span></div>
<div class="line">        ...; <span class="comment">// Post-conditions check and/or other common operations</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> someFunctionImpl(...) = 0; <span class="comment">// Must be implemented in the derived class</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> The polymorphic behaviour is exposed via <b>protected</b> virtual functions having the same name, but with <b>Impl</b> suffix.</p>
<p>All the variants of message interface class that are going to be described below are descendants of <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class. Please refer to the documentation of the latter for detailed info on the described functions and their parameters.</p>
<h2><a class="anchor" id="page_use_prot_interface_id_retrieve"></a>
Polymorphic Retrieval of Message ID</h2>
<p>When there is a need to be able to polymorphically retrieve message ID, the <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option needs to be used. Note, that this option requires presence of <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> (which is expected to be used in protocol definition) to specify type of the message ID in order to work properly. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage =</div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#a03117ed117740f000541038e3670bf0e">comms::option::app::IdInfoInterface</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a03117ed117740f000541038e3670bf0e"><div class="ttname"><a href="namespacecomms_1_1option.html#a03117ed117740f000541038e3670bf0e">comms::option::IdInfoInterface</a></div><div class="ttdeci">comms::option::app::IdInfoInterface IdInfoInterface</div><div class="ttdoc">Same as comms::option::app::IdInfoInterface.</div><div class="ttdef"><b>Definition:</b> options.h:1813</div></div>
</div><!-- fragment --><p> It adds the following functions: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// API function to retrieve ID of the function</span></div>
<div class="line">    MsgIdParamType <a class="code" href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">getId</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> MsgIdParamType <a class="code" href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">getIdImpl</a>() <span class="keyword">const</span> = 0; <span class="comment">// Automatically implemented in the actual message class</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1Message_html_aa8e70f9849dc35cc25018207d556b691"><div class="ttname"><a href="classcomms_1_1Message.html#aa8e70f9849dc35cc25018207d556b691">comms::Message::getIdImpl</a></div><div class="ttdeci">virtual MsgIdParamType getIdImpl() const =0</div><div class="ttdoc">Pure virtual function used to retrieve ID of the message.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_aaac9fd890f4efb1263179c3799d52098"><div class="ttname"><a href="classcomms_1_1Message.html#aaac9fd890f4efb1263179c3799d52098">comms::Message::getId</a></div><div class="ttdeci">MsgIdParamType getId() const</div><div class="ttdoc">Retrieve ID of the message.</div></div>
</div><!-- fragment --><p> The usage of <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> without <a class="el" href="structcomms_1_1option_1_1def_1_1MsgIdType.html">comms::option::def::MsgIdType</a> will be ignored, and <b>getId()</b> as well as <b>getIdImpl()</b> member functions won't be created.</p>
<p>The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#aa00be33cb01b7e9cdee9ecebfa54c171">comms::Message::hasGetId()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1IdInfoInterface.html">comms::option::app::IdInfoInterface</a> option has been used, i.e. the message interface class defines mentioned earlier functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_read"></a>
Polymorphic Read of Payload (Deserialisation)</h2>
<p>If the implementation requires polymorphic read and process of input messages, the <b>read()</b> operation needs to be added to the interface. It is achieved by using <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option to provide a type of the iterator that is going to be used for reading: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator&lt;const std::uint8_t*&gt;</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1ReadIterator_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a></div><div class="ttdoc">Option used to specify type of iterator used for reading.</div><div class="ttdef"><b>Definition:</b> options.h:1241</div></div>
</div><!-- fragment --><p> As the result the interface class defines the following types and functions: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Type of the the iterator used for reading, the same as provided with</span></div>
<div class="line">    <span class="comment">// comms::option::app::ReadIterator option.</span></div>
<div class="line">    <span class="keyword">typedef</span> ... <a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">ReadIterator</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// API function to perform read</span></div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">read</a>(<a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">ReadIterator</a>&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl</a>(iter, len);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Expected to be overriden in the derived class.</span></div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">readImpl</a>(<a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">ReadIterator</a>&amp; iter, std::size_t len) </div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb">comms::ErrorStatus::NotSupported</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1Message_html_a77396db2ec7a29de4bf335af49e1d760"><div class="ttname"><a href="classcomms_1_1Message.html#a77396db2ec7a29de4bf335af49e1d760">comms::Message::read</a></div><div class="ttdeci">ErrorStatus read(ReadIterator &amp;iter, std::size_t size)</div><div class="ttdoc">Read message contents using provided iterator.</div></div>
<div class="ttc" id="aclasscomms_1_1Message_html_a8679fd222f23e632097defc811aefbd6"><div class="ttname"><a href="classcomms_1_1Message.html#a8679fd222f23e632097defc811aefbd6">comms::Message::readImpl</a></div><div class="ttdeci">virtual comms::ErrorStatus readImpl(ReadIterator &amp;iter, std::size_t size)</div><div class="ttdoc">Virtual function used to implement read operation.</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_a6bfb15414c84bb8644f05ffa20198515"><div class="ttname"><a href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">comms::option::ReadIterator</a></div><div class="ttdeci">comms::option::app::ReadIterator&lt; TIter &gt; ReadIterator</div><div class="ttdoc">Same as comms::option::app::ReadIterator.</div><div class="ttdef"><b>Definition:</b> options.h:1806</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a></div><div class="ttdeci">ErrorStatus</div><div class="ttdoc">Error statuses reported by the Communication module.</div><div class="ttdef"><b>Definition:</b> ErrorStatus.h:17</div></div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb">comms::ErrorStatus::NotSupported</a></div><div class="ttdeci">@ NotSupported</div><div class="ttdoc">The operation is not supported.</div></div>
</div><!-- fragment --><p> Please <b>note</b>, that COMMS library doesn't impose any restrictions on how the input data is collected and stored. It is a responsibility of the <b>caller</b> to allocate and maintain the input buffer, while providing only an iterator for read operation. <br  />
Also <b>note</b>, that iterator is passed by reference, which allows advancing operator when read operation is performed. <br  />
For example: </p><div class="fragment"><div class="line">std::size_t readMessage(MyMessage&amp; msg, <span class="keyword">const</span> std::uint8_t* buf, std::size_t len)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">MyMessage::ReadIterator</a> readIter = buf;</div>
<div class="line">    <span class="keyword">auto</span> es = msg.read(readIter, len); <span class="comment">// readIter is advanced in the read operation</span></div>
<div class="line">    <span class="keywordflow">if</span> (es != <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">        ... <span class="comment">// Report and handle error</span></div>
<div class="line">        <span class="keywordflow">return</span> 0U; </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Report number of processed bytes from buffer:</span></div>
<div class="line">    <span class="keyword">auto</span> bytesCount = std::distance(<a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">MyMessage::ReadIterator</a>(buf), readIter);</div>
<div class="line">    <span class="keywordflow">return</span> bytesCount;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a></div><div class="ttdeci">@ Success</div><div class="ttdoc">Used to indicate successful outcome of the operation.</div></div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#a1cab88111f9e395e71f8a8eb05c99fb5">comms::Message::hasRead()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator</a> option has been used, i.e. the message interface class defines mentioned earlier types and functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_write"></a>
Polymorphic Write of Payload (Serialisation)</h2>
<p>If the implementation requires polymorphic serialisation of the messages and sending them over I/O link, the <b>write()</b> operation needs to be added to the interface. It is achieved by using <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option to provide a type of the iterator that is going to be used for writing: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator&lt;std::back_insert_iterator&lt;std::vector&lt;std::uint8_t&gt;</a> &gt; &gt;,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1WriteIterator_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a></div><div class="ttdoc">Option used to specify type of iterator used for writing.</div><div class="ttdef"><b>Definition:</b> options.h:1247</div></div>
</div><!-- fragment --><p> As the result the interface class defines the following types and functions: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Type of the the iterator used for writing, the same as provided with</span></div>
<div class="line">    <span class="comment">// comms::option::app::WriteIterator option.</span></div>
<div class="line">    <span class="keyword">typedef</span> ... <a class="code" href="namespacecomms_1_1option.html#a407c3ebeac360f26e51899312568ebb8">WriteIterator</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// API function to perform write</span></div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> write(<a class="code" href="namespacecomms_1_1option.html#a407c3ebeac360f26e51899312568ebb8">WriteIterator</a>&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> writeImpl(iter, len);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Expected to be overriden in the derived class.</span></div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> writeImpl(<a class="code" href="namespacecomms_1_1option.html#a407c3ebeac360f26e51899312568ebb8">WriteIterator</a>&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a9ed2d871602556951e39f3cebd08d6cb">comms::ErrorStatus::NotSupported</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a407c3ebeac360f26e51899312568ebb8"><div class="ttname"><a href="namespacecomms_1_1option.html#a407c3ebeac360f26e51899312568ebb8">comms::option::WriteIterator</a></div><div class="ttdeci">comms::option::app::WriteIterator&lt; TIter &gt; WriteIterator</div><div class="ttdoc">Same as comms::option::app::WriteIterator.</div><div class="ttdef"><b>Definition:</b> options.h:1810</div></div>
</div><!-- fragment --><p> Please <b>note</b>, that COMMS library doesn't impose any restrictions on storage type for the output buffer. It is a responsibility of the <b>caller</b> to allocate and maintain the output buffer, while providing only an iterator for write operation. In the example above the output buffer is chosen to be <b>std::vector&lt;std::uint8_t&gt;</b> and the write operation will be performed using <b>push_back()</b> calls on this vector (due to <b>std::back_insert_iterator</b> being chosen as <b>WriteIterator</b>).</p>
<p>Also <b>note</b>, that iterator is passed by reference, which allows advancing operator when write operation is performed. In case the iterator is random-access one, the difference between the initial and its value after the write has been performed can be used to determine amount of bytes that have been written to the buffer.</p>
<p>The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#aa7a317a10acda2cd7affd8b69a7b459a">comms::Message::hasWrite()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option has been used, i.e. the message interface class defines mentioned earlier types and functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_length"></a>
Polymorphic Serialisation Length Retrieval</h2>
<p>Sometimes it may be needed to polymorphically retrieve the serialisation length of the message in order to be able to reserve or allocate enough space for output buffer. The <b>COMMS</b> library provides <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option that adds <b>length()</b> member function to the interface. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#adf3a68ac5e1b3c10e4cd92ea8cd3b7b0">comms::option::app::LengthInfoInterface</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_adf3a68ac5e1b3c10e4cd92ea8cd3b7b0"><div class="ttname"><a href="namespacecomms_1_1option.html#adf3a68ac5e1b3c10e4cd92ea8cd3b7b0">comms::option::LengthInfoInterface</a></div><div class="ttdeci">comms::option::app::LengthInfoInterface LengthInfoInterface</div><div class="ttdoc">Same as comms::option::app::LengthInfoInterface.</div><div class="ttdef"><b>Definition:</b> options.h:1819</div></div>
</div><!-- fragment --><p> This option adds the following functions to the interface definition: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Retrieve the serialisation length</span></div>
<div class="line">    std::size_t length()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> lengthImpl();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> std::size_t lengthImpl()<span class="keyword"> const </span>{...}; <span class="comment">// Must be overridden in the derived class</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#aaaded9d46874a89824e91c962524836d">comms::Message::hasLength()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> option has been used, i.e. the message interface class defines mentioned earlier functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_valid"></a>
Polymorphic Validity Check</h2>
<p>Sometimes it may be needed to be able to check whether the message contents (fields) have valid values. The <b>COMMS</b> library provides <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html" title="Option used to add valid() function into Message interface.">comms::option::app::ValidCheckInterface</a> option that adds <b>valid()</b> member function to the interface: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage =</div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#a5049cec0c01322150d3d68cb4220468d">comms::option::app::ValidCheckInterface</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a5049cec0c01322150d3d68cb4220468d"><div class="ttname"><a href="namespacecomms_1_1option.html#a5049cec0c01322150d3d68cb4220468d">comms::option::ValidCheckInterface</a></div><div class="ttdeci">comms::option::app::ValidCheckInterface ValidCheckInterface</div><div class="ttdoc">Same as comms::option::app::ValidCheckInterface.</div><div class="ttdef"><b>Definition:</b> options.h:1816</div></div>
</div><!-- fragment --><p> This option adds the following functions to the interface definition: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Retrieve the serialisation length</span></div>
<div class="line">    <span class="keywordtype">bool</span> valid()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> validImpl();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> validImpl()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// By default all messages are valid, can be overridden in derived class.</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#a133c135fda72ca2257fed0f5427053b4">comms::Message::hasValid()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1ValidCheckInterface.html">comms::option::app::ValidCheckInterface</a> option has been used, i.e. the message interface class defines mentioned earlier functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_handle"></a>
Polymorphic Dispatch Message for Handling</h2>
<p>When new data arrives on I/O link, it's transport framing is going to be processed (described in detailed in <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a> section below). and new message object is going to be created. It's going to be returned as a smart pointer (std::unique_ptr) to the defined interface class (<b>MyMessage</b>). The actual type of this message object needs to be recognised and message properly handled. Using simple switch statement on message ID (returned by <b>getId()</b> interface function) can result in significant amount of boilerplate code, which grows and must be updated every time new message is added to the protocol. The <b>COMMS</b> library provides much better way to dispatch messages to appropriate handler.</p>
<p>The handler class needs to be forward declared and passed to the definition of <b>MyMessage</b> interface via <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option. </p><div class="fragment"><div class="line"><span class="comment">// Forward declaration</span></div>
<div class="line"><span class="keyword">class </span>MyHandler;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyHandler = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler&lt;MyHandler&gt;</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1Handler_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a></div><div class="ttdoc">Option used to specify type of the message handler.</div><div class="ttdef"><b>Definition:</b> options.h:1273</div></div>
</div><!-- fragment --><p> When this option is used the <b>MyMessage</b> will define the following interface types and functions: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// The same type as passed via comms::option::app::Handler option     </span></div>
<div class="line">    <span class="keyword">typedef</span> ... <a class="code" href="namespacecomms_1_1option.html#a62c855d5dce0a0ef977238ea051d288a">Handler</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Return type of the dispatch function, which is the same as return type of</span></div>
<div class="line">    <span class="comment">// every Handler::handle() member function</span></div>
<div class="line">    <span class="keyword">typedef</span> ... DispatchRetType;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dispatch this message to handler</span></div>
<div class="line">    DispatchRetType dispatch(<a class="code" href="namespacecomms_1_1option.html#a62c855d5dce0a0ef977238ea051d288a">Handler</a>&amp; handler)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> dispatchImpl(handler);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> DispatchRetType dispatchImpl(<a class="code" href="namespacecomms_1_1option.html#a62c855d5dce0a0ef977238ea051d288a">Handler</a>&amp; handler) {...} <span class="comment">// Must be overridden in the derived class</span></div>
<div class="line">};</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a62c855d5dce0a0ef977238ea051d288a"><div class="ttname"><a href="namespacecomms_1_1option.html#a62c855d5dce0a0ef977238ea051d288a">comms::option::Handler</a></div><div class="ttdeci">comms::option::app::Handler&lt; T &gt; Handler</div><div class="ttdoc">Same as comms::option::app::Handler.</div><div class="ttdef"><b>Definition:</b> options.h:1829</div></div>
</div><!-- fragment --><p> More details about polymorphic dispatching and handling will be provided below in <a class="el" href="page_use_prot.html#page_use_prot_handling">Message Handling</a> section.</p>
<p>The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#aec8ad53f1b5aa5f06a0d47c7d9585783">comms::Message::hasDispatch()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler</a> option has been used, i.e. the message interface class defines mentioned earlier types and functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_refresh"></a>
Keeping Message Contents in a Consistent State</h2>
<p>Some communication protocol may define fields that depend on other fields. For example, bits in a bitmask field may be used to define whether some optional fields exist. Or the information about amount of elements in the list to follow may reside in an independent numeric field. <br  />
 After updating such fields directly, using the interface of the message object, the message contents may end up being in an inconsistent (or invalid) state. There may be a need to polymorphically normalise the state of the message object. The <b>COMMS</b> library provides <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option, that adds <b>refresh()</b> member function to the message interface. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#a9c4b999f046f218fe5b0d27bf3196681">comms::option::app::RefreshInterface</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a9c4b999f046f218fe5b0d27bf3196681"><div class="ttname"><a href="namespacecomms_1_1option.html#a9c4b999f046f218fe5b0d27bf3196681">comms::option::RefreshInterface</a></div><div class="ttdeci">comms::option::app::RefreshInterface RefreshInterface</div><div class="ttdoc">Same as comms::option::app::RefreshInterface.</div><div class="ttdef"><b>Definition:</b> options.h:1822</div></div>
</div><!-- fragment --><p> This option adds the following functions to the interface definition: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Refresh message contents</span></div>
<div class="line">    <span class="keywordtype">bool</span> refresh()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> refreshImpl();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> refreshImpl()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, that the <a class="el" href="classcomms_1_1Message.html#adf78ac63decb13777fd7d203de01fdd1">refresh()</a> member function returns boolean value, which is expected to be <b>true</b> in case at least one of the internal fields has been updated, and <b>false</b> if message state remains unchanged. <br  />
Also note, that interface provide default implementation of <b>refreshImpl()</b> virtual function. The message object that require proper "refresh" functionality may just override it with proper implementation.</p>
<p>The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#ae0929a96d1cb0c12a2b2a383ebd015ef">comms::Message::hasRefresh()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1RefreshInterface.html">comms::option::app::RefreshInterface</a> option has been used, i.e. the message interface class defines mentioned earlier functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_name"></a>
Polymorphic Message Name Retrieval</h2>
<p>Some applications may require knowledge about and report the name of the received / sent message. The <b>COMMS</b> library provides <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option, that adds <b>name()</b> member function to the message interface (see <a class="el" href="classcomms_1_1Message.html#acdc8a1db5b023e576dd74f906dd547ad">comms::Message::name()</a>). </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#a741507dd462ca95f3aaea65bf7f2fb24">comms::option::app::NameInterface</a>,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a741507dd462ca95f3aaea65bf7f2fb24"><div class="ttname"><a href="namespacecomms_1_1option.html#a741507dd462ca95f3aaea65bf7f2fb24">comms::option::NameInterface</a></div><div class="ttdeci">comms::option::app::NameInterface NameInterface</div><div class="ttdoc">Same as comms::option::app::NameInterface.</div><div class="ttdef"><b>Definition:</b> options.h:1825</div></div>
</div><!-- fragment --><p> This option adds the following functions to the interface definition: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Retrieve name of the message </span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* name()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> nameImpl();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* nameImpl() <span class="keyword">const</span> = 0; <span class="comment">// Must be overridden in the derived class</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#abcaf6e76e7639112d33a04683a4e1a43">comms::Message::hasName()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> option has been used, i.e. the message interface class defines mentioned earlier functions.</p>
<h2><a class="anchor" id="page_use_prot_interface_virt_destructor"></a>
Virtual Destructor</h2>
<p>By default the <a class="el" href="classcomms_1_1Message.html">comms::Message</a> class defines its destructor as <b>virtual</b> if and only if it exhibits a polymorphic behaviour, i.e. if there is at least one other virtual function defined. There are a couple of ways to change this default behaviour. </p><ul>
<li>If the definition of the common message interface class using exhibits polymorphic behaviour (i.e. has other virtual functions), but mustn't define its destructor as <b>virtual</b>, use <a class="el" href="structcomms_1_1option_1_1app_1_1NoVirtualDestructor.html">comms::option::app::NoVirtualDestructor</a> option in the interface class definition. <div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1NoVirtualDestructor.html">comms::option::app::NoVirtualDestructor</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1NoVirtualDestructor_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1NoVirtualDestructor.html">comms::option::app::NoVirtualDestructor</a></div><div class="ttdoc">Force the destructor of comms::Message class to be non-virtual, even if there are other virtual funct...</div><div class="ttdef"><b>Definition:</b> options.h:1362</div></div>
</div><!-- fragment --> </li>
<li>If the definition of the common interface class doesn't have any virtual function, but still requires an ability to be polymorphically deleted, i.e. must have virtual destructor, just inherit from <b>my_protocol::Message</b> and define the destructor as virtual. <div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage : <span class="keyword">public</span> </div>
<div class="line">    my_protocol::Message&lt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~MyMessage() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="page_use_prot_interface_summary"></a>
Interface Options Summary</h2>
<p>All the options introduced above can be used in any order. They can also be repeated multiple times. However, the option that was defined first takes priority over (or overrides) the same option defined later. <br  />
 For example, the definition below defines <b>WriteIterator</b> to be <b>std::uint8_t*</b>, because it was defined with first <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator&lt;std::uint8_t*&gt;</a>, </div>
<div class="line">        ...</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator&lt;std::back_insert_iterator&lt;std::vector&lt;std::uint8_t&gt;</a> &gt;,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> The definition below gives a full interface of all the introduced functions: <b>getId()</b>, <b>read()</b>, <b>write()</b>, <b>dispatch()</b>, <b>length()</b>, <b>valid()</b>, <b>refresh()</b>, and <b>name()</b>. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage = my_protocol::Message&lt;</div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#a03117ed117740f000541038e3670bf0e">comms::option::app::IdInfoInterface</a>, <span class="comment">// Add an ability to retrieve message ID value</span></div>
<div class="line">    <a class="code" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator&lt;const std::uint8_t*&gt;</a>, <span class="comment">// Use const std::uint8_t* as iterator for reading</span></div>
<div class="line">    <a class="code" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator&lt;std::uint8_t*&gt;</a>, <span class="comment">// Use std::uint8_t* as iterator for writing</span></div>
<div class="line">    <a class="code" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler&lt;MyHandler&gt;</a>, <span class="comment">// My MyHandler class declared earlier as a handler for messages</span></div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#adf3a68ac5e1b3c10e4cd92ea8cd3b7b0">comms::option::app::LengthInfoInterface</a>, <span class="comment">// Add an ability to retrieve serialisation length</span></div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#a5049cec0c01322150d3d68cb4220468d">comms::option::app::ValidCheckInterface</a>, <span class="comment">// Add an ability to check contents validity</span></div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#a9c4b999f046f218fe5b0d27bf3196681">comms::option::app::RefreshInterface</a>,  <span class="comment">// Add an ability to refresh message contents</span></div>
<div class="line">    <a class="code" href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a> <span class="comment">// Add an ability to retrieve message name</span></div>
<div class="line">&gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1NameInterface_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1NameInterface.html">comms::option::app::NameInterface</a></div><div class="ttdoc">Option used to add name() function into Message interface.</div><div class="ttdef"><b>Definition:</b> options.h:1267</div></div>
</div><!-- fragment --><p> In case no polymorphic interface extension option has been chosen, every message object becomes a simple "data structure" without any v-table "penalty". </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyInterface = my_protocol::Message&lt;&gt;;</div>
</div><!-- fragment --><h1><a class="anchor" id="page_use_prot_messages"></a>
Protocol Messages</h1>
<p>The protocol messages are expected to be defined as template classes, receiving at least one template parameter, which specifies the application specific interface class. For example </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase,</div>
<div class="line">        ...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="aclasscomms_1_1MessageBase_html"><div class="ttname"><a href="classcomms_1_1MessageBase.html">comms::MessageBase</a></div><div class="ttdoc">Base class for all the custom protocol messages.</div><div class="ttdef"><b>Definition:</b> MessageBase.h:80</div></div>
</div><!-- fragment --><p> The interface class that was defined for the application (<b>MyMessage</b>) needs to be passed as <b>TBase</b> template parameter. The defined message class extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>, which in turn extends provided interface class <b>TBase</b>, which in turn extends (or typedef-s) <a class="el" href="classcomms_1_1Message.html">comms::Message</a>. The inheritance hierarchy may look like this: <div class="diagraph">
<img src="dia_message_class_hierarchy.png" />
</div>
</p>
<p>Due to the fact that every protocol message class extends <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>, the detailed documentation on available member types and functions can be viewed on <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> reference page.</p>
<p>All the protocol message classes implement <b>non-virtual</b> functions that may be used to implement polymorphic behavior. These function has the same name as described earlier interface, but start with <b>do*</b> prefix.</p>
<ul>
<li><b>doRead()</b> - implements message read functionality (see <a class="el" href="classcomms_1_1MessageBase.html#a45782845d1f24fc957efe1a41fdf32c4">comms::MessageBase::doRead()</a>) </li>
<li><b>doWrite()</b> - implements message write functionality (see <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">comms::MessageBase::doWrite()</a>) </li>
<li><b>doLength()</b> - implements message serialisation length calculation (see <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">comms::MessageBase::doLength()</a>) </li>
<li><b>doValid()</b> - implements message contents validity check (see <a class="el" href="classcomms_1_1MessageBase.html#afcb3077fb16f36d4710effc4d61a1330">comms::MessageBase::doValid()</a>) </li>
<li><b>doRefresh()</b> - implements bringing message to a consistent state (see <a class="el" href="classcomms_1_1MessageBase.html#a2feb6d8948de99eef4213a234625d3ec">comms::MessageBase::doRefresh()</a>) </li>
<li><b>doName()</b> - implements retrieval of the message name.</li>
</ul>
<p>Based on the requested polymorphic functionality, the <b><a class="el" href="classcomms_1_1MessageBase.html" title="Base class for all the custom protocol messages.">comms::MessageBase</a></b> class automatically implements virtual <b>*Impl</b>() member functions (but only when needed). </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase,</div>
<div class="line">        ...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doRead(TIter&amp; iter, std::size_t len) {...}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> doWrite(TIter&amp; iter, std::size_t len)<span class="keyword"> const </span>{...}</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">protected:</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> readImpl(<a class="code" href="namespacecomms_1_1option.html#a6bfb15414c84bb8644f05ffa20198515">ReadIterator</a>&amp; iter, std::size_t len)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> doRead(iter, len);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> writeImpl(<a class="code" href="namespacecomms_1_1option.html#a407c3ebeac360f26e51899312568ebb8">WriteIterator</a>&amp; iter, std::size_t len)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> doWrite(iter, len);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> Such architecture allows usage of non-virtual functions when actual type of the message is known. For example </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line"><span class="keywordtype">void</span> writeMessage(<span class="keyword">const</span> TMsg&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> es = msg.doWrite(...);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> and using polymorphic behaviour when not </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> writeMessage(<span class="keyword">const</span> MyMessage&amp; msg)</div>
<div class="line">{</div>
<div class="line">    static_assert(MyMessage::hasWrite(), <span class="stringliteral">&quot;MyMessage must support polymorphic write&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> es = msg.write(...);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Every message has zero or more fields, which are stored in <b>std::tuple</b> as private members of <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>. The access to the fields can be obtained using <b>fields()</b> member function (see <a class="el" href="classcomms_1_1MessageBase.html#af4b8bc4b6db684d0006d2c6c70b1e891">comms::MessageBase::fields()</a>).</p>
<p>However, every message that has at least one field is expected to use <a class="el" href="classcomms_1_1MessageBase.html#a2c70987da383935a4cf0ceb5228f497a">COMMS_MSG_FIELDS_NAMES()</a> (or <a class="el" href="classcomms_1_1MessageBase.html#a25cd34ed5b338241067433c45d7345ac">COMMS_MSG_FIELDS_ACCESS()</a> in older versions) macro to provide names to inner fields. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase,</div>
<div class="line">        ...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_MSG_FIELDS_NAMES(value1, value2, value3);</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> It is equivalent of having the following types and member functions defined. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase,</div>
<div class="line">        ...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> FieldIdx</div>
<div class="line">    {</div>
<div class="line">        FieldIdx_value1,</div>
<div class="line">        FieldIdx_value2,</div>
<div class="line">        FieldIdx_value3,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value1&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value1() -&gt; decltype(std::get&lt;FieldIdx_value1&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value1&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value1&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value1() const -&gt; decltype(std::get&lt;FieldIdx_value1&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value1&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value2&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value2() -&gt; decltype(std::get&lt;FieldIdx_value2&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value2&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value2&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value2() const -&gt; decltype(std::get&lt;FieldIdx_value2&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value2&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value3&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() -&gt; decltype(std::get&lt;FieldIdx_value3&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value3&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;value3&quot; field (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> field_value3() const -&gt; decltype(std::get&lt;FieldIdx_value3&gt;(fields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_value3&gt;(fields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Types of used fields</span></div>
<div class="line">    <span class="keyword">using</span> Field_value1 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">    <span class="keyword">using</span> Field_value2 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">    <span class="keyword">using</span> Field_value3 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> As the result every message field can be accessed by index </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::Message1&lt;MyMessage&gt;;</div>
<div class="line">MyMessage1 msg;</div>
<div class="line"><span class="keyword">auto</span>&amp; msg1Fields = msg.fields(); <span class="comment">// access to std::tuple of message fields.</span></div>
<div class="line"><span class="keyword">auto</span>&amp; value1Field = std::get&lt;MyMessage1::FieldIdx_value1&gt;(msg1Fields);</div>
<div class="line"><span class="keyword">auto</span>&amp; value2Field = std::get&lt;MyMessage1::FieldIdx_value2&gt;(msg1Fields);</div>
<div class="line"><span class="keyword">auto</span>&amp; value2Field = std::get&lt;MyMessage1::FieldIdx_value2&gt;(msg1Fields);</div>
</div><!-- fragment --><p> or by name </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; value1Field = msg.field_value1();</div>
<div class="line"><span class="keyword">auto</span>&amp; value2Field = msg.field_value2();</div>
<div class="line"><span class="keyword">auto</span>&amp; value2Field = msg.field_value3();</div>
</div><!-- fragment --><h1><a class="anchor" id="page_use_prot_fields"></a>
Message Fields</h1>
<p>In order to continue with the tutorial, it is paramount to understand a concept of <b>fields</b>, which are abstractions around value storage primitives and/or objects, such as integral values, floating point values, strings, arrays, etc.. Every <b>field</b> class is defined in <a class="el" href="namespacecomms_1_1field.html">comms::field</a> namespace and exposes predefined interface in order to make template meta-programming as easy as possible. As an example let's take a look at <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> class which is used to define integral value field. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> : <span class="keyword">public</span> TBase</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Define inner storage type</span></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a> = T;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get access to the stored value</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a>&amp; <a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>() { <span class="keywordflow">return</span> m_value; }</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a>&amp; <a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_value; }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">read</a>(TIter&amp; iter, std::size_t len) {...}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TIter&gt;</div>
<div class="line">    <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">comms::ErrorStatus</a> <a class="code" href="classcomms_1_1field_1_1IntValue.html#acde94491d8bec35eebd751d8e598224f">write</a>(TIter&amp; iter, std::size_t len)<span class="keyword"> const </span>{...}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Serialisation length</span></div>
<div class="line">    std::size_t <a class="code" href="classcomms_1_1field_1_1IntValue.html#a822ea1aa868e545c08f258183d0e389b">length</a>()<span class="keyword"> const </span>{...}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Validity of the value</span></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#a4591523e8f580ce0e34b6c50a15e1f84">valid</a>()<span class="keyword"> const </span>{...}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Bring field&#39;s contents into a consistent state</span></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classcomms_1_1field_1_1IntValue.html#aed219921ab7ccd3876c4cda32b53fc29">refresh</a>() {...}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">ValueType</a> m_value;</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a></div><div class="ttdoc">Field that represent integral value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:73</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_a0a72f169069219478bd2c6bce26e8809"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#a0a72f169069219478bd2c6bce26e8809">comms::field::IntValue::ValueType</a></div><div class="ttdeci">typename BaseImpl::ValueType ValueType</div><div class="ttdoc">Type of underlying integral value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:94</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_a4591523e8f580ce0e34b6c50a15e1f84"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#a4591523e8f580ce0e34b6c50a15e1f84">comms::field::IntValue::valid</a></div><div class="ttdeci">bool valid() const</div><div class="ttdoc">Check validity of the field value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:222</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_a6317922167564fa2889270afcb963500"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">comms::field::IntValue::value</a></div><div class="ttdeci">const ValueType &amp; value() const</div><div class="ttdoc">Get access to integral value storage.</div><div class="ttdef"><b>Definition:</b> IntValue.h:162</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_a822ea1aa868e545c08f258183d0e389b"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#a822ea1aa868e545c08f258183d0e389b">comms::field::IntValue::length</a></div><div class="ttdeci">constexpr std::size_t length() const</div><div class="ttdoc">Get length required to serialise the current field value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:202</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_ab258d5bbd1e5ed5dc1a2840e24d09781"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#ab258d5bbd1e5ed5dc1a2840e24d09781">comms::field::IntValue::read</a></div><div class="ttdeci">ErrorStatus read(TIter &amp;iter, std::size_t size)</div><div class="ttdoc">Read field value from input data sequence.</div><div class="ttdef"><b>Definition:</b> IntValue.h:240</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_acde94491d8bec35eebd751d8e598224f"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#acde94491d8bec35eebd751d8e598224f">comms::field::IntValue::write</a></div><div class="ttdeci">ErrorStatus write(TIter &amp;iter, std::size_t size) const</div><div class="ttdoc">Write current field value to output data sequence.</div><div class="ttdef"><b>Definition:</b> IntValue.h:275</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1IntValue_html_aed219921ab7ccd3876c4cda32b53fc29"><div class="ttname"><a href="classcomms_1_1field_1_1IntValue.html#aed219921ab7ccd3876c4cda32b53fc29">comms::field::IntValue::refresh</a></div><div class="ttdeci">bool refresh()</div><div class="ttdoc">Refresh the field's value.</div><div class="ttdef"><b>Definition:</b> IntValue.h:229</div></div>
</div><!-- fragment --><p> The main things to note are that every field definition class: </p><ul>
<li>receives its base class as the first template parameter. It is expected to be a variant of <a class="el" href="classcomms_1_1Field.html">comms::Field</a> with <a class="el" href="namespacecomms_1_1option_1_1def.html#a606d8afcd788b9c39088709e9be2f546">comms::option::def::BigEndian</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#af84304efc306dc824db55e16a92f016d">comms::option::def::LittleEndian</a> option to specify the serialisation endian. It may be inner <b>Field</b> type of <b>MyMessage</b> interface class defined earlier (<b>MyMessage::Field</b> - documented as <a class="el" href="classcomms_1_1Message.html#a4cd3705f965f28c601858aced3f16c48">comms::Message::Field</a>) </li>
<li>exhibits some default behaviour which can be modified by passing various options from <a class="el" href="namespacecomms_1_1option_1_1app.html">comms::option::app</a> and/or <a class="el" href="namespacecomms_1_1option_1_1def.html" title="Namespace that contains all the options used to define protocol.">comms::option::def</a> namespaces as additional template parameters. The options that define how field is serialised are expected to be used as part of protocol definition. The protocol definition is also expected to allow passing extra options that are relevant to application environment and/or behaviour (such as modifying the default storage type). </li>
<li>defines <b>ValueType</b> inner value storage type and provides <b>value()</b> member functions to access the stored value. </li>
<li>provides <b>read()</b> and <b>write()</b> member functions to read and write the inner value given the iterator used for reading / writing and available length of the buffer. </li>
<li>has <b>length()</b> member function to report how many bytes are required to serialise currently stored value. </li>
<li>provides <b>valid()</b> member function to check whether the stored value is valid (within expected range of values). </li>
<li>has <b>refresh()</b> member function to bring its contents to consistent / valid state when required.</li>
</ul>
<p>Also note that all the member function are <b>NON-virtual</b>, i.e. the field abstractions do not have polymorphic behaviour.</p>
<p>The most important member function to a client application is <b>value()</b>. It allows access to the stored value. Note, that the stored value is accessed by reference. It allows both get and set operations: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> myFieldValue = myField.value();</div>
<div class="line">myField.value() = 5U;</div>
</div><!-- fragment --><p> Other member functions are of lesser importance to the client application, they are used by the protocol definition itself to properly (de)serialise message contents and provide other useful functionality.</p>
<p>The available fields abstractions are: </p><ul>
<li><a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_int_value">Integral Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_enum_value">Enum Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_bitmask_value">Bitmask Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_bitfield">Bitfield Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_bundle">Bundle Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_array_list">Array List Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_string">String Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1FloatValue.html">comms::field::FloatValue</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_fp_value">Floating Point Value Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_optional">Optional Fields</a> </li>
<li><a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> - used to define <a class="el" href="page_use_prot.html#page_use_prot_fields_variant">Variant Fields</a></li>
</ul>
<h2><a class="anchor" id="page_use_prot_fields_int_value"></a>
Integral Value Fields</h2>
<p>Integral value fields are defined using <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> class. Its inner <b>ValueType</b> type is the same as second template parameter. Most integral value fields are defined and used "as-is" </p><div class="fragment"><div class="line"><span class="comment">// base class for all the fields, usually defined by the protocol definition library</span></div>
<div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a></div>
<div class="line"> </div>
<div class="line"><span class="comment">// definition of integral field</span></div>
<div class="line"><span class="keyword">using</span> MyIntField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, <span class="comment">// base class for all the fields, defined by the protocol definition library</span></div>
<div class="line">        std::uint16_t</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// usage of the field</span></div>
<div class="line">MyIntField field;</div>
<div class="line">field.value() = 5; <span class="comment">// serialised as &quot;00 05&quot;</span></div>
</div><!-- fragment --><p> Some field's definitions may use <a class="el" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a> option, which adds predefined offset to the field before serialising and subtracts it before deserialising. Classic example would be having a "year" information, but serialised as offset from year <b>2000</b> with a single byte. Such field may be defined as following: </p><div class="fragment"><div class="line"><span class="keyword">using</span> YearField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::int16_t, </div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength&lt;1&gt;</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a>&lt;-2000&gt;</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FixedLength_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a></div><div class="ttdoc">Option used to specify number of bytes that is used for field serialisation.</div><div class="ttdef"><b>Definition:</b> options.h:280</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1NumValueSerOffset_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1NumValueSerOffset.html">comms::option::def::NumValueSerOffset</a></div><div class="ttdoc">Option to specify numeric value serialisation offset.</div><div class="ttdef"><b>Definition:</b> options.h:378</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that while serialisation takes only 1 byte, the client application will use full year number without worrying about added / removed offset </p><div class="fragment"><div class="line">YearField field;</div>
<div class="line">field.value() = 2018; <span class="comment">// serialised as 0x12;</span></div>
</div><!-- fragment --><p> Some protocols may exchange floating point values by serialising them as integral ones. For example, multiply the floating point value by 1000 before the serialisation, and upon reception divide the received value by 1000 to get the floating point one. Such fields will be defined using <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> type with using <a class="el" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio</a> option </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFpField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, <span class="comment">// base class for all the fields, defined by the protocol definition library</span></div>
<div class="line">        std::int32_t,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio&lt;1, 1000&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ScalingRatio_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio</a></div><div class="ttdoc">Option to specify scaling ratio.</div><div class="ttdef"><b>Definition:</b> options.h:410</div></div>
</div><!-- fragment --><p> The inner value of such field is integral one. However, there are <a class="el" href="classcomms_1_1field_1_1IntValue.html#aab70162b392a06982b66c9417a7f8ea7">comms::field::IntValue::getScaled()</a> and <a class="el" href="classcomms_1_1field_1_1IntValue.html#a1df02ae1e08b356662b2364a9e5d8e27">comms::field::IntValue::setScaled()</a> member functions that allow get and set original floating point value without worrying what math operation needs to be performed. </p><div class="fragment"><div class="line">MyFpField field;</div>
<div class="line">field.setScaled(1.3f);</div>
<div class="line">assert(field.value() == 1300); </div>
<div class="line"><span class="keyword">auto</span> asDouble = field.getScaled&lt;<span class="keywordtype">double</span>&gt;(); <span class="comment">// equivalent to 1.3</span></div>
</div><!-- fragment --><p> In addition to <b>scaling</b>, the <b>COMMS</b> library also provides an ability to specify <b>units</b>. For example, some protocol may define distance in <b>1/10</b> of the <b>millimetres</b>. The definition of such field may look like this </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyDistance = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::int32_t,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ScalingRatio.html">comms::option::def::ScalingRatio&lt;1, 10&gt;</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1Units.html">comms::option::def::UnitsMillimeters</a>         </div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1Units_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1Units.html">comms::option::def::Units</a></div><div class="ttdoc">Options to specify units of the field.</div><div class="ttdef"><b>Definition:</b> options.h:693</div></div>
</div><!-- fragment --><p> The <b>COMMS</b> library provides a <b>limited</b> set of units conversion functions in <a class="el" href="namespacecomms_1_1units.html">comms::units</a> namespace. When using the provided conversion function the application developer doesn't need to remember the original units and/or scaling factor. The <b>COMMS</b> library does all the math. It also prevents (at compile time) usage of wrong conversion functions, say calculating time (<b>milliseconds</b>), when specified units are <b>distance</b> (<b>millimetres</b>). </p><div class="fragment"><div class="line">MyDistance field; </div>
<div class="line"><a class="code" href="namespacecomms_1_1units.html#ac8b38043f97e0556190d90320b19bfa6">comms::units::setMeters</a>(field, 1.2345);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in 1/10 of mm:&quot;</span> &lt;&lt; field.value() &lt;&lt; std::endl; <span class="comment">// prints 12345</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in mm&quot;</span> &lt;&lt; comms::units::getMillimeters&lt;double&gt;(field); <span class="comment">// prints 1234.5</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Distance in cm&quot;</span> &lt;&lt; comms::units::getCentimeters&lt;double&gt;(field); <span class="comment">// prints 123.45</span></div>
<div class="ttc" id="anamespacecomms_1_1units_html_ac8b38043f97e0556190d90320b19bfa6"><div class="ttname"><a href="namespacecomms_1_1units.html#ac8b38043f97e0556190d90320b19bfa6">comms::units::setMeters</a></div><div class="ttdeci">void setMeters(TField &amp;field, TVal &amp;&amp;val)</div><div class="ttdoc">Update field's value accordingly, while providing meters value.</div><div class="ttdef"><b>Definition:</b> units.h:1178</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that <b>COMMS</b> library is about the communication protocols and not about unit conversions. The unit conversion functionality is quite basic and limited. If there is a need to use third party unit conversion library, it could be wise to <b>static_assert</b> on assumption for origin units. </p><div class="fragment"><div class="line">static_assert(comms::units::isMillimeters&lt;MyDistance&gt;(), <span class="stringliteral">&quot;Invalid units assumption&quot;</span>);</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line">static_assert(<a class="code" href="namespacecomms_1_1units.html#a1cdaab055b04b7c1beb9827f0ce73ac9">comms::units::isMillimeters</a>(field), <span class="stringliteral">&quot;Invalid units assumption&quot;</span>);</div>
<div class="ttc" id="anamespacecomms_1_1units_html_a1cdaab055b04b7c1beb9827f0ce73ac9"><div class="ttname"><a href="namespacecomms_1_1units.html#a1cdaab055b04b7c1beb9827f0ce73ac9">comms::units::isMillimeters</a></div><div class="ttdeci">constexpr bool isMillimeters()</div><div class="ttdoc">Compile time check whether the field type holds millimeters.</div><div class="ttdef"><b>Definition:</b> units.h:1080</div></div>
</div><!-- fragment --><p>By default, When <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> field is constructed, the inner value is constructed to be 0. However, the field definition may use <a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605">comms::option::def::DefaultNumValue</a> option to specify some other value </p><div class="fragment"><div class="line"><span class="comment">// definition of integral field</span></div>
<div class="line"><span class="keyword">using</span> MyIntField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, <span class="comment">// base class for all the fields, defined by the protocol definition library</span></div>
<div class="line">        std::uint16_t,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;25&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">MyIntField field;</div>
<div class="line">assert(field.value() == 25);</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1DefaultValueInitialiser_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultValueInitialiser</a></div><div class="ttdoc">Option that specifies default initialisation class.</div><div class="ttdef"><b>Definition:</b> options.h:616</div></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_enum_value"></a>
Enum Value Fields</h2>
<p>The <b>enum</b> values are defined using <a class="el" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a> class. It is very similar to <a class="el" href="page_use_prot.html#page_use_prot_fields_int_value">Integral Value Fields</a>. The main difference, that second template parameter as well as inner <b>ValueType</b> type is <b>enum</b>. The <b>enum</b> can be scoped (enum class) or regular (just enum). </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> SomeEnumVal : std::uint8_t</div>
<div class="line">{</div>
<div class="line">    Val1,</div>
<div class="line">    Val2,</div>
<div class="line">    Val3,</div>
<div class="line">    NumOfValues</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> SomeEnumField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        SomeEnumVal,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a>&lt;0, (int)SomeEnumVal::NumOfValues - 1&gt;,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue</a>&lt;(<span class="keywordtype">int</span>)SomeEnumVal::Val3&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">SomeEnumField field;</div>
<div class="line">assert(field.value() == SomeEnumVal::Val3); <span class="comment">// initialised by default to Val3;</span></div>
<div class="line">field.value() = SomeEnumVal::Val2;</div>
<div class="ttc" id="aclasscomms_1_1field_1_1EnumValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a></div><div class="ttdoc">Enumerator value field.</div><div class="ttdef"><b>Definition:</b> EnumValue.h:74</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ValidNumValueRange_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a></div><div class="ttdoc">Provide range of valid numeric values.</div><div class="ttdef"><b>Definition:</b> options.h:956</div></div>
</div><!-- fragment --><p> Note, that underlying type of the enum dictates default serialisation length.</p>
<h2><a class="anchor" id="page_use_prot_fields_bitmask_value"></a>
Bitmask Value Fields</h2>
<p>Bitmasks (or bitsets) are also numeric values where every bit has separate, independent meaning. Such fields are defined using <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a> class. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div>
<div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; <span class="comment">// Second bit is reserved and must be 0</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a></div><div class="ttdoc">Bitmask value field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:103</div></div>
</div><!-- fragment --><p> The field definition will use <a class="el" href="structcomms_1_1option_1_1def_1_1FixedLength.html">comms::option::def::FixedLength</a> option in order to specify its serialisation length. The inner <b>ValueType</b> type will be calculated automatically and defined as one of the unsigned types: <b>std::uint8_t</b>, <b>std::uint16_t</b>, <b>std::uint32_t</b>, or <b>std::uint64_t</b>. The usage of <a class="el" href="namespacecomms_1_1option_1_1def.html#ab250f5104df4cfe83741d63e6db70505">comms::option::def::BitmaskReservedBits</a> option will mark certain bits as "reserved". It influences only validity check functionality (see <a class="el" href="classcomms_1_1Field.html#abbc7d5f9c7a7167869590974d46edf5d">comms::field::BitmaskValue::valid()</a>). If any of the reserved bits doesn't have an expected value, the call to <b>valid()</b> member function will return <b>false</b>.</p>
<p>The bitmask field definition is also expected to use <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS()</a> macros to provide names for the bits and generate convenience access function. If bit names are sequential, i.e. start from bit <b>0</b>, and go up without any holes in the middle, then single <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#abe8a230b0b02d5e2bfc3a3c5a42e4f62">COMMS_BITMASK_BITS_SEQ()</a> macro can be used instead achieving the same effect. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div>
<div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; <span class="comment">// Second bit is reserved and must be 0</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">COMMS_BITMASK_BITS</a>(first, third=2, fourth, fifth, sixth, seventh, eighth);</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">COMMS_BITMASK_BITS_ACCESS</a>(first, third, fourth, fifth, sixth, seventh, eighth);</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a0649d4ce913efb2b067ed2f33fdbce8b"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a0649d4ce913efb2b067ed2f33fdbce8b">comms::field::BitmaskValue::COMMS_BITMASK_BITS_ACCESS</a></div><div class="ttdeci">#define COMMS_BITMASK_BITS_ACCESS(...)</div><div class="ttdoc">Generate access functions for bits in comms::field::BitmaskValue field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:651</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_ad73b3130afa08a1155ac8b7e7ad915ee"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#ad73b3130afa08a1155ac8b7e7ad915ee">comms::field::BitmaskValue::COMMS_BITMASK_BITS</a></div><div class="ttdeci">#define COMMS_BITMASK_BITS(...)</div><div class="ttdoc">Provide names for bits in comms::field::BitmaskValue field.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:557</div></div>
</div><!-- fragment --><p> is equivalent to defining: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBitmask : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html">comms::field::BitmaskValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        comms::option::def::FixedLength&lt;1&gt;,</div>
<div class="line">        comms::option::def::BitmaskReservedBits&lt;0x2, 0&gt; </div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> BitIdx </div>
<div class="line">    {</div>
<div class="line">        BitIdx_first,</div>
<div class="line">        BitIdx_third=2,</div>
<div class="line">        BitIdx_fourth,</div>
<div class="line">        BitIdx_fifth,</div>
<div class="line">        BitIdx_sixth,</div>
<div class="line">        BitIdx_seventh,</div>
<div class="line">        BitIdx_eighth,</div>
<div class="line">        BitIdx_numOfValues</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_first()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">getBitValue</a>(BitIdx_first); }</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_first(<span class="keywordtype">bool</span> val) { <a class="code" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">setBitValue</a>(BitIdx_first, val); }</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_third()<span class="keyword"> const </span>{ ... }</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_third(<span class="keywordtype">bool</span> val) { ... }</div>
<div class="line">    <span class="keywordtype">bool</span> getBitValue_fourth()<span class="keyword"> const </span>{ ... }</div>
<div class="line">    <span class="keywordtype">void</span> setBitValue_fourth(<span class="keywordtype">bool</span> val) { ... }</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a3ba03ea117a584dafb99e27e47ee8819"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">comms::field::BitmaskValue::getBitValue</a></div><div class="ttdeci">bool getBitValue(unsigned bitNum) const</div><div class="ttdoc">Get bit value.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:316</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1BitmaskValue_html_a7ae5a5fde24cc9498e34e087b8f571ea"><div class="ttname"><a href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">comms::field::BitmaskValue::setBitValue</a></div><div class="ttdeci">void setBitValue(unsigned bitNum, bool val)</div><div class="ttdoc">Set bit value.</div><div class="ttdef"><b>Definition:</b> BitmaskValue.h:323</div></div>
</div><!-- fragment --><p> The generated convenience access functions use existing <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a3ba03ea117a584dafb99e27e47ee8819">comms::field::BitmaskValue::getBitValue()</a> and <a class="el" href="classcomms_1_1field_1_1BitmaskValue.html#a7ae5a5fde24cc9498e34e087b8f571ea">comms::field::BitmaskValue::setBitValue()</a> member functions.</p>
<p>It is also possible to set multiple bits at the same time by accessing the stored value directly </p><div class="fragment"><div class="line">MyBitmask field;</div>
<div class="line">field.value() = 0x81; <span class="comment">// Setting first and eighth bits</span></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_bitfield"></a>
Bitfield Fields</h2>
<p>Many communication protocols try to pack multiple independent values into a one or several bytes to save traffic on I/O link. For example RS-232 serial port configuration may be defined as following:</p>
<p>3 Bits to configure baud rate: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Baud Rate   </th><th class="markdownTableHeadCenter">Serialisation Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">9600   </td><td class="markdownTableBodyCenter">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">14400   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">19200   </td><td class="markdownTableBodyCenter">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">28800   </td><td class="markdownTableBodyCenter">3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">38400   </td><td class="markdownTableBodyCenter">4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">57600   </td><td class="markdownTableBodyCenter">5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">115200   </td><td class="markdownTableBodyCenter">6   </td></tr>
</table>
<p>2 Bits to configure parity: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Parity   </th><th class="markdownTableHeadCenter">Serialisation Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">None   </td><td class="markdownTableBodyCenter">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Odd   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Even   </td><td class="markdownTableBodyCenter">2   </td></tr>
</table>
<p>2 Bits to configure stopBits: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Stop Bits   </th><th class="markdownTableHeadCenter">Serialisation Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">One   </td><td class="markdownTableBodyCenter">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">One and half   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Two   </td><td class="markdownTableBodyCenter">2   </td></tr>
</table>
<p>2 Bits to configure flow control: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Flow Control   </th><th class="markdownTableHeadCenter">Serialisation Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">None   </td><td class="markdownTableBodyCenter">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Hardware   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Software   </td><td class="markdownTableBodyCenter">2   </td></tr>
</table>
<p>The field definition will use <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> and probably look similar to code below </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> Baud {...}</div>
<div class="line"><span class="keyword">enum class</span> Parity {...}</div>
<div class="line"><span class="keyword">enum class</span> StopBits {...}</div>
<div class="line"><span class="keyword">enum class</span> FlowControl {...}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SerialConfigField : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, Baud, comms::option::def::FixedBitLength&lt;3&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, Parity, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, StopBits, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, FlowControl, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint8_t, comms::option::def::FixedBitLength&lt;7&gt; &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(baud, parity, stopBits, flowControl, reserved);</div>
<div class="line">}</div>
<div class="ttc" id="aField_8h_html_af74198f06b52d3f58c92e795b2ff7129"><div class="ttname"><a href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a></div><div class="ttdeci">#define COMMS_FIELD_MEMBERS_NAMES(...)</div><div class="ttdoc">Provide names for member fields of composite fields, such as comms::field::Bundle or comms::field::Bi...</div><div class="ttdef"><b>Definition:</b> Field.h:372</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bitfield_html"><div class="ttname"><a href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a></div><div class="ttdoc">Bitfield field.</div><div class="ttdef"><b>Definition:</b> Bitfield.h:93</div></div>
</div><!-- fragment --><p> All the member fields of the <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> are stored internally as <b>std::tuple</b>, as the result the inner <b>ValueType</b> of such field is <b>std::tuple</b> of all member fields and call to <a class="el" href="classcomms_1_1field_1_1Bitfield.html#a860dec7b3bdc52722f91037d6adacc03">comms::field::Bitfield::value()</a> member function will give an access to it.</p>
<p>The field definition is expected to use <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> macro, which will generate <b>FieldIdx</b> enum as well as convenience access member functions. The code becomes equivalent to: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>SerialConfigField : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, Baud, comms::option::def::FixedBitLength&lt;3&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, Parity, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, StopBits, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, FlowControl, comms::option::def::FixedBitLength&lt;2&gt; &gt;,</div>
<div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint8_t, comms::option::def::FixedBitLength&lt;7&gt; &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Access indices for member fields</span></div>
<div class="line">    <span class="keyword">enum</span> FieldIdx {</div>
<div class="line">        FieldIdx_baud,</div>
<div class="line">        FieldIdx_parity,</div>
<div class="line">        FieldIdx_stopBits,</div>
<div class="line">        FieldIdx_flowControl,</div>
<div class="line">        FieldIdx_reserved,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;baud&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_baud() -&gt; decltype(std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to const &quot;baud&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_baud() const -&gt; decltype(std::get&lt;FieldIdx_baud&gt;(value()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_baud&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;parity&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_parity() -&gt; decltype(std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to const &quot;parity&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_parity() const -&gt; decltype(std::get&lt;FieldIdx_parity&gt;(value()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_parity&gt;(<a class="code" href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ... <span class="comment">// and so on for all other member fields</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bitfield_html_a80cf3ed42ed61895a62e98a6ebfe4e3c"><div class="ttname"><a href="classcomms_1_1field_1_1Bitfield.html#a80cf3ed42ed61895a62e98a6ebfe4e3c">comms::field::Bitfield::value</a></div><div class="ttdeci">const ValueType &amp; value() const</div><div class="ttdoc">Get access to the stored tuple of fields.</div><div class="ttdef"><b>Definition:</b> Bitfield.h:148</div></div>
</div><!-- fragment --><p> Accessing the member field value in such setup, such as "baud" may look like this: </p><div class="fragment"><div class="line">SerialConfigField configField;</div>
<div class="line">configField.field_baud().value() = Baud::Val_115200;</div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_bundle"></a>
Bundle Fields</h2>
<p>There are cases when multiple independent fields need to be bundled into a single field and expose the required interface of reading, writing, calculating length, checking field's contents validity, and bringing field's value into a consistent state. It may be required when a message contains sequence (see <a class="el" href="page_use_prot.html#page_use_prot_fields_array_list">Array List Fields</a>) of such bundles/structs. The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a> field for this purpose. It is quite similar to <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> described earlier. The difference is that every member field doesn't specify any length in bits, just bytes. For example: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> SomeEnum : std::uint8_t</div>
<div class="line">{</div>
<div class="line">    SomeEnum_Value1,</div>
<div class="line">    SomeEnum_Value2,</div>
<div class="line">    SomeEnum_Value3,</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyBundle : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            comms::field::IntValue&lt;MyFieldBase, std::int16_t&gt; <span class="comment">// 2 bytes int value</span></div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, SomeEnum&gt;, <span class="comment">// 1 byte enum value</span></div>
<div class="line">            comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt; <span class="comment">// 1 byte bitmask</span></div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(member1, member2, member3);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bundle_html"><div class="ttname"><a href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a></div><div class="ttdoc">Bundles multiple fields into a single field.</div><div class="ttdef"><b>Definition:</b> Bundle.h:61</div></div>
</div><!-- fragment --><p> Just like with <a class="el" href="page_use_prot.html#page_use_prot_fields_bitfield">Bitfield Fields</a>, the inner <b>ValueType</b> type of such field is a <b>std::tuple</b> of member fields, and usage of <a class="el" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES()</a> has exactly the same effect, i.e. generates inner <b>FieldIdx</b> enum and convenience access member functions: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyBundle : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            comms::field::IntValue&lt;MyFieldBase, std::int16_t&gt; <span class="comment">// 2 bytes int value</span></div>
<div class="line">            comms::field::EnumValue&lt;MyFieldBase, SomeEnum&gt;, <span class="comment">// 1 byte enum value</span></div>
<div class="line">            comms::field::BitmaskValue&lt;MyFieldBase, comms::option::def::FixedLength&lt;1&gt; &gt; <span class="comment">// 1 byte bitmask</span></div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">enum</span> FieldIdx</div>
<div class="line">    {</div>
<div class="line">        FieldIdx_member1,</div>
<div class="line">        FieldIdx_member2,</div>
<div class="line">        FieldIdx_member3,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;member1&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_member1() -&gt; decltype(std::get&lt;FieldIdx_member1&gt;(<a class="code" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_member1&gt;(<a class="code" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to const &quot;member1&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_member1() const -&gt; decltype(std::get&lt;FieldIdx_member1&gt;(value()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_member1&gt;(<a class="code" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessor to &quot;member2&quot; field</span></div>
<div class="line">    <span class="keyword">auto</span> field_member2() -&gt; decltype(std::get&lt;FieldIdx_member2&gt;(<a class="code" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;FieldIdx_member2&gt;(<a class="code" href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">value</a>());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1field_1_1Bundle_html_abca6bbe6991d32eda3f539d58876aa2b"><div class="ttname"><a href="classcomms_1_1field_1_1Bundle.html#abca6bbe6991d32eda3f539d58876aa2b">comms::field::Bundle::value</a></div><div class="ttdeci">ValueType &amp; value()</div><div class="ttdoc">Get access to the stored tuple of fields.</div><div class="ttdef"><b>Definition:</b> Bundle.h:108</div></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_array_list"></a>
Array List Fields</h2>
<p>Some communication protocols may define messages that transmit sequence of similar fields and/or raw data buffers. To make it easier to handle, the <b>COMMS</b> library provides <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a> field which provide a required interface to properly handle such sequences of data. It supports a sequence of raw bytes </p><div class="fragment"><div class="line"><span class="keyword">using</span> MySimpleList = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::uint8_t <span class="comment">// raw byte type as second template parameter</span></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1field_1_1ArrayList_html"><div class="ttname"><a href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a></div><div class="ttdoc">Field that represents a sequential collection of fields.</div><div class="ttdef"><b>Definition:</b> ArrayList.h:193</div></div>
</div><!-- fragment --><p> as well as using sequence of any fields defined in <a class="el" href="namespacecomms_1_1field.html" title="Namespace that contains definitions of all message fields.">comms::field</a> namespace </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyComplexList = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        MyBundle <span class="comment">// Complex bundle field, defined in previous section </span></div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> The <b>default</b> storage type (inner <b>ValueType</b> type) of these fields is <b>std::vector</b> of specified type, i.e. it is <b>std::vector&lt;std::uint8_t&gt;</b> in case of <b>MySimpleList</b> and <b>std::vector&lt;MyBundle&gt;</b> in case of <b>MyComplexList</b>. Such default storage type may be unsuitable to certain applications, especially for bare-metal ones. The <b>COMMS</b> library allows changing it using extra options. The protocol definition is expected to provide a way to pass extra options to such fields. It is explained in <a class="el" href="page_use_prot.html#page_use_prot_fields_customisation">Application Specific Customisation of Fields</a> section below in more details.</p>
<p>Please pay attention, that in case of non-raw data lists, the inner <b>std::vector</b> contains fields, not values. As the result access to the stored values may require a bit of extra function calls: </p><div class="fragment"><div class="line">MyComplexList list;</div>
<div class="line"><span class="keyword">auto</span>&amp; storageVec = list.value(); <span class="comment">// access to std::vector&lt;MyBundle&gt;</span></div>
<div class="line">storageVec.resize(1);</div>
<div class="line"><span class="keyword">auto</span>&amp; firstBundle = storageVec[0]; <span class="comment">// access to first MyBundle element</span></div>
<div class="line"><span class="keyword">auto</span>&amp; firstMember1 = firstBundle.field_member1(); <span class="comment">// access to &quot;member1&quot; member of first bundle</span></div>
<div class="line">firstMember1.value() = ...; <span class="comment">// assign the value of &quot;member1&quot;</span></div>
</div><!-- fragment --><p> Some protocols may define fixed size lists. In such case lists are defined with usage of <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyList = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;4&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1SequenceFixedSize_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a></div><div class="ttdoc">Option used to define exact number of elements in the collection field.</div><div class="ttdef"><b>Definition:</b> options.h:579</div></div>
</div><!-- fragment --><p> Usage of this option just ensures right amount of elements "on the wire" after the field is serialised, but it does <b>NOT</b> automatically resize inner storage vector. </p><div class="fragment"><div class="line">MyList field;</div>
<div class="line">assert(field.value().empty()); <span class="comment">// vector is empty upon construction</span></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_string"></a>
String Fields</h2>
<p>Many protocols have to transfer strings. They are defined using <a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a> field. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyString = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String&lt;MyFieldBase&gt;</a>;</div>
<div class="ttc" id="aclasscomms_1_1field_1_1String_html"><div class="ttname"><a href="classcomms_1_1field_1_1String.html">comms::field::String</a></div><div class="ttdoc">Field that represents a string.</div><div class="ttdef"><b>Definition:</b> String.h:160</div></div>
</div><!-- fragment --><p> It is very similar to <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a> it terms of value storage, read/write operations, and supported options. By default the value is stored as <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a>. </p><div class="fragment"><div class="line">MyString myStr;</div>
<div class="line"><span class="keyword">auto</span>&amp; myStrStorage = myStr.value(); <span class="comment">// Reference to std::string.</span></div>
</div><!-- fragment --><p> However, there are options that can modify this default behaviour. The protocol definition classes are expected to provide a way to pass extra application specific options to the string field definition. It is explained in more details in <a class="el" href="page_use_prot.html#page_use_prot_fields_customisation">Application Specific Customisation of Fields</a> section below.</p>
<p>Also similar to <a class="el" href="page_use_prot.html#page_use_prot_fields_array_list">Array List Fields</a>, fixed length strings are defined using <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option, and just like with lists it does <b>NOT</b> automatically resize inner string, just ensures right amount of characters "on the wire" when field is serialised. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyFixedString = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize&lt;32&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">MyFixedString field;</div>
<div class="line">assert(field.value().empty());</div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_fp_value"></a>
Floating Point Value Fields</h2>
<p>Floating point value fields are defined using <a class="el" href="classcomms_1_1field_1_1FloatValue.html">comms::field::FloatValue</a> They are very similar to <a class="el" href="page_use_prot.html#page_use_prot_fields_int_value">Integral Value Fields</a>, but use <b>float</b> or <b>double</b> as its internal storage type. They abstract the IEEE 754 floating point values, which are serialised "as is" with either big or little endian encoding. The floating point value fields also support the same scaling and units conversion just like <a class="el" href="page_use_prot.html#page_use_prot_fields_int_value">Integral Value Fields</a>.</p>
<h2><a class="anchor" id="page_use_prot_fields_optional"></a>
Optional Fields</h2>
<p>Some protocols may define optional fields, which may exist or be missing based on information recorded in other fields. For example there is a "flags" bitmask field which specifies whether the following field exists or missing. The optional field may also be tentative, i.e. if there is enough data in the input buffer it exists, and missing otherwise. The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a> which is a mere wrapper around other fields and provides an ability to set the optional state of the field. </p><div class="fragment"><div class="line"><span class="keyword">using</span> OptField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::int32_t&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1field_1_1Optional_html"><div class="ttname"><a href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a></div><div class="ttdoc">Adaptor class to any other field, that makes the field optional.</div><div class="ttdef"><b>Definition:</b> Optional.h:46</div></div>
</div><!-- fragment --><p> The default mode of such field is "tentative", which means read if there is data available in the input buffer, and write if there is enough space in the output buffer. </p><div class="fragment"><div class="line">OptField field;</div>
<div class="line">assert(field.isTentative());</div>
</div><!-- fragment --><p> The default mode can be changed using <a class="el" href="namespacecomms_1_1option_1_1def.html#adcd3a25551f74636157bfff761d4e39f">comms::option::def::ExistsByDefault</a> or <a class="el" href="namespacecomms_1_1option_1_1def.html#a6ec725d747184d01b7afe266f53740de">comms::option::def::MissingByDefault</a> options. For example </p><div class="fragment"><div class="line"><span class="keyword">using</span> ExistingOptField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Optional.html">comms::field::Optional</a>&lt;</div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::int32_t&gt;</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::ExistsByDefault</a></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line">ExistingOptField field;</div>
<div class="line">assert(field.doesExist()); </div>
</div><!-- fragment --><p> <b>NOTE</b>, that inner <b>ValueType</b> of such field is wrapped actual field and both <a class="el" href="classcomms_1_1field_1_1Optional.html#a3707ec3c53ddfaadacd99c448ad12f27">comms::field::Optional::value()</a> and <a class="el" href="classcomms_1_1field_1_1Optional.html#a7acbbdcc3ba130ceccc032be59cca0de">comms::field::Optional::field()</a> member functions allow to access it. For example: </p><div class="fragment"><div class="line">OptField field;</div>
<div class="line"><span class="keyword">auto</span>&amp; innerField = field.field(); <span class="comment">// or call field.value()</span></div>
<div class="line">innerField.value() = 1234;</div>
<div class="line">field.setExists();</div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_variant"></a>
Variant Fields</h2>
<p>Some protocols may require usage of heterogeneous fields or lists of heterogeneous fields, i.e. the ones that can be of multiple types. Good example would be a list of <b>properties</b>, where every property is a key/value pair or a type/length/value triplet. The key (or type) is usually a numeric ID of the property, while value can be any field of any length. Such fields are defined using <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> class. It is very similar to <a class="el" href="page_use_prot.html#page_use_prot_fields_bundle">Bundle Fields</a>, but serves as one big union of provided member fields, i.e. only one can be used at a time.</p>
<p>As an example for the key/value pairs let's assume usage of three value types: </p><ul>
<li>Unsigned integer with length of only 1 byte (<b>Value1</b>) </li>
<li>Unsigned integer with length of 4 bytes (<b>Value2</b>) </li>
<li>String field with 1 byte size prefix (<b>Value3</b>)</li>
</ul>
<p>The <b>COMMS</b> library provides <a class="el" href="classcomms_1_1field_1_1Variant.html" title="Defines a &quot;variant&quot; field, that can contain any of the provided ones.">comms::field::Variant</a> field to allow such heterogeneous fields and the protocol definition may look something like this: </p><div class="fragment"><div class="line"><span class="comment">// Definition of value fields</span></div>
<div class="line"><span class="keyword">using</span> MyFieldBase = <a class="code" href="classcomms_1_1Field.html">comms::Field&lt;comms::option::def::BigEndian&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> Value1 = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint8_t&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> Value2 = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;MyFieldBase, std::uint32_t&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> Value3 = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a>&lt;</div>
<div class="line">            <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">                MyFieldBase,</div>
<div class="line">                std::uint8_t</div>
<div class="line">            &gt;</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//The common key type is usually represented as enum.</span></div>
<div class="line"><span class="keyword">enum class</span> KeyId : std::uint8_t</div>
<div class="line">{</div>
<div class="line">    Key1,</div>
<div class="line">    Key2,</div>
<div class="line">    Key3,</div>
<div class="line">    NumOfValues</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of &quot;key&quot; fields</span></div>
<div class="line"><span class="keyword">template</span> &lt;KeyId TId&gt;</div>
<div class="line"><span class="keyword">using</span> KeyField =</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1EnumValue.html">comms::field::EnumValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        KeyId,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue</a>&lt;(int)TId&gt;,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange</a>&lt;(<span class="keywordtype">int</span>)TId, (int)TId&gt;,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid&lt;&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> Key1 = KeyField&lt;KeyId::Key1&gt;;</div>
<div class="line"><span class="keyword">using</span> Key2 = KeyField&lt;KeyId::Key2&gt;;</div>
<div class="line"><span class="keyword">using</span> Key3 = KeyField&lt;KeyId::Key3&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of properties bundles</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">class </span>Property : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            TKey,</div>
<div class="line">            TValue</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, val);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> Property1 = Property&lt;Key1, Value1&gt;;</div>
<div class="line"><span class="keyword">using</span> Property2 = Property&lt;Key2, Value2&gt;;</div>
<div class="line"><span class="keyword">using</span> Property3 = Property&lt;Key3, Value3&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of the variant field</span></div>
<div class="line"><span class="keyword">class </span>MyVariant : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;Property1, Property2, Property3&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type.</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES</a>(prop1, prop2, prop3);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Definition of properties list</span></div>
<div class="line"><span class="keyword">using</span> PropertiesList = <a class="code" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList&lt;MyFieldBase, MyVariant&gt;</a>;</div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a></div><div class="ttdoc">Defines a &quot;variant&quot; field, that can contain any of the provided ones.</div><div class="ttdef"><b>Definition:</b> Variant.h:70</div></div>
<div class="ttc" id="aclasscomms_1_1field_1_1Variant_html_a7b12d7388ea81343e0c77a92264c8931"><div class="ttname"><a href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">comms::field::Variant::COMMS_VARIANT_MEMBERS_NAMES</a></div><div class="ttdeci">#define COMMS_VARIANT_MEMBERS_NAMES(...)</div><div class="ttdoc">Provide names for member fields of comms::field::Variant field.</div><div class="ttdef"><b>Definition:</b> Variant.h:843</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1FailOnInvalid_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a></div><div class="ttdoc">Option that forces field's read operation to fail if invalid value is received.</div><div class="ttdef"><b>Definition:</b> options.h:674</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1SequenceSizeFieldPrefix.html">comms::option::def::SequenceSizeFieldPrefix</a></div><div class="ttdoc">Option that modifies the default behaviour of collection fields to prepend the serialised data with n...</div><div class="ttdef"><b>Definition:</b> options.h:438</div></div>
</div><!-- fragment --><p> <b>IMPORTANT:</b> The <a class="el" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a> field uses uninitialized implementation dependent storage area able to be initialized and hold any of the provided member field types (but only one at a time). The inner <a class="el" href="classcomms_1_1field_1_1Variant.html#adc09c38e7f2d71ac5d5e98d9780a58c7">ValueType</a> type contains definition of the used storage type and <a class="el" href="classcomms_1_1field_1_1Variant.html#afadb93367e987db10b4add65990b3f19">value()</a> member function which returns reference to the used storage area. These type and function should <b>NOT</b> be used directly. Instead, the protocol definition is expected to use <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> macro, which generates appropriate access and conversion wrapper functions around <a class="el" href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">comms::field::Variant::initField()</a> and <a class="el" href="classcomms_1_1field_1_1Variant.html#a41f2ddd1d5b3bfc3647e82912fe97f47">comms::field::Variant::accessField()</a>.</p>
<p>The usage of <a class="el" href="classcomms_1_1field_1_1Variant.html#a7b12d7388ea81343e0c77a92264c8931">COMMS_VARIANT_MEMBERS_NAMES()</a> in the above is equivalent to having the following member types and functions defined </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariant : <span class="keyword">public</span> <a class="code" href="classcomms_1_1field_1_1Variant.html">comms::field::Variant</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Enumerator to access fields </span></div>
<div class="line">    <span class="keyword">enum</span> FieldIdx {</div>
<div class="line">        FieldIdx_prop1,</div>
<div class="line">        FieldIdx_prop2,</div>
<div class="line">        FieldIdx_prop3,</div>
<div class="line">        FieldIdx_numOfValues</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize internal storage as &quot;prop1&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    <span class="keyword">auto</span> initField_prop1(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop1&gt;(std::forward&lt;TArgs&gt;(args)...))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop1&gt;(std::forward&lt;TArgs&gt;(args)...)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop1&quot;</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop1() -&gt; decltype(accessField&lt;FieldIdx_prop1&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop1&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop1&quot; (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop1() const -&gt; decltype(accessField&lt;FieldIdx_prop1&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop1&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize internal storage as &quot;prop2&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    <span class="keyword">auto</span> initField_prop2(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop2&gt;(std::forward&lt;TArgs&gt;(args)...))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop2&gt;(std::forward&lt;TArgs&gt;(args)...)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop2&quot;</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop2() -&gt; decltype(accessField&lt;FieldIdx_prop2&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop2&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop2&quot; (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop2() const -&gt; decltype(accessField&lt;FieldIdx_prop2&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop2&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize internal storage as &quot;prop3&quot;</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TArgs&gt;</div>
<div class="line">    <span class="keyword">auto</span> initField_prop3(TArgs&amp;&amp;... args) -&gt; decltype(initField&lt;FieldIdx_prop3&gt;(std::forward&lt;TArgs&gt;(args)...))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> initField&lt;FieldIdx_prop3&gt;(std::forward&lt;TArgs&gt;(args)...)</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop3&quot;</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop3() -&gt; decltype(accessField&lt;FieldIdx_prop3&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop3&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access internal storage already initialized as &quot;prop3&quot; (const variant)</span></div>
<div class="line">    <span class="keyword">auto</span> accessField_prop3() const -&gt; decltype(accessField&lt;FieldIdx_prop3&gt;())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> accessField&lt;FieldIdx_prop3&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Types of used fields</span></div>
<div class="line">    <span class="keyword">using</span> Field_prop1 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">    <span class="keyword">using</span> Field_prop2 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">    <span class="keyword">using</span> Field_prop3 = ... <span class="comment">/* implementation dependent field type */</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> <b>NOTE</b>, that the provided names have propagated into definition of <b>FieldIdx</b> enum, all <b>initField_*</b> and <b>accessField_*</b> functions, as well as inner <b>Field_*</b> types.</p>
<p>When variant field object is instantiated, accessing the currently held field can be tricky though. There is a need to differentiate between <b>compile-time</b> and <b>run-time</b> knowledge of the contents.</p>
<p>When preparing a variant field (or message with variant fields) to be sent out, usually the inner field type and its value are known at compile time. The initialization of the field can be performed using one of the <b>initField_*</b>() member function described above: </p><div class="fragment"><div class="line">MyVariant var; <span class="comment">// Created in &quot;invalid&quot; state</span></div>
<div class="line"><span class="keyword">auto</span>&amp; prop1 = var.initField_prop1(); <span class="comment">// Initialise as Property1 (constructor of prop1 is called)</span></div>
<div class="line"><span class="keyword">auto</span>&amp; prop1ValField = prop1.field_val(); <span class="comment">// Access the &quot;value&quot; field of the bundle</span></div>
<div class="line">prop1ValField.value() = 0xff; <span class="comment">// Update the property value</span></div>
</div><!-- fragment --><p> or use <a class="el" href="classcomms_1_1field_1_1Variant.html#a6e4dd4d3fa0537593ba42374aaf542e0">comms::field::Variant::initField()</a> member function and generated <b>FieldIdx</b> enum as compile time access index: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; prop1 = var.initField&lt;MyVariant::FieldIdx_prop1&gt;();</div>
</div><!-- fragment --><p> It is possible to re-initialize the field as something else, the previous definition will be properly destructed. </p><div class="fragment"><div class="line">MyVariant var; <span class="comment">// Created in &quot;invalid&quot; state</span></div>
<div class="line"><span class="keyword">auto</span>&amp; prop1 = var.initField_prop1(); <span class="comment">// Initialize as Property1 (constructor of prop1 is called)</span></div>
<div class="line"><span class="keyword">auto</span>&amp; prop2 = var.initField_prop2(); <span class="comment">// Destruct Property1 and initialize as Property2</span></div>
</div><!-- fragment --><p> If the variant field has been initialized before, but there is a need to access the real type (also known at compile time), use appropriate <b>accessField_*</b>() member function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateProp1(MyVariant&amp; var)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span>&amp; prop1 = var.accessField_prop1(); <span class="comment">// Access as Property1 (simple cast, no call to the constructor)</span></div>
<div class="line">    <span class="keyword">auto</span>&amp; prop1ValField = prop1.field_val()); <span class="comment">// Access the &quot;value&quot; field of the bundle</span></div>
<div class="line">    prop1ValField.value() = 0xff; <span class="comment">// Update the property value</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> or use <a class="el" href="classcomms_1_1field_1_1Variant.html#a41f2ddd1d5b3bfc3647e82912fe97f47">comms::field::Variant::accessField()</a> member function and generated <b>FieldIdx</b> enum as compile time access index: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; prop1 = var.accessField&lt;MyVariant::FieldIdx_prop1&gt;();</div>
</div><!-- fragment --><p> There are cases (such as handling field after "read" operation), when actual type of the <b>Variant</b> field is known at run-time. The most straightforward way is to inquire the actual type index using <a class="el" href="classcomms_1_1field_1_1Variant.html#a20b3323d7a94321da9acadc097bc5f36" title="Get index of the current field (within the Members tuple).">comms::field::Variant::currentField()</a> function and then use a <code>switch</code> statement and handle every case accordingly. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handleMyVariant(<span class="keyword">const</span> MyVariant&amp; var)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(var.currentField())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> MyVariant::FieldIdx_prop1:</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span>&amp; prop1 = var.accessField_prop1(); <span class="comment">// cast to &quot;prop1&quot;</span></div>
<div class="line">            ... <span class="comment">// handle prop1;</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">case</span> MyVariant::FieldIdx_prop2:</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">auto</span>&amp; prop2 = var.accessField_prop2(); <span class="comment">// cast to &quot;prop2&quot;</span></div>
<div class="line">            ... <span class="comment">// handle prop2;</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        ...</div>
<div class="line">    };</div>
<div class="line">}</div>
</div><!-- fragment --><p> However, such approach may require a significant amount of boilerplate code with manual (error-prone) "casting" to appropriate field type. The <b>COMMS</b> library provides a built-in way to perform relatively efficient (O(log(n)) way of dispatching the actual field to its appropriate handling function by using <a class="el" href="classcomms_1_1field_1_1Variant.html#a6bdfe5b65c5b74b010eee7e1078c10f5" title="Execute provided function object with current field as parameter.">comms::field::Variant::currentFieldExec()</a> member function. It expects to receive a handling object which can handle all of the available inner types: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariantHandler</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Property1&amp; prop) {...}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Property2&amp; prop) {...}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Property3&amp; prop) {...}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handleVariant(MyVariant&amp; var)</div>
<div class="line">{</div>
<div class="line">    var.currentFieldExec(MyVariantHandler());</div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b>, that every <b>operator()</b> function receives a compile time index of the handed field within a containing tuple. If it's not needed when handling the member field, just ignore it or static_assert on its value if the index's value is known.</p>
<p>The class of the handling object may also receive the handled member type as a template parameter </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyVariantHandler</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> TIdx, <span class="keyword">typename</span> TField&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(TField&amp; prop) {...}</div>
<div class="line">}</div>
</div><!-- fragment --><p> The example above covers basic key/value pairs type of properties. Quite often protocols use TLV (type/length/value) triplets instead. Adding <b>length</b> information allows having multiple <b>value</b> fields to follow (some of them may be introduced in future versions of protocols) as well as receiving unknown (to earlier versions of the protocol) properties and skipping over them. The definition above may be slightly altered (see below) to support such properties: </p><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// No need for length prefix for string any more</span></div>
<div class="line">using Value3 = <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String&lt;MyFieldBase&gt;</a>;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Definition of properties bundles</span></div>
<div class="line">template &lt;<span class="keyword">typename</span> TKey, <span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">class </span>Property : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1Bundle.html">comms::field::Bundle</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            TKey,</div>
<div class="line">            comms::field::IntValue&lt;MyFieldBase, std::uint16_t&gt;, <span class="comment">// 2 byte value of remaining length</span></div>
<div class="line">            TValue</div>
<div class="line">        &gt;,</div>
<div class="line">        comms::option::def::RemLengthMemberField&lt;1&gt; <span class="comment">// Index of remaining length field is 1</span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base = ...; <span class="comment">// repeat base definition</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="Field_8h.html#af74198f06b52d3f58c92e795b2ff7129">COMMS_FIELD_MEMBERS_NAMES</a>(key, length, val);</div>
<div class="line">};</div>
<div class="line">...</div>
</div><!-- fragment --><p> The rest of the handling code presented above applies for this kind as well with one small nuance. The value of the <b>length</b> field depends on the value of <b>val</b> (especially with variable length fields like strings).</p>
<p>When such property field is default constructed, the <b>length</b> is updated to a correct value. </p><div class="fragment"><div class="line">MyVariant var;</div>
<div class="line"><span class="keyword">auto</span>&amp; prop1 = var.initField_prop1(); <span class="comment">// Initialize as Property1 (1 byte integral value)</span></div>
<div class="line">assert(prop1.field_length().value() == 1U);</div>
<div class="line"><span class="keyword">auto</span>&amp; prop3 = var.initField_prop3(); <span class="comment">// Re-initialize as Property3 (empty string)</span></div>
<div class="line">assert(prop3.field_length().value() == 0U); <span class="comment">// Remaining length of empty string</span></div>
</div><!-- fragment --><p> In case the <b>val</b> field of the <b>prop3</b> gets updated, the value of <b>length</b> field is not valid any more. There is a need to bring it into a consistent state by calling <b>refresh()</b> member function. </p><div class="fragment"><div class="line">prop3.field_val().value() = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">prop3.refresh();</div>
<div class="line">assert(prop3.field_length().value() == 5U);</div>
</div><!-- fragment --><p> Note, that there is no need to call <b>refresh()</b> after every update of a variant field. Usually such updates are done as preparation of the message to be sent. It is sufficient to call <b>doRefresh()</b> member function of the message object at the end of the update. </p><div class="fragment"><div class="line">SomeMessage msg;</div>
<div class="line"><span class="keyword">auto</span>&amp; propsList = msg.field_propsList(); <span class="comment">// access the properties list</span></div>
<div class="line"><span class="keyword">auto</span>&amp; propsListVector = propsList.value(); <span class="comment">// access the storage (vector);</span></div>
<div class="line">propsListVector.resize(10); <span class="comment">// create 10 properties (still invalid)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span>&amp; prop1VariantField = propsListVector[0].initField_prop1(); <span class="comment">// Initialize first as &quot;prop1&quot;</span></div>
<div class="line">prop1VariantField.field_val().value() = 0xf;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span>&amp; prop3VariantField = propsListVector[1].initField_prop3(); <span class="comment">// Initialize second as &quot;prop3&quot;</span></div>
<div class="line">prop3VariantField.field_val().value() = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">msg.doRefresh(); <span class="comment">// Bring all fields into a consistent state in one go</span></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_customisation"></a>
Application Specific Customisation of Fields</h2>
<p>The <b>COMMS</b> library provides multiple options to modify default behaviour of field classes. Many of them modify the way how the field is (de)serialised. Such options are expected to be used in actual protocol definition code. However, there are also options that modify used data structures or field's behaviour. Such options are application specific, and the protocol definition is expected to provide a way on delivering such options to fields definitions. The recommended way for the protocol definition is to have separate struct called <b>DefaultOptions</b> which defines all the relevant extension options as its inner types. For example, The message definition may look like this: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"><span class="preprocessor">#include &quot;DefaultOptions.h&quot;</span> <span class="comment">// Defines DefaultOptions struct</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">struct </span>Message1Fields</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> field1 = ...;</div>
<div class="line">    <span class="keyword">using</span> field2 = ...</div>
<div class="line">    <span class="keyword">using</span> field3 = </div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1String.html">comms::field::String</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            <span class="keyword">typename</span> TOpt::message::Message1Fields::field3 <span class="comment">// Extra option(s) </span></div>
<div class="line">        &gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bunding type</span></div>
<div class="line">    <span class="keyword">using</span> All = </div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            field1,</div>
<div class="line">            field2,</div>
<div class="line">            field3</div>
<div class="line">        &gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&lt;TOpt&gt;::All&gt;, <span class="comment">// using fields with extra options</span></div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase, TOpt&gt; &gt; </div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;...&gt;; </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Provide names for the fields</span></div>
<div class="line">    COMMS_MSG_FIELDS_NAMES(value1, value2, value3);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="acomms_8h_html"><div class="ttname"><a href="comms_8h.html">comms.h</a></div><div class="ttdoc">Aggregates all the includes of the COMMS library interface.</div></div>
</div><!-- fragment --><p> The inner structure of <b>DefaultOptions</b> struct is not important, but the recommended practice is to resemble the scope of fields. It may look like this </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"><span class="keyword">struct </span>DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field1 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>; <span class="comment">// no extra functionality by default</span></div>
<div class="line">            <span class="keyword">using</span> field2 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>; <span class="comment">// no extra functionality by default</span></div>
<div class="line">            <span class="keyword">using</span> field3 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>; <span class="comment">// no extra functionality by default</span></div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// my_protocol</span></div>
<div class="ttc" id="anamespacecomms_1_1option_html_a7cab23e160841f8b640b5afeccd8b664"><div class="ttname"><a href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::EmptyOption</a></div><div class="ttdeci">comms::option::app::EmptyOption EmptyOption</div><div class="ttdoc">Same as comms::option::app::EmptyOption.</div><div class="ttdef"><b>Definition:</b> options.h:1802</div></div>
</div><!-- fragment --><p> The application is expected to provide its own options describing struct / class if needed. The easiest way is to extend provided <b>DefaultOptions</b> and override selected types. For example </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field3 = <a class="code" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage&lt;32&gt;</a>;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1FixedSizeStorage_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a></div><div class="ttdoc">Option that forces usage of embedded uninitialised data area instead of dynamic memory allocation.</div><div class="ttdef"><b>Definition:</b> options.h:1331</div></div>
</div><!-- fragment --><p> The definition of the message(s) may look like this: </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::Message1&lt;MyMessage, MyOptions&gt;;</div>
</div><!-- fragment --><p> If there is a need to pass more than one extra option to a field, these options can be bundled together is <b>std::tuple</b>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field3 = std::tuple&lt;..., ...&gt;;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="page_use_prot_fields_customisation_seq"></a>
Customisation for Lists and Strings</h3>
<p>As was already mentioned earlier the default storage type (<b>ValueType</b>) of <a class="el" href="page_use_prot.html#page_use_prot_fields_array_list">Array List Fields</a> is <b>std::vector</b>, while default storage type for <a class="el" href="page_use_prot.html#page_use_prot_fields_string">String Fields</a> is <b>std::string</b>. These types are suitable for most of C++ applications, but may be unsuitable for bare-metal embedded platforms. That why the protocol definition <b>must</b> allow additional customisation of such fields.</p>
<p>The <b>COMMS</b> library provides multiple options to change the default storage type. There is <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> option. When passed to the <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> or <a class="el" href="classcomms_1_1field_1_1String.html">comms::field::String</a>, it changes the default storage type to be <a class="el" href="classcomms_1_1util_1_1StaticVector.html">comms::util::StaticVector</a> or <a class="el" href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString</a> respectively. These types expose the same public API as <b>std::vector</b> or <b>std::string</b>, but use pre-allocated storage area (as their private member) to store the elements / characters. Note, that the <a class="el" href="structcomms_1_1option_1_1app_1_1FixedSizeStorage.html">comms::option::app::FixedSizeStorage</a> option has a template parameter, which specify number of elements (not necessarily bytes) to be stored. If the field definition already uses <a class="el" href="structcomms_1_1option_1_1def_1_1SequenceFixedSize.html">comms::option::def::SequenceFixedSize</a> option to specify that number of elements is fixed, there is <a class="el" href="structcomms_1_1option_1_1app_1_1SequenceFixedSizeUseFixedSizeStorage.html">comms::option::app::SequenceFixedSizeUseFixedSizeStorage</a> option which has the same effect of forcing <a class="el" href="classcomms_1_1util_1_1StaticVector.html">comms::util::StaticVector</a> or <a class="el" href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString</a> to be storage types, but does not require repeating specification of storage area size. For example, if message type is defined to use provided <b>DefaultOptions</b>, then the storage type of <b>field3</b> will be <b>std::string</b> </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::Message1&lt;MyMessage&gt;;</div>
<div class="line">MyMessage1 msg;</div>
<div class="line">std::string&amp; field3Str = msg.field_value3().value();</div>
</div><!-- fragment --><p> However, if message type is defined to used described earlier <b>MyOptions</b>, then the storage type of <b>field3</b> will be <a class="el" href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString</a> </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::Message1&lt;MyMessage, MyOptions&gt;;</div>
<div class="line">MyMessage1 msg;</div>
<div class="line"><a class="code" href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString&lt;32&gt;</a>&amp; field3Str = msg.field_value3().value();</div>
<div class="ttc" id="aclasscomms_1_1util_1_1StaticString_html"><div class="ttname"><a href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString</a></div><div class="ttdoc">Replacement to std::string when no dynamic memory allocation is allowed.</div><div class="ttdef"><b>Definition:</b> StaticString.h:780</div></div>
</div><!-- fragment --><p> NOTE, that using default <b>std::vector</b> / <b>std::string</b> or provided <a class="el" href="classcomms_1_1util_1_1StaticVector.html">comms::util::StaticVector</a> / <a class="el" href="classcomms_1_1util_1_1StaticString.html">comms::util::StaticString</a> will involve copying of the data to these storage areas during the <b>read</b> operation. If the input buffer is contiguous, i.e the pointer to the last element is <b>always</b> greater than pointer to the first one (not some kind of circular buffer), then copying of the data may be avoided by using <a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a> option. The option will change the default storage types to be <a href="https://en.cppreference.com/w/cpp/container/span">std::span&lt;std::uint8_t&gt;</a> or <a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::string_view</a> respectively. In case standard variants are unavalable due to used C++ standard or insufficient standard library version then <a class="el" href="classcomms_1_1util_1_1ArrayView.html">comms::util::ArrayView</a> and/or <a class="el" href="classcomms_1_1util_1_1StringView.html">comms::util::StringView</a> will be used instead.</p>
<p><b>NOTE</b>, that passing <a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a> option to <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> is possible only if it is list of raw data (<b>std::uint8_t</b> is used as element type). </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field3 = <a class="code" href="namespacecomms_1_1option.html#aa3d3bba58428f4b08e3ab29a751954e3">comms::option::app::OrigDataView</a>;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="anamespacecomms_1_1option_html_aa3d3bba58428f4b08e3ab29a751954e3"><div class="ttname"><a href="namespacecomms_1_1option.html#aa3d3bba58428f4b08e3ab29a751954e3">comms::option::OrigDataView</a></div><div class="ttdeci">comms::option::app::OrigDataView OrigDataView</div><div class="ttdoc">Same as comms::option::app::OrigDataView.</div><div class="ttdef"><b>Definition:</b> options.h:1871</div></div>
</div><!-- fragment --><p>If default standard <b>std::vector</b> / <b>std::string</b> or all the provided by the <b>COMMS</b> library storage type are not good enough, it is possible to specify custom storage type using <a class="el" href="structcomms_1_1option_1_1app_1_1CustomStorageType.html">comms::option::app::CustomStorageType</a> option. For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field3 = </div>
<div class="line">                <a class="code" href="structcomms_1_1option_1_1app_1_1CustomStorageType.html">comms::option::app::CustomStorageType</a>&lt;</div>
<div class="line">                    boost::container::pmr::string</div>
<div class="line">                &gt;;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1CustomStorageType_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1CustomStorageType.html">comms::option::app::CustomStorageType</a></div><div class="ttdoc">Set custom storage type for fields like comms::field::String or comms::field::ArrayList.</div><div class="ttdef"><b>Definition:</b> options.h:1348</div></div>
</div><!-- fragment --><h3><a class="anchor" id="page_use_prot_fields_customisation_other"></a>
Customisation for Other Fields</h3>
<p>While allowing extra customisation for fields like <b>list</b> or <b>string</b> is a <b>"must have"</b> feature of the protocol definition, it may also allow additional customisation of other fields as well. For example, let's assume that <b>field1</b> of previously mentioned <b>Message1</b> is a numeric field, that defined the following way: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comms_8h.html">comms/comms.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;MyFieldBase.h&quot;</span> <span class="comment">// Defines MyFieldBase common base class for all the fields</span></div>
<div class="line"><span class="preprocessor">#include &quot;DefaultOptions.h&quot;</span> <span class="comment">// Defines DefaultOptions struct</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">struct </span>Message1Fields</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> field1 = </div>
<div class="line">        <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">            MyFieldBase,</div>
<div class="line">            std::uint8_t,</div>
<div class="line">            <span class="keyword">typename</span> TOpt::message::Message1Fields::field1, <span class="comment">// Extra options </span></div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;10&gt;</a>,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;10, 20&gt;</a></div>
<div class="line">        &gt;;</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&lt;TOpt&gt;::All&gt;, <span class="comment">// using fields with extra options</span></div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase, TOpt&gt; &gt; </div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> If not other options are passed as <b>message::Message1Fields::field1</b> inner type of application specific options struct / class, then the inner value of <b>field1</b> will be initialised to <b>10</b> upon construction and the range of valid values will be <b>[10, 20]</b>. Such default settings may be modified using various options. For example, making the value to be initialised to <b>5</b> and adding it to valid values may look like this: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field1 = </div>
<div class="line">                std::tuple&lt;</div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;5&gt;</a>,</div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValue&lt;5&gt;</a></div>
<div class="line">                &gt;;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p> After these extra options are passed to the field's definition it becomes equivalent to </p><div class="fragment"><div class="line"><span class="keyword">using</span> field1 = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase,</div>
<div class="line">        std::uint8_t,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;5&gt;</a>, <span class="comment">// overrides default value 10 defined below</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValue&lt;5&gt;</a>, <span class="comment">// added to previously defined range [10, 20]</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;10&gt;</a>,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;10, 20&gt;</a></div>
<div class="line">    &gt;;</div>
</div><!-- fragment --><p> <b>NOTE</b> that <b>COMMS</b> library processes all the options <b>bottom-up</b>, i.e. starts with <b>comms::option::def::ValidNumValueRange&lt;10, 20&gt;</b> (which records initial valid range [10, 20]), then processes <b><a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605" title="Alias to DefaultValueInitialiser, it defines initialiser class that assigns numeric value provided as...">comms::option::def::DefaultNumValue&lt;10&gt;</a></b> (which records default value to be 10), then processes <b><a class="el" href="namespacecomms_1_1option_1_1def.html#a8ca4dd158c2eb6e8b58a2640b1e4d04d" title="Alias to ValidNumValueRange.">comms::option::def::ValidNumValue&lt;5&gt;</a></b> (which <b>adds</b> value 5 to the existing valid ranges), then processes <b><a class="el" href="namespacecomms_1_1option_1_1def.html#ae716383045f6638aca961d2d4a1d0605" title="Alias to DefaultValueInitialiser, it defines initialiser class that assigns numeric value provided as...">comms::option::def::DefaultNumValue&lt;5&gt;</a></b> (which changes the default value to be 5).</p>
<p>In case the application needs to override originally defined valid range(s) of the field, it can use <a class="el" href="structcomms_1_1option_1_1def_1_1ValidRangesClear.html">comms::option::def::ValidRangesClear</a> option, which will clear all previously defined valid ranges and will start accumulating them anew. For example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">struct </span>Message1Fields : <span class="keyword">public</span> my_protocol::DefaultOptions::message::Message1Fields</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">using</span> field1 = </div>
<div class="line">                std::tuple&lt;</div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;5&gt;</a>, <span class="comment">// change the default value</span></div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValue&lt;5&gt;</a>, <span class="comment">// add 5 to valid ranges of [40, 50]</span></div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1ValidNumValueRange.html">comms::option::def::ValidNumValueRange&lt;40, 50&gt;</a>, <span class="comment">// new range</span></div>
<div class="line">                    <a class="code" href="structcomms_1_1option_1_1def_1_1ValidRangesClear.html">comms::option::def::ValidRangesClear</a> <span class="comment">// clear the default ranges</span></div>
<div class="line">                &gt;;</div>
<div class="line">        };</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="ttc" id="astructcomms_1_1option_1_1def_1_1ValidRangesClear_html"><div class="ttname"><a href="structcomms_1_1option_1_1def_1_1ValidRangesClear.html">comms::option::def::ValidRangesClear</a></div><div class="ttdoc">Clear accumulated ranges of valid values.</div><div class="ttdef"><b>Definition:</b> options.h:961</div></div>
</div><!-- fragment --><p> Additional option that may be quite useful is <a class="el" href="structcomms_1_1option_1_1def_1_1FailOnInvalid.html">comms::option::def::FailOnInvalid</a>. It causes the <b>read</b> operation to fail with provided error status when read value is not valid (<b>valid()</b> member function returns <b>false</b>).</p>
<p>There may be other useful options, which are not covered by this tutorial, please open reference page of a required <b>field</b> class for the list of supported options and read their documentation for more details.</p>
<h2><a class="anchor" id="page_use_prot_fields_value_assign"></a>
Field Value Assignment</h2>
<p>As was mentioned earlier, every field class has <b>value()</b> member function, which provides an access to internal value storage. Quite often there may be case when explicit cast is required. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;FieldBase, std::uint8_t&gt;</a>; <span class="comment">// One byte int</span></div>
<div class="line"><span class="keywordtype">int</span> someValue = ...;</div>
<div class="line">MyField field;</div>
<div class="line">field.<a class="code" href="classcomms_1_1field_1_1IntValue.html#a6317922167564fa2889270afcb963500">value</a>() = <span class="keyword">static_cast&lt;</span>std::uint8_t<span class="keyword">&gt;</span>(someValue);</div>
</div><!-- fragment --><p> The code above is boilerplate one, which in general should be avoided, because in case of the field definition being changed, the cast below must also be changed. Such boilerplate code can be avoided by using extra compile time type manipulations: </p><div class="fragment"><div class="line">field.value() = <span class="keyword">static_cast&lt;</span>typename std::decay&lt;decltype(field.value())<span class="keyword">&gt;</span>::type&gt;(someValue);</div>
</div><!-- fragment --><p> However, it's too much typing to do and quite inconvenient for the developer. The <b>COMMS</b> library provides <a class="el" href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign()</a> stand alone function which can be used for easy assignments with implicit <b>static_cast</b> to appropriate type. It should be used for any arithmetic and/or enum storage values. </p><div class="fragment"><div class="line"><a class="code" href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign</a>(field.value()) = someValue; <span class="comment">// static_cast is automatic</span></div>
<div class="ttc" id="anamespacecomms_html_a5b8201618df7a2022eb502b194826a4e"><div class="ttname"><a href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign</a></div><div class="ttdeci">details::ValueAssignWrapper&lt; T &gt; cast_assign(T &amp;value)</div><div class="ttdoc">Helper function to assign value with static_cast to appropriate type.</div><div class="ttdef"><b>Definition:</b> cast.h:29</div></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_fields_cast"></a>
Cast Between Fields</h2>
<p>There may also be cases when value of one field needs to be assigned to value of another type. If <b>static_cast</b> between the values works, then it is possible to use <a class="el" href="namespacecomms.html#a5b8201618df7a2022eb502b194826a4e">comms::cast_assign()</a> function described in <a class="el" href="page_use_prot.html#page_use_prot_fields_value_assign">Field Value Assignment</a> section above. </p><div class="fragment"><div class="line"><a class="code" href="namespacecomms_1_1util.html#a8b2699905fdbe18d691e4cf30619c7cc">comms::assign</a>(field1.value()) = field2.value();</div>
<div class="ttc" id="anamespacecomms_1_1util_html_a8b2699905fdbe18d691e4cf30619c7cc"><div class="ttname"><a href="namespacecomms_1_1util.html#a8b2699905fdbe18d691e4cf30619c7cc">comms::util::assign</a></div><div class="ttdeci">void assign(T &amp;obj, TIter from, TIter to)</div><div class="ttdoc">Assigns a new value to provided object.</div><div class="ttdef"><b>Definition:</b> assign.h:39</div></div>
</div><!-- fragment --><p> However, there may be cases when such cast is not possible. For example value of 1 byte <a class="el" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a> needs to be assigned to a <a class="el" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a> length of which is also 1 byte, but it splits the value into a couple of inner members. In this case the <a class="el" href="namespacecomms.html#a503a7696e8a2d355614c52f5f01db177">comms::field_cast()</a> function should be used. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyInt = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue&lt;FieldBase, std::uint8_t&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> MyBitfield = <a class="code" href="classcomms_1_1field_1_1Bitfield.html">comms::field::Bitfield</a>&lt;...&gt;;</div>
<div class="line">MyInt field1;</div>
<div class="line">MyBitfield field2;</div>
<div class="line">... <span class="comment">// Set values of field1 and field2</span></div>
<div class="line">field2 = comms::field_cast&lt;MyBitfield&gt;(field1);</div>
</div><!-- fragment --><p> <b>NOTE</b>, that casting and assignment is performed on the field objects themselves, not their stored values.</p>
<h1><a class="anchor" id="page_use_prot_transport"></a>
Transport Framing</h1>
<p>In addition to definition of the messages and their contents, every communication protocol must ensure that the message is successfully delivered over the I/O link to the other side. The serialised message payload must be wrapped in some kind of transport information prior to being sent and unwrapped on the other side when received. The <b>COMMS</b> protocol defines multiple so called <b>layers</b> (defined in <b><a class="el" href="namespacecomms_1_1protocol.html" title="Namespace that contains definition of layers that can be used to wrap message data with transport dat...">comms::protocol</a></b> namespace). The transport framing will be defined using those <b>layer</b> classes and may be called <b>ProtocolStack</b> or <b>Frame</b>. Its definition is expected to look something like this: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for comms::protocol::MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(...);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1EmptyOption_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a></div><div class="ttdoc">No-op option, doesn't have any effect.</div><div class="ttdef"><b>Definition:</b> options.h:1235</div></div>
</div><!-- fragment --><p> The first template parameter (<b>TMessage</b>) is common message interface class described earlier in <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a> section.</p>
<p>The second template parameter (<b>TInputMessages</b>) is <b>std::tuple</b> of input messages that <b>read</b> operation is expected to recognise. The message classes must be sorted by the ascending order of message IDs. The protocol definition is also expected to define <b>AllMessages</b> tuple which lists all the protocol messages, which can be used as reference.</p>
<p>The third template parameter (<b>TAllocationOptions</b>) is extra option(s) (bundled in <b>std::tuple</b> if more than one) to be passed to <a class="el" href="classcomms_1_1protocol_1_1MsgIdLayer.html">comms::protocol::MsgIdLayer</a> class which is responsible for message allocation. By default the message object is dynamically allocated, it is possible to modify such behaviour by using <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option. It will be explained in more details further below.</p>
<p>The fourth template parameter (<b>TPayloadOptions</b>) is irrelevant in most cases. It has a meaning only when transport wrapping values are cached for further analysis. It will also be explained in more details further below.</p>
<p><b>NOTE</b>, that <b>ProtocolStack</b> definition is actually an alias to one of the classes from <a class="el" href="namespacecomms_1_1protocol.html">comms::protocol</a> namespace. To get a detailed information on available public API please reference to one of them, for example <a class="el" href="classcomms_1_1protocol_1_1SyncPrefixLayer.html">comms::protocol::SyncPrefixLayer</a>.</p>
<p>It may also happen, that the extra options (<b>TAllocationOptions</b> and <b>TPayloadOptions</b>) are defined inside the recommended <b>DefaultOptions</b> structure and be passed to the layers definitions themselves. Such approach is undertaken by the <b>commsdsl2comms</b> code generator application from the <a href="https://github.com/commschamp/commsdsl">commsdsl</a> project. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DefaultOptions</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">struct </span>frame</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Extra options for Layers.</span></div>
<div class="line">        <span class="keyword">struct </span>FrameLayers</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Extra options for Data layer.</span></div>
<div class="line">            <span class="keyword">using</span> Data = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Extra options for Id layer.</span></div>
<div class="line">            <span class="keyword">using</span> Id = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">            </div>
<div class="line">        }; <span class="comment">// struct FrameLayers</span></div>
<div class="line">        </div>
<div class="line">    }; <span class="comment">// struct frame</span></div>
<div class="line">}/ <span class="comment">// struct DefaultOptions</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TOpt = DefaultOptions <span class="comment">// Options of the protocol definitions</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TOpt&gt; </div>
<div class="line">{</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(...);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_transport_read"></a>
Reading Transport Framing and Message Payload</h2>
<p>The <b>COMMS</b> library provides some convenience input processing and message dispatching functionality suitable for most cases. There is <a class="el" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch()</a> function which is responsible to process provided data in input buffer, detect and allocate message objects, and dispatch them to provided handler. For example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="process_8h.html">comms/process.h</a>&quot;</span> <span class="comment">// Contains processing function(s)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Alias to my_protocol::ProtocolStack</span></div>
<div class="line"><span class="keyword">using</span> ProtStack = my_protocol::ProtocolStack&lt;MyMessage&gt;</div>
<div class="line"> </div>
<div class="line">ProtStack protStack; <span class="comment">// Protocol stack object</span></div>
<div class="line">MyHandler handler; <span class="comment">// Handler object</span></div>
<div class="line">std::size_t consumed = <a class="code" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch</a>(buf, bufLen, protStack, handler);</div>
<div class="line">... <span class="comment">// Removed consumed bytes from input buffer</span></div>
<div class="ttc" id="anamespacecomms_html_a1ad268bb091d752a4c557374f65e4f44"><div class="ttname"><a href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch</a></div><div class="ttdeci">std::size_t processAllWithDispatch(TBufIter bufIter, std::size_t len, TFrame &amp;&amp;frame, THandler &amp;handler)</div><div class="ttdoc">Process all available input and dispatch all created message objects to appropriate handling function...</div><div class="ttdef"><b>Definition:</b> process.h:246</div></div>
<div class="ttc" id="aprocess_8h_html"><div class="ttname"><a href="process_8h.html">process.h</a></div><div class="ttdoc">Provides auxiliary functions for processing input and dispatching messages.</div></div>
</div><!-- fragment --><p> The code above will dispatch allocated message objects to the provided handler using <a class="el" href="namespacecomms.html#a2452362a2fe3788e868e4f40e54cf102">comms::dispatchMsg()</a> function, which in turn performs compile time analysis of supported message types and can result in either using polymorphic (see <a class="el" href="namespacecomms.html#ad0286f72522d7804868bb551505a08e1">comms::dispatchMsgPolymorphic()</a>) or static binary search (see <a class="el" href="namespacecomms.html#a31149d8672043acec9acc15cb8072af9">comms::dispatchMsgStaticBinSearch()</a>) way of dispatching. If such default behavior of the <b>COMMS</b> library is not good enough for a particular application, it is recommended to use <a class="el" href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">comms::processAllWithDispatchViaDispatcher()</a> function instead, which uses <a class="el" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a> to force a particular way of dispatching. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyDispatcher = <a class="code" href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher&lt;comms::option::ForceDispatchStaticBinSearch&gt;</a></div>
<div class="line">std::size_t consumed = </div>
<div class="line">    comms::processAllWithDispatchViaDispatcher&lt;MyDispatcher&gt;(buf, bufLen, protStack, handler);</div>
<div class="ttc" id="aclasscomms_1_1MsgDispatcher_html"><div class="ttname"><a href="classcomms_1_1MsgDispatcher.html">comms::MsgDispatcher</a></div><div class="ttdoc">An auxiliary class to force a particular way of dispatching message to its handler.</div><div class="ttdef"><b>Definition:</b> MsgDispatcher.h:63</div></div>
</div><!-- fragment --><p> If the described above processing functions (<a class="el" href="namespacecomms.html#a1ad268bb091d752a4c557374f65e4f44">comms::processAllWithDispatch()</a> and <a class="el" href="namespacecomms.html#ab5a09c4ded3af5eae3c39fa4926478bb">comms::processAllWithDispatchViaDispatcher()</a>) are not good enough for a particular application, there are several auxiliary functions that can be used to implement application specific input data processing loop. Please refer to the documentation of: </p><ul>
<li><a class="el" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch()</a> </li>
<li><a class="el" href="namespacecomms.html#a7088de229a0103c1de50a2a1deebad45">comms::processSingleWithDispatchViaDispatcher()</a> </li>
<li><a class="el" href="namespacecomms.html#a4df361b68b43438d84c63c70f5fce161">comms::processSingle()</a></li>
</ul>
<p>There are protocols when number of input messages is very limited (one or two) such as various types of acknowledgment. To support such case <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> member function of the <b>ProtocolStack</b> as well as processing function(s) described above support reception of reference to the real message object (instead of <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a> pointer). </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyAckMsg = my_protocol::AckMsg&lt;MyMessage&gt;;</div>
<div class="line">MyAckMsg msg;</div>
<div class="line"><span class="keyword">auto</span> es = <a class="code" href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch</a>(buf, bufLen, protStack, msg);</div>
<div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">comms::ErrorStatus::InvalidMsgId</a>) {</div>
<div class="line">    <span class="comment">// Unexpected message (not AckMsg) has been received, report or handle error</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1aa3715f4b800299cfe6c930f0dd998aab">comms::ErrorStatus::InvalidMsgId</a></div><div class="ttdeci">@ InvalidMsgId</div><div class="ttdoc">Used to indicate that received message has unknown id.</div></div>
<div class="ttc" id="anamespacecomms_html_a6192c4f27a8a642677487c3fd9c56768"><div class="ttname"><a href="namespacecomms.html#a6192c4f27a8a642677487c3fd9c56768">comms::processSingleWithDispatch</a></div><div class="ttdeci">comms::ErrorStatus processSingleWithDispatch(TBufIter &amp;bufIter, std::size_t len, TFrame &amp;&amp;frame, TMsg &amp;msg, THandler &amp;handler, TExtraValues... extraValues)</div><div class="ttdoc">Process input until first message is recognized, its object is created and dispatched to appropriate ...</div><div class="ttdef"><b>Definition:</b> process.h:119</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that in such case there is <b>no</b> need for either <a class="el" href="page_use_prot.html#page_use_prot_interface_read">Polymorphic Read of Payload (Deserialisation)</a> or <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>. In fact, no virtual function call is used in the code above.</p>
<h2><a class="anchor" id="page_use_prot_transport_msg_alloc"></a>
Message Object Allocation</h2>
<p>By default, the message object is dynamically allocated. However, some applications (especially bare-metal ones) may require something different. The <b>COMMS</b> library has <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> option, which may be passed as third template parameter (<b>TAllocationOptions</b>) to <b>ProtocolStack</b> type definition. It statically allocates (in private data members) storage area, that is capable to store any message object from the <b>std::tuple</b> passed as second parameter to <b>ProtocolStack</b> type definition. The message allocation is performed using "placement new" operator, which means only one message object can be allocated at a time. The smart pointer holding the message (<a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>) is still <b>std::unique_ptr</b>, but with custom deleter.</p>
<p>In case the <a class="el" href="page_use_prot.html#page_use_prot_interface">Message Interface</a> class does not define any virtual function (which results in lack of virtual destructor), the <b>COMMS</b> library also creates a custom deleter for the defined smart pointer to the allocated message (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a17b1b0d2a42427cb7c998a41c9aa3174">MsgPtr</a>) to allow proper downcast of the held pointer to the appropriate class and invoke the correct destructor.</p>
<p>In such cases (that require usage of custom deleters) please refrain from releasing the held object and/or changing the smart pointer type.</p>
<h2><a class="anchor" id="page_use_prot_transport_generic_msg"></a>
Using Generic Message</h2>
<p>In general, if message ID cannot be recognised, then appropriate message object cannot be created and processed, i.e. the reading loop will just discard such input. However, there are applications that serve as some kind of a <b>bridge</b> or a <b>firewall</b>, i.e. need to recognise and process only limited number of input messages, all the rest need to be forwarded "as-is" or maybe wrapped in different transport frame before sending it over different I/O link. To help with such task <b>COMMS</b> library provides <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> class. There is also <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> option that can be passed as third template parameter (<b>TAllocationOptions</b>) to the <b>ProtocolStack</b> type definition. It will force of creation <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> object when appropriate message object is not found. </p><div class="fragment"><div class="line"><span class="comment">// Define generic message type</span></div>
<div class="line"><span class="keyword">using</span> MyGenericMessage = <a class="code" href="classcomms_1_1GenericMessage.html">comms::GenericMessage&lt;MyMessage&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Limited number of supported messages</span></div>
<div class="line"><span class="keyword">using</span> MyInputMessages = </div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        my_protocol::Message1&lt;MyMessage&gt;,</div>
<div class="line">        my_protocol::Message2&lt;MyMessage&gt;</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Protocol stack definition</span></div>
<div class="line"><span class="keyword">using</span> ProtStack = </div>
<div class="line">    my_protocol::ProtocolStack&lt;</div>
<div class="line">        MyMessage, </div>
<div class="line">        MyInputMessages,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage&lt;MyGenericMessage&gt;</a></div>
<div class="line">    &gt;;</div>
<div class="ttc" id="aclasscomms_1_1GenericMessage_html"><div class="ttname"><a href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a></div><div class="ttdoc">Generic Message.</div><div class="ttdef"><b>Definition:</b> GenericMessage.h:76</div></div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1SupportGenericMessage_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a></div><div class="ttdoc">Option used to allow comms::GenericMessage generation inside comms::MsgFactory and/or comms::protocol...</div><div class="ttdef"><b>Definition:</b> options.h:1315</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> has only single field, which is a list of raw data (<a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a>). The <b>read</b> operation of such field will result in copying the data from input buffer to internal storage of this field. The <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a> class has also other template parameters (except common message interface class). The second template parameter is option(s) that are going to be passed to this <a class="el" href="classcomms_1_1field_1_1ArrayList.html" title="Field that represents a sequential collection of fields.">comms::field::ArrayList</a> field. If allocated message is <b>not</b> going to outlive input buffer, than it may make sense to pass <a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a> as second template parameter to <a class="el" href="classcomms_1_1GenericMessage.html">comms::GenericMessage</a>. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyGenericMessage = <a class="code" href="classcomms_1_1GenericMessage.html">comms::GenericMessage&lt;MyMessage, comms::option::app::OrigDataView&gt;</a>;</div>
</div><!-- fragment --><p>Also <b>note</b>, that it is possible to combine usage of <a class="el" href="structcomms_1_1option_1_1app_1_1InPlaceAllocation.html">comms::option::app::InPlaceAllocation</a> and <a class="el" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage</a> as the third template parameter to <b>ProtocolStack</b> type definition using <b>std::tuple</b> bundling. </p><div class="fragment"><div class="line"><span class="keyword">using</span> ProtStack = </div>
<div class="line">    my_protocol::ProtocolStack&lt;</div>
<div class="line">        MyMessage, </div>
<div class="line">        MyInputMessages,</div>
<div class="line">        std::tuple&lt;</div>
<div class="line">            <a class="code" href="namespacecomms_1_1option.html#a8ab0ed0f97a929a87d0a4a136b6e8cef">comms::option::app::InPlaceAllocation</a>,</div>
<div class="line">            <a class="code" href="structcomms_1_1option_1_1app_1_1SupportGenericMessage.html">comms::option::app::SupportGenericMessage&lt;MyGenericMessage&gt;</a></div>
<div class="line">        &gt;</div>
<div class="line">    &gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a8ab0ed0f97a929a87d0a4a136b6e8cef"><div class="ttname"><a href="namespacecomms_1_1option.html#a8ab0ed0f97a929a87d0a4a136b6e8cef">comms::option::InPlaceAllocation</a></div><div class="ttdeci">comms::option::app::InPlaceAllocation InPlaceAllocation</div><div class="ttdoc">Same as comms::option::app::InPlaceAllocation.</div><div class="ttdef"><b>Definition:</b> options.h:1850</div></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_transport_write"></a>
Writing Transport Framing and Message Payload</h2>
<p>The easiest way to implement write functionality is to use the ability of the message object to perform polymorphic write. </p><div class="fragment"><div class="line">ProtStack protStack; <span class="comment">// Protocol stack defined in one of previous sections</span></div>
<div class="line"><span class="keywordtype">void</span> sendMessage(<span class="keyword">const</span> MyMessage&amp; msg, std::uint8_t* buf, std::size_t len)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> writeIter = comms::writeIteratorFor&lt;MyMessage&gt;(&amp;buf[0]);</div>
<div class="line">    <span class="keyword">auto</span> es = protStack.write(msg, writeIter, len);</div>
<div class="line">    <span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">        ... <span class="comment">// Send contents of dataToSend via I/O link</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> In order to support such polymorphic write the common message interface class <b>MyMessage</b> has to have the following polymorphic functionality</p>
<ul>
<li><a class="el" href="page_use_prot.html#page_use_prot_interface_write">Polymorphic Write of Payload (Serialisation)</a> to write the message payload. </li>
<li><a class="el" href="page_use_prot.html#page_use_prot_interface_id_retrieve">Polymorphic Retrieval of Message ID</a> to write the message ID information.</li>
</ul>
<p>In case the transport framing reports size that follows, the support for <a class="el" href="page_use_prot.html#page_use_prot_interface_length">Polymorphic Serialisation Length Retrieval</a> is also recommended. It will be used to write the required value right away. However, if not provided the dummy value (<b>0</b>) will be written at first, then after the write operation is complete, the number of written bytes will be calculated and the previously written dummy value updated accordingly. <b>NOTE</b>, that such update is possible only if iterator used for writing is random-access one. Otherwise, such update won't be possible. In this case <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a> error status will be returned. It means that the write operation is incomplete, there is a need to perform <b>update()</b> call with random-access iterator. For example, let's assume the <a class="el" href="page_use_prot.html#page_use_prot_interface_length">Polymorphic Serialisation Length Retrieval</a> is not supported and <b>std::back_insert_iterator&lt;std::vector&lt;std::uint8&gt; &gt;</b> is passed to <b>MyMessage</b> with <a class="el" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator</a> option. the message object to perform polymorphic write </p><div class="fragment"><div class="line">ProtStack protStack; <span class="comment">// Protocol stack defined in one of previous sections</span></div>
<div class="line"><span class="keywordtype">void</span> sendMessage(<span class="keyword">const</span> MyMessage&amp; msg, std::vector&lt;std::uint8_t&gt;&amp; outBuf)</div>
<div class="line">{</div>
<div class="line">    assert(outBuf.empty()) <span class="comment">// Make sure buffer is empty</span></div>
<div class="line">    auto writeIter = std::back_inserter(outBuf);</div>
<div class="line">    auto es = protStack.write(msg, writeIter, outBuf.max_size());</div>
<div class="line">    if (es == <a class="code" href="namespacecomms.html">comms</a>::<a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1">ErrorStatus</a>::UpdateRequired) {</div>
<div class="line">        <span class="keyword">auto</span> updateIter = &amp;outBuf[0];</div>
<div class="line">        es = protStack.update(updateIter, outBuf.size());</div>
<div class="line">    }</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">        ... <span class="comment">// Send contents of dataToSend via I/O link</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_html"><div class="ttname"><a href="namespacecomms.html">comms</a></div><div class="ttdoc">Main namespace for all classes / functions of COMMS library.</div></div>
</div><!-- fragment --><p> Similar scenario of a need to handle <a class="el" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a> error status may occur when transport framing contains checksum value and output (not random-access) iterator is used. The checksum calculation requires going over the written data to calculate the value. However, it won't be possible to do right away, the <b>update()</b> call must follow.</p>
<p>There may be cases when <b>update()</b> operation also requires knowledge about message object being written. For example when remaining size information shares the same bytes with some extra flags, which can be retrieved from the message object being written. To support such cases there is also overloaded <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3656112afd3d327855b8d5c93b8a6779">update()</a> member function which also receives reference to message object/ </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a>) {</div>
<div class="line">    <span class="keyword">auto</span> updateIter = &amp;outBuf[0];</div>
<div class="line">    es = protStack.update(msg, updateIter, outBuf.size());</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_html_a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d"><div class="ttname"><a href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a618c95bafa9a5e5ab723e10573f3365d">comms::ErrorStatus::UpdateRequired</a></div><div class="ttdeci">@ UpdateRequired</div></div>
</div><!-- fragment --><p>The <b>ProtocolStack</b> does not require usage of polymorphic write for message serialisation all the time. If number of messages being sent is not very high, sometimes it makes sense to avoid adding an ability to support polymorphic write in the common interface. In this case the sending functionality can be implemented using a template function where actual message objects are passed as the parameter: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TMsg&gt;</div>
<div class="line"><span class="keywordtype">void</span> sendMessage(<span class="keyword">const</span> TMsg&amp; msg)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">auto</span> es = protStack.write(msg, ...);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Such implementation does not require any polymorphic behaviour from the message object being sent, it takes all the required information from the direct calls to non-virtual <b>doGetId()</b> (see <a class="el" href="classcomms_1_1MessageBase.html#afad51591454e5bc2a293743d2d1671d5">comms::MessageBase::doGetId()</a>) and <b>doLength()</b> (see <a class="el" href="classcomms_1_1MessageBase.html#a6d36881b8fea2fa53cc8e17a1e82df27">comms::MessageBase::doLength()</a>). The payload write is also performed using direct call to <b>doWrite()</b> (see <a class="el" href="classcomms_1_1MessageBase.html#a79e5ec00e39ff64c5f9208813f270468">comms::MessageBase::doWrite()</a>).</p>
<h2><a class="anchor" id="page_use_prot_transport_caching"></a>
Access to Processed Stack Fields</h2>
<p>All the examples above do not store the read/written transport fields anywhere. In most cases it is not needed. However, if need arises they can be cached during the read/write operations and accessed later. The <b>ProtocolStack</b> also defines <b>AllFields</b> type which is <b>std::tuple</b> of all the fields used by all the layer classes. <br  />
Also, the <b>ProtocolStack</b> defines <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#af0877d7cedb580508e91ecfb7353227d">writeFieldsCached()</a> member functions which are substitutes to normal <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a6799fbfb090ea3a612d3757a0d28fd06">write()</a>. The first parameter to these functions is reference to the <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ac9c47bcb2d5407fb4679cff923b1f86a">AllFields</a> bundle object. </p><div class="fragment"><div class="line">ProtStack::AllFields fields;</div>
<div class="line"><span class="keyword">auto</span> es = protStack.readFieldsCached(fields, msgPtr, readIter, bufSize);</div>
</div><!-- fragment --><p> The layer class that is responsible to read/write payload data (see <a class="el" href="classcomms_1_1protocol_1_1MsgDataLayer.html">comms::protocol::MsgDataLayer</a>) uses <a class="el" href="classcomms_1_1field_1_1ArrayList.html">comms::field::ArrayList</a> to define a field that will store the payload when "caching" operations are performed. That's where the fourth template parameter (<b>TPayloadOptions</b>) to <b>ProtocolStack</b> definition comes in play. In case the the input / output buffer outlives the <b>AllFields</b> object, consider passing <a class="el" href="structcomms_1_1option_1_1app_1_1OrigDataView.html">comms::option::app::OrigDataView</a> option as the fourth template parameter to <b>ProtocolStack</b> definition, which will pass it to to the field containing the message payload raw data. Otherwise, the payload part from the read / written buffer will also be copied to storage area of the cached payload field.</p>
<p>As was mentioned earlier, the protocol stack is defined using so called <b>layer</b> classes (defined in <a class="el" href="namespacecomms_1_1protocol.html">comms::protocol</a> namespace) by wrapping one another. Access to the appropriate layer may be obtained using a sequence of calls to <b>nextLayer()</b> member functions (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a85be582d3c8e022bc5241b7729d96d49">comms::protocol::ProtocolLayerBase::nextLayer()</a>). Alternatively, the protocol stack definition is also expected to use <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a7fb36c91416d5bbfd3434c164cc01692">COMMS_PROTOCOL_LAYERS_ACCESS()</a> macro to generate a convenience access functions. For example </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(payload, <span class="keywordtype">id</span>, size, checksum, sync);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> The provided names are used in generation of access member functions with <b>layer_</b> prefix. The code above is equivalent to having the following member functions defined. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySyncPrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Access to PAYLOAD layer</span></div>
<div class="line">    decltype(<span class="keyword">auto</span>) layer_payload();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to PAYLOAD layer</span></div>
<div class="line">    decltype(auto) layer_payload() const;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to ID layer</span></div>
<div class="line">    decltype(auto) layer_id();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to ID layer</span></div>
<div class="line">    decltype(auto) layer_id() const;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to SIZE layer</span></div>
<div class="line">    decltype(auto) layer_size();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to SIZE layer</span></div>
<div class="line">    decltype(auto) layer_size() const;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to CHECKSUM layer</span></div>
<div class="line">    decltype(auto) layer_checksum();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to CHECKSUM layer</span></div>
<div class="line">    decltype(auto) layer_checksum() const;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access to SYNC layer</span></div>
<div class="line">    decltype(auto) layer_sync();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Const access to SYNC layer</span></div>
<div class="line">    decltype(auto) layer_sync() const;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Then the access to the appropriate layer as as simple as calling appropriate <b>layer_*</b>() member function. Once the access is obtained, it is possible to call <b>accessCachedField()</b> (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a3abb2d85e1433979aabeb6b09c7a2037">comms::protocol::ProtocolLayerBase::accessCachedField()</a>) member function to get an access to appropriate field. For example: </p><div class="fragment"><div class="line">ProtStack protStack; <span class="comment">// Protocol stack object</span></div>
<div class="line">ProtStack::AllFields fields; <span class="comment">// Transport fields</span></div>
<div class="line"><span class="keyword">auto</span> es = protStack.readFieldsCached(fields, msgPtr, readIter, bufSize);</div>
<div class="line"><span class="keywordflow">if</span> (es != <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">    ... <span class="comment">// handle error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;SYNC = &quot;</span> &lt;&lt; protStack.layer_sync().accessCachedField(fields).value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;SIZE = &quot;</span> &lt;&lt; protStack.layer_size().accessCachedField(fields).value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;ID = &quot;</span> &lt;&lt; protStack.layer_id().accessCachedField(fields).value() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;CHECKSUM = &quot;</span> &lt;&lt; protStack.layer_checksum().accessCachedField(fields).value() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Version <b>v2.0</b> the <b>COMMS</b> library has introduced additional way to retrieve values from stripped message framing. There are several functions listed below that can be used to pass extra variadic arguments to the "read" functions of the protocol stack (see <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#a60d0ea06c68e5b885bf651d7a7b14d1a">read()</a> and <a class="el" href="classcomms_1_1protocol_1_1ProtocolLayerBase.html#ad22a30d6baba8a074f419fe710b809d5">readFieldsCached()</a>). </p><ul>
<li><a class="el" href="namespacecomms_1_1protocol.html#ac267c873369aacc9a16b9b205d85246b">comms::protocol::missingSize()</a> - Use to retrieve minimal missing size required to be read in order the following "read()" operation to have a chance of being completed successfully. </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId()</a> - Use to retrieve numeric message ID. </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex()</a> - Use to retrieve index of the message among difference message types that have the same numeric ID. </li>
<li><a class="el" href="namespacecomms_1_1protocol.html#ae85afb77abdbfda64916cc6e0d2cb521">comms::protocol::msgPayload()</a> - Use to retrieve the location of message payload in the input buffer.</li>
</ul>
<p>For example there can be a case when <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a> does not support <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a>. In this case it might be required to retrieve the information about message ID and its relevant index in order to dispatch message object to its appropriate handling function (see <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a>). </p><div class="fragment"><div class="line"><span class="comment">// Alias to my_protocol::ProtocolStack</span></div>
<div class="line"><span class="keyword">using</span> ProtStack = my_protocol::ProtocolStack&lt;MyMessage&gt;</div>
<div class="line"> </div>
<div class="line">ProtStack protStack; <span class="comment">// Protocol stack object</span></div>
<div class="line">MyHandler handler; <span class="comment">// Handler object</span></div>
<div class="line">ProtStack::MsgPtr msg; Pointer to message to be updated</div>
<div class="line">my_protocol::MsgId <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a> = my_protocol::MsgId(); <span class="comment">// Message ID to be updated </span></div>
<div class="line">std::size_t <a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a> = 0U; <span class="comment">// Message index to be updated</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> es = </div>
<div class="line">    protStack.read(</div>
<div class="line">        msg, </div>
<div class="line">        readIter, </div>
<div class="line">        bufLen, </div>
<div class="line">        <a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId</a>(<a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a>), <span class="comment">// msgId will be updated here</span></div>
<div class="line">        <a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex</a>(<a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a>)); <span class="comment">// msgIndex will be updated here</span></div>
<div class="line"><span class="keywordflow">if</span> (es == <a class="code" href="namespacecomms.html#a0a259a03d68bce98b4a129fb34aaa2e1a505a83f220c02df2f85c3810cd9ceb38">comms::ErrorStatus::Success</a>) {</div>
<div class="line">    assert(msg); <span class="comment">// Message object is expected to be valid</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dispatch message knowing its id and index.</span></div>
<div class="line">    comms::dispatchMsg&lt;MyInputMessages&gt;(<a class="code" href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">msgId</a>, <a class="code" href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">msgIndex</a>, *msg, handler);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_a4dfb5a97bd086a5926c9101f467f8683"><div class="ttname"><a href="namespacecomms_1_1protocol.html#a4dfb5a97bd086a5926c9101f467f8683">comms::protocol::msgId</a></div><div class="ttdeci">details::MsgIdRetriever&lt; TId &gt; msgId(TId &amp;val)</div><div class="ttdoc">Add &quot;message ID&quot; output parameter to protocol stack's (frame's) &quot;read&quot; operation.</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1569</div></div>
<div class="ttc" id="anamespacecomms_1_1protocol_html_a8b5ef8b32dcb4f47fb149397c14897ae"><div class="ttname"><a href="namespacecomms_1_1protocol.html#a8b5ef8b32dcb4f47fb149397c14897ae">comms::protocol::msgIndex</a></div><div class="ttdeci">details::MsgIndexRetriever msgIndex(std::size_t &amp;val)</div><div class="ttdoc">Add &quot;message index&quot; output parameter to protocol stack's (frame's) &quot;read&quot; operation.</div><div class="ttdef"><b>Definition:</b> ProtocolLayerBase.h:1607</div></div>
</div><!-- fragment --><h1><a class="anchor" id="page_use_prot_handling"></a>
Message Handling</h1>
<p>When a message is received over I/O link and successfully deserialised, it needs to be dispatched to appropriate handling function. Many developers write quite big (depends on number of messages it needs to handle) switch statement that checks the ID of the message and calls appropriate function in the relevant case area. Other developers try to minimise amount of boilerplate code by introducing hand written map from message ID to the handling function. Such approaches may be quite inefficient in terms of execution performance as well as development effort required to introduce a new message when protocol evolves.</p>
<p>The <b>COMMS</b> library has a built-in efficient (O(1)) dispatch mechanism, which uses "Double Dispatch" idiom. The <a class="el" href="page_use_prot.html#page_use_prot_interface_handle">Polymorphic Dispatch Message for Handling</a> section above described using <b><a class="el" href="structcomms_1_1option_1_1app_1_1Handler.html" title="Option used to specify type of the message handler.">comms::option::app::Handler</a></b> option, which adds polymorphic <b>dispatch()</b> member function to the common interface class (<b>MyMessage</b>). The provided handling class (<b>MyHandler</b>) is expected to define <b>handle()</b> member function for every message class it is expected to handle. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg) {...}</div>
<div class="line">    <span class="keywordtype">void</span> handle(my_protocol::Message5&lt;MyMessage&gt;&amp; msg) {...}</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> and a single <b>handle()</b> member function that receives common message interface class for all the messages that need to be ignored or handled in some other common way. If this function is not added, the compilation may fail. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">void</span> handle(MyMessage&amp; msg) {} <span class="comment">// do nothing for all other messages</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> For example, let's assume that <b>MyHandler</b> defines message to properly handle <b>Message1</b>, but doesn't care about <b>Message2</b>. In this case </p><div class="fragment"><div class="line">std::unique_ptr&lt;MyMessage&gt; msg1(<span class="keyword">new</span> my_protocol::Message1&lt;MyMessage&gt;);</div>
<div class="line">std::unique_ptr&lt;MyMessage&gt; msg2(<span class="keyword">new</span> my_protocol::Message2&lt;MyMessage&gt;);</div>
<div class="line">MyHandler handler;</div>
<div class="line"> </div>
<div class="line">msg1-&gt;dispatch(handler); <span class="comment">// invokes handle(my_protocol::Message1&lt;MyMessage&gt;&amp;)</span></div>
<div class="line">msg2-&gt;dispatch(handler); <span class="comment">// invokes handle(MyMessage&amp;)</span></div>
</div><!-- fragment --><p><b>NOTE</b>, that <b>MyMessage</b> class is only forward declared when <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a> (<b>MyMessage</b>), but needs to be properly defined (included if in separate file) when defining <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a>.</p>
<h2><a class="anchor" id="page_use_prot_handling_multi"></a>
Having Multiple Handlers</h2>
<p>There may be a need for being able to dispatch message for multiple independent handlers. Good example would be having a state-machine, where every state processes the same message in different way. It is simple to implement by just defining the handling functions as <b>virtual</b>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message3&lt;MyMessage&gt;&amp; msg) = 0;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> Defining the concrete handlers: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Handler1 : <span class="keyword">public</span> MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message3&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Handler2 : <span class="keyword">public</span> MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message3&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override </span>{...};</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> Now, any of the handlers may be used to handle the message: </p><div class="fragment"><div class="line">std::unique_ptr&lt;MyMessage&gt; msg(...<span class="comment">/* some message object */</span>);</div>
<div class="line">Handler1 handler1;</div>
<div class="line">Handler2 handler2;</div>
<div class="line"> </div>
<div class="line">msg-&gt;dispatch(handler1); <span class="comment">// Handle with handler1</span></div>
<div class="line">msg-&gt;dispatch(handler2); <span class="comment">// Handle with handler2</span></div>
</div><!-- fragment --><h2><a class="anchor" id="page_use_prot_handling_generic"></a>
Generic Handler</h2>
<p>The <b>COMMS</b> library provides some help in defining custom message handlers. There is <a class="el" href="classcomms_1_1GenericHandler.html">comms::GenericHandler</a> class that receives at least two template parameters. The first one is a common interface class for all the handled messages (<b>MyMessage</b>). The second template parameter is all the types of all the custom messages the handler is supposed to handle, bundled into std::tuple. Remember defining a bundle of messages (<b>MyInputMessages</b>) that need to be recognised during <a class="el" href="page_use_prot.html#page_use_prot_transport_read">Reading Transport Framing and Message Payload</a>? It's probably a good place to reuse it or define a new tuple if there is a mismatch. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessagesToHandle = MyInputMessages;</div>
</div><!-- fragment --><p> As the result the <a class="el" href="classcomms_1_1GenericHandler.html" title="Generic common message handler.">comms::GenericHandler</a> implements <b>virtual</b> <b>handle()</b> function for all the provided messages including the provided interface one. The code that automatically generated by <b><a class="el" href="classcomms_1_1GenericMessage.html" title="Generic Message.">comms::GenericMessage</a></b> is equivalent to the one below. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">class </span>GenericHandler&lt;MyMessage, MyMessagesToHandle&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(MyMessage&amp; msg) {} <span class="comment">// Do nothing</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;handle(<span class="keyword">static_cast&lt;</span>MyMessage&amp;<span class="keyword">&gt;</span>(msg)); <span class="comment">// invoke default handling</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        this-&gt;handle(<span class="keyword">static_cast&lt;</span>MyMessage&amp;<span class="keyword">&gt;</span>(msg)); <span class="comment">// invoke default handling</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> Now, what remains is to inherit from <a class="el" href="classcomms_1_1GenericHandler.html" title="Generic common message handler.">comms::GenericHandler</a> and override the functions that need to be overridden: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler : <span class="keyword">public</span> <a class="code" href="classcomms_1_1GenericHandler.html">comms::GenericHandler</a>&lt;MyMessage, AllMessages&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Enable polymorphic delete</span></div>
<div class="line">    <span class="keyword">virtual</span> ~MyHandler() {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Overriding the default handling function</span></div>
<div class="line">    <span class="keyword">virtual</span> handle(MyMessage&amp; msg)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Ignoring message with ID: &quot;</span> &lt;&lt; msg.getId() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Overriding handling of Message1</span></div>
<div class="line">    <span class="keyword">virtual</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        ...; <span class="comment">// Handle Message1</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclasscomms_1_1GenericHandler_html"><div class="ttname"><a href="classcomms_1_1GenericHandler.html">comms::GenericHandler</a></div><div class="ttdoc">Generic common message handler.</div><div class="ttdef"><b>Definition:</b> GenericHandler.h:50</div></div>
</div><!-- fragment --><p> Pay attention that <a class="el" href="classcomms_1_1GenericHandler.html">comms::GenericHandler</a> doesn't declare its destructor as virtual. If the handler object requires support for polymorphic delete (destruction), make sure to declare its destructor as virtual.</p>
<h2><a class="anchor" id="page_use_prot_handling_result"></a>
Returning Handling Result</h2>
<p>All the examples above used <b>void</b> as a return type from handling functions. It is possible, however, to return value of handling result. In order to achieve this the handler class needs to define inner <b>RetType</b> type and all the <b>handle()</b> functions must return it. For example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Return type of all the handle() functions</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">bool</span> RetType;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message1&lt;MyMessage&gt;&amp; msg) {...}</div>
<div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message2&lt;MyMessage&gt;&amp; msg) {...}</div>
<div class="line">    <span class="keywordtype">bool</span> handle(my_protocol::Message3&lt;MyMessage&gt;&amp; msg) {...}</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> If inner <b>RetType</b> type is defined, it is propagated to be also the return type of the <a class="el" href="classcomms_1_1Message.html#af2781055a9fb72a553d56cfd6ac99c5e">comms::Message::dispatch()</a> member function as well. As the result the developer may use constructs like this: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> result = msg-&gt;dispatch(handler);</div>
</div><!-- fragment --><p>If <a class="el" href="classcomms_1_1GenericHandler.html">comms::GenericHandler</a> class is used to define the handler class, its third template parameter (which defaults to <b>void</b>), can be used to specify the return type of handling functions.</p>
<p><b>NOTE</b>, since version <b>v1.1</b> the <b>COMMS</b> library supports other ways to dispatch a message object to its handling function in addition to one described above. Please read <a class="el" href="page_dispatch.html">Advanced Guide to Message Dispatching</a> page for more details.</p>
<h1><a class="anchor" id="page_use_prot_extra_transport"></a>
Extra Transport Values</h1>
<p>Some protocols may use extra values in their transport information, which may influence the way how message payload is being read and/or message object being handled. Good example would be having a protocol version, which defines what message payload fields were serialised and which were not (because they were introduced in later version of the protocol). Such extra information is stored in the message object itself. If this is the case, the protocol definition is expected to use <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option in addition to specifying serialisation endian and message ID type (described in <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a>). (see <a class="el" href="page_field_tutorial.html">Fields Definition Tutorial</a>) and bundled in <b>std::tuple:</b> </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Field describing protocol version.</span></div>
<div class="line"><span class="keyword">using</span> MyVersionField = </div>
<div class="line">    <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;</div>
<div class="line">        MyFieldBase, </div>
<div class="line">        std::uint16_t,</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1def_1_1DefaultValueInitialiser.html">comms::option::def::DefaultNumValue&lt;5&gt;</a> <span class="comment">// Implementing v5 of the protocol by default</span></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Relevant extra transport fields, bundled in std::tuple</span></div>
<div class="line"><span class="keyword">using</span> MyExtraTransportFields =</div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        MyVersionField</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// (Re)definition of the base class as inner Base type</span></div>
<div class="line">    <span class="keyword">using</span> Base = <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    COMMS_MSG_TRANSPORT_FIELDS_NAMES(<a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>)</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="anamespacecomms_html_a124576497d233cf87eb7432190e6c9fe"><div class="ttname"><a href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">comms::version</a></div><div class="ttdeci">constexpr unsigned version()</div><div class="ttdoc">Version of the COMMS library as single numeric value.</div><div class="ttdef"><b>Definition:</b> version.h:64</div></div>
</div><!-- fragment --><p> Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option as well as <a class="el" href="classcomms_1_1Message.html#a00912bb201d47afbb0c3e51fff95b338">COMMS_MSG_TRANSPORT_FIELDS_NAMES()</a> macro in the message class definition is equivalent to having the following types and member functions defined </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Type of extra fields</span></div>
<div class="line">    <span class="keyword">using</span> TransportFields = MyExtraTransportFields;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessors for defined transport fields</span></div>
<div class="line">    TransportFields&amp; transportFields() { <span class="keywordflow">return</span> m_transportFields; }</div>
<div class="line">    <span class="keyword">const</span> TransportFields&amp; transportFields()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_transportFields; }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Indices to access extra transport fields</span></div>
<div class="line">    <span class="keyword">enum</span> TransportFieldIdx</div>
<div class="line">    {</div>
<div class="line">        TransportFieldIdx_version,</div>
<div class="line">        TransportFieldIdx_numOfValues</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;version&quot; extra transport field</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_version() -&gt; decltype(std::get&lt;TransportFieldIdx_version&gt;(transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_version&gt;(transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Access the &quot;version&quot; extra transport field (const version)</span></div>
<div class="line">    <span class="keyword">auto</span> transportField_version() const -&gt; decltype(std::get&lt;TransportFieldIdx_version&gt;(transportFields()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::get&lt;TransportFieldIdx_version&gt;(transportFields());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Definition of the transport field&#39;s types</span></div>
<div class="line">    <span class="keyword">using</span> TransportField_version = MyVersionField;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    TransportFields m_transportFields;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> For reference see also description of <a class="el" href="classcomms_1_1Message.html#a6da7116040cb3e35912aa4b82a2a66b1">comms::Message::transportFields()</a> member function.</p>
<p>Access to the version information given a reference to message object may now be implemented as: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(my_protocol::Message&lt;&gt;&amp; msg)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Retrieve the version numeric value</span></div>
<div class="line">    <span class="keyword">auto</span> versionValue = msg.transportField_version().value();</div>
<div class="line"> </div>
<div class="line">    ... <span class="comment">// do something with version information</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <b>NOTE</b>, that the defined "extra transport fields" are there to attach some extra information, delivered as part of transport framing, to message object itself. These fields are <b>NOT</b> getting serialised / deserialised when message object (payload) being read / written.</p>
<p>The <a class="el" href="classcomms_1_1Message.html">comms::Message</a> interface class defines <a class="el" href="classcomms_1_1Message.html#a57f6dc0452da23c5cdf25ec56b26df80">comms::Message::hasTransportFields()</a> static constexpr member function, which may be used at compile time to determine whether the <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option has been used, i.e. the message interface class defines mentioned earlier types and functions.</p>
<h2><a class="anchor" id="page_use_prot_extra_transport_version"></a>
Built-in Version Support</h2>
<p>The <b>COMMS</b> library contain a built-in protocol version support when version info is provided within <a class="el" href="page_use_prot.html#page_use_prot_extra_transport">Extra Transport Values</a>. To support this feature, the message interface definition class needs to use <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option, in addition to <a class="el" href="structcomms_1_1option_1_1def_1_1ExtraTransportFields.html">comms::option::def::ExtraTransportFields</a> option itself, to specify which field is <b>version</b>. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Field describing protocol version.</span></div>
<div class="line"><span class="keyword">using</span> MyVersionField = <a class="code" href="classcomms_1_1field_1_1IntValue.html">comms::field::IntValue</a>&lt;...&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Relevant extra transport fields, bundled in std::tuple</span></div>
<div class="line"><span class="keyword">using</span> MyExtraTransportFields =</div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        MyVersionField</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;</div>
<div class="line">        comms::option::def::BigEndian,</div>
<div class="line">        comms::option::def::MsgIdType&lt;MsgId&gt;,</div>
<div class="line">        comms::option::def::ExtraTransportFields&lt;MyExtraTransportFields&gt;,</div>
<div class="line">        comms::option::def::VersionInExtraTransportFields&lt;0&gt;</div>
<div class="line">        TOptions...</div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> Usage of <a class="el" href="structcomms_1_1option_1_1def_1_1VersionInExtraTransportFields.html">comms::option::def::VersionInExtraTransportFields</a> option generates inner <b>VersionType</b> type (see <a class="el" href="classcomms_1_1Message.html#adf1cc4a66938068978b802ae5b76a2d1">comms::Message::VersionType</a>) as well as <b><a class="el" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe" title="Version of the COMMS library as single numeric value.">version()</a></b> access functions (see <a class="el" href="classcomms_1_1Message.html#a5ad5c5b59d08590aba3b1e97f4e8149c">comms::Message::version()</a>) for direct access to it. It is equivalent to having the following functions defined: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message : <span class="keyword">public</span></div>
<div class="line">    <a class="code" href="classcomms_1_1Message.html">comms::Message</a>&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// Type of extra fields</span></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a> = ...; <span class="comment">// Equals to ValueType of the relevant field.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accessors for the version info</span></div>
<div class="line">    <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a>&amp; <a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>();</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">VersionType</a>&amp; <a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
<div class="ttc" id="anamespacecomms_1_1option_html_aa2401dbc73075e26591fa9459745678f"><div class="ttname"><a href="namespacecomms_1_1option.html#aa2401dbc73075e26591fa9459745678f">comms::option::VersionType</a></div><div class="ttdeci">comms::option::def::VersionType&lt; T &gt; VersionType</div><div class="ttdoc">Same as comms::option::def::VersionType.</div><div class="ttdef"><b>Definition:</b> options.h:1768</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that updating the version information only modifies the value of the relevant transport fields itself. The message contents are not being updated. There is a need to invoke <b>doFieldsVersionUpdate()</b> member function (see <a class="el" href="classcomms_1_1MessageBase.html#a87ba954a125586e6a339aad7b0d11e7c">comms::MessageBase::doFieldsVersionUpdate()</a>), which will do the job of updating message contents accordingly. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::MyMessage&lt;...&gt;;</div>
<div class="line">MyMessage1 msg;</div>
<div class="line">msg.version() = 5U; <span class="comment">// Update the version</span></div>
<div class="line">msg.doFieldsVersionUpdate(); <span class="comment">// Update the message contents that depend on version</span></div>
</div><!-- fragment --><p> The <b>refresh</b> functionality (direct or polymorphic) also contains update of the fields' version, which can be used instead. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> updateVersion(MyMessage&amp; msg)</div>
<div class="line">{</div>
<div class="line">    msg.version() = 5U;</div>
<div class="line">    msg.refresh(); <span class="comment">// Polymorphically update the message contents accordingly</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="page_use_prot_pseudo_transport"></a>
Pseudo Transport Values</h1>
<p>Some communication protocols have values (such as protocol version information), which are reported in the payload of one of the messages and may influence the way how other messages being deserialised and/or handled. Usually it is some kind of <b>CONNECT</b> message. Such scenario is implemented in the very similar way to <a class="el" href="page_use_prot.html#page_use_prot_extra_transport">Extra Transport Values</a>. The protocol stack is still defined using <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> but with <a class="el" href="structcomms_1_1option_1_1def_1_1PseudoValue.html">comms::option::def::PseudoValue</a> option. Such layer contains the "pseudo" field in its internal data members and pretends to read it during <b>read</b> operation.</p>
<p>Let's assume the protocol framing is defined to be </p><div class="fragment"><div class="line">SIZE | ID | PAYLOAD</div>
</div><!-- fragment --><p> but there is some kind of <b>CONNECT</b> message that reports client protocol version. The transport framing will probably be defined as if it handles the following stack. </p><div class="fragment"><div class="line">SIZE | ID | VERSION (pseudo) | PAYLOAD</div>
</div><!-- fragment --><p> The transport framing is expected to be defined as below providing an access to the VERSION handling layer: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;</div>
<div class="line">    <span class="keyword">typename</span> TMessage, <span class="comment">// common interface class defined by the application</span></div>
<div class="line">    <span class="keyword">typename</span> TInputMessages = AllMessages&lt;TMessage&gt;, <span class="comment">// Input messages that need to be recognised</span></div>
<div class="line">    <span class="keyword">typename</span> TAllocationOptions = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>, <span class="comment">// Extra options for MsgIdLayer</span></div>
<div class="line">    <span class="keyword">typename</span> TPayloadOptions = <a class="code" href="structcomms_1_1option_1_1app_1_1EmptyOption.html">comms::option::app::EmptyOption</a> <span class="comment">// Extra options for payload storage</span></div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">struct </span>ProtocolStack : <span class="keyword">public</span> </div>
<div class="line">    MySizePrefix&lt;TMessage, TInputMessages, TAllocationOptions, TPayloadOptions&gt; </div>
<div class="line">{</div>
<div class="line">    COMMS_PROTOCOL_LAYERS_ACCESS(payload, <a class="code" href="namespacecomms.html#a124576497d233cf87eb7432190e6c9fe">version</a>, <span class="keywordtype">id</span>, size);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> Then after reception and handling of the mentioned <b>CONNECT</b> message, the stored pseudo version field may be accessed using <b>pseudoField()</b> member function of <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html">comms::protocol::TransportValueLayer</a> layer (see <a class="el" href="classcomms_1_1protocol_1_1TransportValueLayer.html#ae0c3d9fe16b720fa29300a6230743564">comms::protocol::TransportValueLayer::pseudoField()</a>) and updated with reported value. </p><div class="fragment"><div class="line">ProtStack protStack; <span class="comment">// Protocol stack object</span></div>
<div class="line">protStack.layer_version().pseudoField().value() = connectMsg.field_version().value();</div>
</div><!-- fragment --><p> From now on every received message will have appropriate extra transport field updated accordingly right after receiving of the message and before its <b>read</b> operation being performed.</p>
<h1><a class="anchor" id="page_use_prot_msg_customisation"></a>
Application Specific Customisation of Messages</h1>
<p>When most of the messages are uni-directional, i.e. are either only sent or only received, then it may make sense to split the common message interface class <b>MyMessage</b> (see <a class="el" href="page_use_prot.html#page_use_prot_interface">Defining Message Interface Class</a>) into two interface classes: for <b>input</b> and for <b>output</b>. It will save the generation of unnecessary virtual functions which are not used, but occupy space. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyInputMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1ReadIterator.html">comms::option::app::ReadIterator&lt;const std::uint8_t*&gt;</a>, <span class="comment">// polymorphic read</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1Handler.html">comms::option::app::Handler&lt;MyHandler&gt;</a> <span class="comment">// polymorphic dispatch</span></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">using</span> MyOutputMessage = </div>
<div class="line">    my_protocol::Message&lt;</div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1WriteIterator.html">comms::option::app::WriteIterator&lt;std::uint8_t*&gt;</a>, <span class="comment">// polymorphic write</span></div>
<div class="line">        <a class="code" href="namespacecomms_1_1option.html#a03117ed117740f000541038e3670bf0e">comms::option::app::IdInfoInterface</a>, <span class="comment">// polymorphic ID retrieve</span></div>
<div class="line">        <a class="code" href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a> <span class="comment">// polymorphic serialisation length retrieve</span></div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyInputMessage1 = my_protocol::Message1&lt;MyInputMessage&gt;;</div>
<div class="line"><span class="keyword">using</span> MyInputMessage2 = my_protocol::Message2&lt;MyInputMessage&gt;;</div>
<div class="line"><span class="keyword">using</span> MyInputMessage3 = my_protocol::Message3&lt;MyInputMessage&gt;;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">using MyOutputMessage7 = my_protocol::Message7&lt;MyOutputMessage&gt;;</div>
<div class="line"><span class="keyword">using</span> MyOutputMessage8 = my_protocol::Message8&lt;MyOutputMessage&gt;;</div>
<div class="line"><span class="keyword">using</span> MyOutputMessage9 = my_protocol::Message9&lt;MyOutputMessage&gt;;</div>
<div class="line">...</div>
<div class="ttc" id="astructcomms_1_1option_1_1app_1_1LengthInfoInterface_html"><div class="ttname"><a href="structcomms_1_1option_1_1app_1_1LengthInfoInterface.html">comms::option::app::LengthInfoInterface</a></div><div class="ttdoc">Option used to add length() function into Message interface.</div><div class="ttdef"><b>Definition:</b> options.h:1259</div></div>
</div><!-- fragment --><p> There may be also an opposite case, when most of the messages are bi-directional, while only few go one way. For most applications the single common message interface will do the job. However generating unnecessary virtual functions for bare-metal application may be a heavy price to pay, especially when ROM size is small. The <b>COMMS</b> library provides several options that inhibit generation of virtual functions. These extra options need to be passed to <a class="el" href="classcomms_1_1MessageBase.html">comms::MessageBase</a> class when defining a message class. Available options are: </p><ul>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoReadImpl.html">comms::option::app::NoReadImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoWriteImpl.html">comms::option::app::NoWriteImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoValidImpl.html">comms::option::app::NoValidImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoLengthImpl.html">comms::option::app::NoLengthImpl</a> </li>
<li><a class="el" href="structcomms_1_1option_1_1app_1_1NoDispatchImpl.html">comms::option::app::NoDispatchImpl</a></li>
</ul>
<p>In order to be able to pass these extra options to message definition classes, the support from the latter is required. If the protocol definition follows a recommended approach the message definition is expected to reuse extra protocol options structure (<b>DefaultOptions</b>) described earlier. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>my_protocol</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allow passing extra options to messages as well</span></div>
<div class="line"><span class="keyword">struct </span>DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> Message1 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">        <span class="keyword">using</span> Message2 = <a class="code" href="namespacecomms_1_1option.html#a7cab23e160841f8b640b5afeccd8b664">comms::option::app::EmptyOption</a>;</div>
<div class="line">        ...</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>message</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TBase, <span class="keyword">typename</span> TOpt = DefaultOptions&gt;</div>
<div class="line"><span class="keyword">class </span>Message1 : <span class="keyword">public</span> </div>
<div class="line">    <a class="code" href="classcomms_1_1MessageBase.html">comms::MessageBase</a>&lt;</div>
<div class="line">        TBase, </div>
<div class="line">        comms::option::def::StaticNumIdImpl&lt;MsgId_Message1&gt;,</div>
<div class="line">        comms::option::def::FieldsImpl&lt;Message1Fields&lt;TOpt&gt;::All&gt;,</div>
<div class="line">        comms::option::def::MsgType&lt;Message1&lt;TBase, TOpt&gt; &gt;,</div>
<div class="line">        typename TOpt::message::Message1 <span class="comment">// Extra options </span></div>
<div class="line">    &gt;</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace message</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace my_protocol</span></div>
</div><!-- fragment --><p> As an example let's assume, that <b>Message1</b> is only sent by the application, but never received, and <b>Message</b> 2 is the opposite, only received by never sent. In this case defining the following options structure and passing them in to message definition classes will work </p><div class="fragment"><div class="line"><span class="keyword">struct </span>MyOptions : <span class="keyword">public</span> my_protocol::DefaultOptions</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>message : <span class="keyword">public</span> my_protocol::DefaultOptions::message</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> Message1 = <a class="code" href="namespacecomms_1_1option.html#a2c4f4dc2770b81385f922d49cf2949c6">comms::option::app::NoReadImpl</a>;</div>
<div class="line">        <span class="keyword">using</span> Message2 = <a class="code" href="namespacecomms_1_1option.html#aef37f12c38decbef4ef6c4b6fe108219">comms::option::app::NoWriteImpl</a>;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyMessage1 = my_protocol::Message1&lt;MyMessage, MyOptions&gt;;</div>
<div class="line"><span class="keyword">using</span> MyMessage2 = my_protocol::Message2&lt;MyMessage, MyOptions&gt;;</div>
<div class="ttc" id="anamespacecomms_1_1option_html_a2c4f4dc2770b81385f922d49cf2949c6"><div class="ttname"><a href="namespacecomms_1_1option.html#a2c4f4dc2770b81385f922d49cf2949c6">comms::option::NoReadImpl</a></div><div class="ttdeci">comms::option::app::NoReadImpl NoReadImpl</div><div class="ttdoc">Same as comms::option::app::NoReadImpl.</div><div class="ttdef"><b>Definition:</b> options.h:1835</div></div>
<div class="ttc" id="anamespacecomms_1_1option_html_aef37f12c38decbef4ef6c4b6fe108219"><div class="ttname"><a href="namespacecomms_1_1option.html#aef37f12c38decbef4ef6c4b6fe108219">comms::option::NoWriteImpl</a></div><div class="ttdeci">comms::option::app::NoWriteImpl NoWriteImpl</div><div class="ttdoc">Same as comms::option::app::NoWriteImpl.</div><div class="ttdef"><b>Definition:</b> options.h:1838</div></div>
</div><!-- fragment --><h1><a class="anchor" id="page_use_prot_msg_extension"></a>
Message Interface Extension</h1>
<p>Sometimes the public interface of the messages, generated by the <b>COMMS</b> library out of available options passed to <a class="el" href="classcomms_1_1Message.html">comms::Message</a>, may be insufficient for some applications and its interface needs to be extended with custom member functions. It is easy to achieve by just implementing required function in common message interface class </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage : <span class="keyword">public</span> my_protocol::Message&lt;...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> someFunc()</div>
<div class="line">    {</div>
<div class="line">        someFuncImpl();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> someFuncImpl() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> All the protocol messages must also be extended in order to implement missing virtual function </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMessage1 : <span class="keyword">public</span> my_protocol::Message1&lt;MyMessage&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> someFuncImpl()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Don't forget to bundle newly defined messages in <b>std::tuple</b> and pass them to <a class="el" href="page_use_prot.html#page_use_prot_transport">Transport Framing</a> definition or <a class="el" href="page_use_prot.html#page_use_prot_handling_generic">Generic Handler</a> when needed. </p><div class="fragment"><div class="line"><span class="keyword">using</span> MyInputMessages = </div>
<div class="line">    std::tuple&lt;</div>
<div class="line">        MyMessage1, </div>
<div class="line">        MyMessage2,</div>
<div class="line">        ...</div>
<div class="line">    &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyProtocolStack = my_protocol::ProtocolStack&lt;MyMessage, MyInputMessages&gt;;</div>
<div class="line"><span class="keyword">using</span> MyHandler = <a class="code" href="classcomms_1_1GenericHandler.html">comms::GenericHandler&lt;MyMessage, MyInputMessages&gt;</a>;</div>
<div class="line">...</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
